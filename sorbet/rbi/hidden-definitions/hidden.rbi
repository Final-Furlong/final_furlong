# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AbstractController::ActionNotFound
  include ::DidYouMean::Correctable
  def action(); end

  def controller(); end

  def initialize(message=T.unsafe(nil), controller=T.unsafe(nil), action=T.unsafe(nil)); end
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*arg); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ClassMethods
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::ConfigMethods
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key, &block); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

module AbstractController::Caching::Fragments::ClassMethods
end

module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
end

module AbstractController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module AbstractController::Callbacks
end

class AbstractController::Callbacks::ActionFilter
  def after(controller); end

  def around(controller); end

  def before(controller); end

  def initialize(actions); end

  def match?(controller); end
end

class AbstractController::Callbacks::ActionFilter
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end

  def after_action(*names, &blk); end

  def append_after_action(*names, &blk); end

  def append_around_action(*names, &blk); end

  def append_before_action(*names, &blk); end

  def around_action(*names, &blk); end

  def before_action(*names, &blk); end

  def prepend_after_action(*names, &blk); end

  def prepend_around_action(*names, &blk); end

  def prepend_before_action(*names, &blk); end

  def skip_after_action(*names); end

  def skip_around_action(*names); end

  def skip_before_action(*names); end
end

module AbstractController::Callbacks::ClassMethods
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
end

module AbstractController::Collector
  def atom(*args, **arg, &block); end

  def bmp(*args, **arg, &block); end

  def css(*args, **arg, &block); end

  def csv(*args, **arg, &block); end

  def gif(*args, **arg, &block); end

  def gzip(*args, **arg, &block); end

  def html(*args, **arg, &block); end

  def ics(*args, **arg, &block); end

  def jpeg(*args, **arg, &block); end

  def js(*args, **arg, &block); end

  def json(*args, **arg, &block); end

  def m4a(*args, **arg, &block); end

  def mp3(*args, **arg, &block); end

  def mp4(*args, **arg, &block); end

  def mpeg(*args, **arg, &block); end

  def multipart_form(*args, **arg, &block); end

  def ogg(*args, **arg, &block); end

  def otf(*args, **arg, &block); end

  def pdf(*args, **arg, &block); end

  def png(*args, **arg, &block); end

  def rss(*args, **arg, &block); end

  def svg(*args, **arg, &block); end

  def text(*args, **arg, &block); end

  def tiff(*args, **arg, &block); end

  def ttf(*args, **arg, &block); end

  def turbo_stream(*args, **arg, &block); end

  def url_encoded_form(*args, **arg, &block); end

  def vcf(*args, **arg, &block); end

  def vtt(*args, **arg, &block); end

  def webm(*args, **arg, &block); end

  def woff(*args, **arg, &block); end

  def woff2(*args, **arg, &block); end

  def xml(*args, **arg, &block); end

  def yaml(*args, **arg, &block); end

  def zip(*args, **arg, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
  def _helpers(); end
end

module AbstractController::Helpers::ClassMethods
  def _helpers=(_helpers); end

  def _helpers_for_modification(); end

  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*methods); end

  def inherited(klass); end

  def modules_for_helpers(modules_or_helper_prefixes); end
end

module AbstractController::Helpers::ClassMethods
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
end

module AbstractController::Translation
  def l(object, **options); end

  def localize(object, **options); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(val); end

  def t(key, **options); end

  def translate(key, **options); end
end

module AbstractController::Translation
  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(val); end
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
end

module AbstractController
  extend ::ActiveSupport::Autoload
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Channel::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(periodic_timers); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(value); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcast_to(*arg, **arg1, &arg2); end

  def broadcasting_for(*arg, **arg1, &arg2); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::ChannelStub
  def confirmed?(); end

  def rejected?(); end

  def start_periodic_timers(); end

  def stop_all_streams(); end

  def stop_periodic_timers(); end

  def stream_from(broadcasting, *arg); end

  def streams(); end
end

class ActionCable::Channel::ConnectionStub
  def connection_identifier(); end

  def identifiers(); end

  def initialize(identifiers=T.unsafe(nil)); end

  def logger(); end

  def subscriptions(); end

  def transmissions(); end

  def transmit(cable_message); end
end

module ActionCable::Channel::Naming
  def channel_name(*arg, **arg1, &arg2); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

class ActionCable::Channel::NonInferrableChannelError
  def initialize(name); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::Streams
  def pubsub(*arg, **arg1, &arg2); end

  def stop_all_streams(); end

  def stop_stream_for(model); end

  def stop_stream_from(broadcasting); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_or_reject_for(model); end
end

class ActionCable::Channel::TestCase
  def _channel_class(); end

  def _channel_class=(_channel_class); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

class ActionCable::Channel::TestCase
  def self._channel_class(); end

  def self._channel_class=(value); end

  def self._channel_class?(); end
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Base
  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*arg, **arg1, &arg2); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*arg, **arg1, &arg2); end

  def receive(websocket_message); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::NonInferrableConnectionError
  def initialize(name); end
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*arg, **arg1, &arg2); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger, &block); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TestCase
  def _connection_class(); end

  def _connection_class=(_connection_class); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

class ActionCable::Connection::TestCase
  def self._connection_class(); end

  def self._connection_class=(value); end

  def self._connection_class?(); end
end

module ActionCable::Connection::TestConnection
  def initialize(request); end

  def logger(); end

  def request(); end
end

class ActionCable::Connection::TestCookieJar
  def encrypted(); end

  def signed(); end
end

class ActionCable::Connection::TestRequest
  def cookie_jar=(cookie_jar); end

  def session=(session); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  def disconnect(); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection
  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end
end

class ActionCable::Server::Base
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(val); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def precompile_assets(); end

  def precompile_assets=(precompile_assets); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Server::Worker
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection, &block); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(&block); end
end

class ActionCable::Server::Worker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap
  def add_subscriber(*arg); end

  def initialize(event_loop); end

  def invoke_callback(*arg); end
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def identifier(); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*arg); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data, &block); end

  def assert_broadcasts(stream, number, &block); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*arg, **arg1, &arg2); end

  def clear_messages(*arg, **arg1, &arg2); end

  def pubsub_adapter(); end
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::StrongParameters
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActionController::Logging
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(mimes_for_respond_to); end

  def mimes_for_respond_to?(); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(responder); end

  def responder?(); end
  MODULES = ::T.let(nil, ::T.untyped)
end

module ActionController::API::HelperMethods
  def current_user(*args, **arg, &block); end

  def devise_controller?(*args, **arg, &block); end

  def signed_in?(*args, **arg, &block); end

  def user_session(*args, **arg, &block); end

  def user_signed_in?(*args, **arg, &block); end

  def warden(*args, **arg, &block); end
end

module ActionController::API::HelperMethods
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Logging::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(value); end

  def self.mimes_for_respond_to?(); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(value); end

  def self.responder?(); end

  def self.without_modules(*modules); end
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
end

class ActionController::BadRequest
  def initialize(msg=T.unsafe(nil)); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::PermissionsPolicy
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActionController::Logging
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::Turbo::Native::Navigation
  include ::Turbo::Frames::FrameRequest
  include ::Turbo::Streams::TurboStreamsTagBuilder
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(etag_with_template_digest); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def flash(*arg, **arg1, &arg2); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(mimes_for_respond_to); end

  def mimes_for_respond_to?(); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(responder); end

  def responder?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def urlsafe_csrf_tokens(); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  def alert(*args, **arg, &block); end

  def combined_fragment_cache_key(*args, **arg, &block); end

  def content_security_policy?(*args, **arg, &block); end

  def content_security_policy_nonce(*args, **arg, &block); end

  def cookies(*args, **arg, &block); end

  def current_user(*args, **arg, &block); end

  def devise_controller?(*args, **arg, &block); end

  def form_authenticity_token(*args, **arg, &block); end

  def notice(*args, **arg, &block); end

  def protect_against_forgery?(*args, **arg, &block); end

  def signed_in?(*args, **arg, &block); end

  def user_session(*args, **arg, &block); end

  def user_signed_in?(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end

  def warden(*args, **arg, &block); end
end

module ActionController::Base::HelperMethods
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::PermissionsPolicy::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Logging::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(value); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(value); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(value); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(value); end

  def self.mimes_for_respond_to?(); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(value); end

  def self.responder?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.urlsafe_csrf_tokens(); end

  def self.urlsafe_csrf_tokens=(urlsafe_csrf_tokens); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::BasicImplicitRender
end

module ActionController::Caching
end

module ActionController::Caching
  extend ::ActiveSupport::Concern
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), cache_control: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def no_store(); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ConditionalGet::ClassMethods
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
end

module ActionController::ContentSecurityPolicy
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::DefaultHeaders
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::DefaultHeaders::ClassMethods
end

module ActionController::DefaultHeaders
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithFlash
end

module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
end

module ActionController::Flash
end

module ActionController::Flash::ClassMethods
  def action_methods(); end

  def add_flash_types(*types); end
end

module ActionController::Flash::ClassMethods
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::FormBuilder::ClassMethods
end

module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def helpers(); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers::ClassMethods
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
end

module ActionController::HttpAuthentication
end

module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::ImplicitRender
end

module ActionController::Instrumentation
  def redirect_to(*arg); end

  def render(*arg); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Instrumentation::ClassMethods
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end

  def send_stream(filename:, disposition: T.unsafe(nil), type: T.unsafe(nil)); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end

  def writeln(string); end
end

class ActionController::Live::Buffer
  def self.queue_size(); end

  def self.queue_size=(queue_size); end
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

module ActionController::Live::ClassMethods
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
  extend ::ActiveSupport::Concern
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LiveTestResponse
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

module ActionController::Logging
end

module ActionController::Logging::ClassMethods
  def log_at(level, **options); end
end

module ActionController::Logging::ClassMethods
end

module ActionController::Logging
  extend ::ActiveSupport::Concern
end

class ActionController::Metal
  include ::ActionController::Testing::Functional
  def content_type(*arg, **arg1, &arg2); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*arg, **arg1, &arg2); end

  def location(*arg, **arg1, &arg2); end

  def location=(arg); end

  def media_type(*arg, **arg1, &arg2); end

  def middleware_stack(); end

  def middleware_stack=(middleware_stack); end

  def middleware_stack?(); end

  def params(); end

  def params=(val); end

  def request(); end

  def request=(request); end

  def reset_session(); end

  def response(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*arg, **arg1, &arg2); end

  def session(*arg, **arg1, &arg2); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*arg, **arg1, &arg2); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.action_encoding_template(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(value); end

  def self.middleware_stack?(); end

  def self.use(*arg, **arg1, &arg2); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

module ActionController::MimeResponds
  def respond_to(*mimes); end
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def any_response?(); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

class ActionController::MimeResponds::Collector
end

module ActionController::MimeResponds
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

module ActionController::ParameterEncoding
end

module ActionController::ParameterEncoding::ClassMethods
  def action_encoding_template(action); end

  def inherited(klass); end

  def param_encoding(action, param, encoding); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

module ActionController::ParameterEncoding::ClassMethods
end

module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern
end

class ActionController::ParameterMissing
  def initialize(param, keys=T.unsafe(nil)); end

  def keys(); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def always_permitted_parameters(); end

  def always_permitted_parameters=(val); end

  def as_json(*arg, **arg1, &arg2); end

  def compact(); end

  def compact!(); end

  def compact_blank(); end

  def compact_blank!(); end

  def converted_arrays(); end

  def deep_transform_keys(&block); end

  def deep_transform_keys!(&block); end

  def delete(key, &block); end

  def delete_if(&block); end

  def dig(*keys); end

  def each(&block); end

  def each_key(*arg, **arg1, &arg2); end

  def each_nested_attribute(); end

  def each_pair(&block); end

  def each_value(&block); end

  def empty?(*arg, **arg1, &arg2); end

  def eql?(other); end

  def except(*keys); end

  def extract!(*keys); end

  def fetch(key, *args); end

  def has_key?(*arg, **arg1, &arg2); end

  def has_value?(*arg, **arg1, &arg2); end

  def include?(*arg, **arg1, &arg2); end

  def init_with(coder); end

  def initialize(parameters=T.unsafe(nil), logging_context=T.unsafe(nil)); end

  def keep_if(&block); end

  def key?(*arg, **arg1, &arg2); end

  def keys(*arg, **arg1, &arg2); end

  def member?(*arg, **arg1, &arg2); end

  def merge(other_hash); end

  def merge!(other_hash); end

  def nested_attributes?(); end

  def parameters(); end

  def permit(*filters); end

  def permit!(); end

  def permitted=(permitted); end

  def permitted?(); end

  def reject(&block); end

  def reject!(&block); end

  def require(key); end

  def required(key); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def select(&block); end

  def select!(&block); end

  def slice(*keys); end

  def slice!(*keys); end

  def stringify_keys(); end

  def to_h(); end

  def to_hash(); end

  def to_param(*args); end

  def to_query(*args); end

  def to_s(*arg, **arg1, &arg2); end

  def to_unsafe_h(); end

  def to_unsafe_hash(); end

  def transform_keys(&block); end

  def transform_keys!(&block); end

  def transform_values(); end

  def transform_values!(); end

  def value?(*arg, **arg1, &arg2); end

  def values(*arg, **arg1, &arg2); end

  def values_at(*keys); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  def self.action_on_unpermitted_parameters(); end

  def self.action_on_unpermitted_parameters=(val); end

  def self.always_permitted_parameters(); end

  def self.always_permitted_parameters=(val); end

  def self.hook_into_yaml_loading(); end

  def self.nested_attribute?(key, value); end

  def self.permit_all_parameters(); end

  def self.permit_all_parameters=(val); end
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

module ActionController::PermissionsPolicy
end

module ActionController::PermissionsPolicy::ClassMethods
  def permissions_policy(**options, &block); end
end

module ActionController::PermissionsPolicy::ClassMethods
end

module ActionController::PermissionsPolicy
  extend ::ActiveSupport::Concern
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
end

module ActionController::Railties
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_back_or_to(fallback_location, allow_other_host: T.unsafe(nil), **options); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end

  def url_from(location); end
end

class ActionController::Redirecting::UnsafeRedirectError
end

class ActionController::Redirecting::UnsafeRedirectError
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def render_to_string(*args); end

  def with_defaults(defaults); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_turbo_stream(turbo_streams_html, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers::ClassMethods
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*arg); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*arg, **arg1, &arg2); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::Rendering::ClassMethods
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  def protect_from_forgery(options=T.unsafe(nil)); end

  def skip_forgery_protection(options=T.unsafe(nil)); end
end

module ActionController::RequestForgeryProtection::ClassMethods
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end

  def warning_message(); end

  def warning_message=(warning_message); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*arg); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def enabled?(); end

  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
end

class ActionController::RespondToMismatchError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
end

class ActionController::Responder
  def error_rendering_options(); end

  def redirect_status(); end

  def redirect_status=(val); end
end

class ActionController::Responder
  def self.redirect_status(); end

  def self.redirect_status=(val); end
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
end

module ActionController::Streaming
end

module ActionController::StrongParameters
  def params(); end

  def params=(value); end
end

module ActionController::StrongParameters
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::TemplateAssertions
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Shoulda::Matchers::ActionController
  include ::Shoulda::Matchers::Routing
  def _controller_class(); end

  def _controller_class=(_controller_class); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  extend ::Shoulda::Matchers::ActionController
  extend ::Shoulda::Matchers::Routing
  def self._controller_class(); end

  def self._controller_class=(value); end

  def self._controller_class?(); end

  def self.executor_around_each_request(); end

  def self.executor_around_each_request=(executor_around_each_request); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def dig(*keys); end

  def enabled?(); end

  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
end

module ActionController::Testing
end

module ActionController::Testing::Functional
  def clear_instance_variables_between_requests(); end

  def recycle!(); end
end

module ActionController::Testing::Functional
end

module ActionController::Testing
end

class ActionController::UnfilteredParameters
  def initialize(); end
end

class ActionController::UnfilteredParameters
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
end

class ActionController::UrlGenerationError
  include ::DidYouMean::Correctable
  def initialize(message, routes=T.unsafe(nil), route_name=T.unsafe(nil), method_name=T.unsafe(nil)); end

  def method_name(); end

  def route_name(); end

  def routes(); end
end

class ActionController::UrlGenerationError
end

module ActionDispatch
  def test_app(); end

  def test_app=(val); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(val); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(val); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def setup(); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil), nonce_directives=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def prefetch_src(*sources); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def require_trusted_types_for(*sources); end

  def sandbox(*values); end

  def script_src(*sources); end

  def script_src_attr(*sources); end

  def script_src_elem(*sources); end

  def style_src(*sources); end

  def style_src_attr(*sources); end

  def style_src_elem(*sources); end

  def trusted_types(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(generator); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SAME_SITE_PROTECTION = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(val); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*arg); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(val); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::MarshalWithJsonFallback
end

class ActionDispatch::Cookies::MarshalWithJsonFallback
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*arg); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def exception_trace(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_response?(); end

  def rescue_responses(); end

  def rescue_responses=(val); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(val); end

  def silent_exceptions(); end

  def silent_exceptions=(val); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(val); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(val); end

  def self.rescue_templates(); end

  def self.rescue_templates=(val); end

  def self.silent_exceptions(); end

  def self.silent_exceptions=(val); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(val); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::FileHandler
  def attempt(env); end

  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil), precompressed: T.unsafe(nil), compressible_content_types: T.unsafe(nil)); end
  PRECOMPRESSED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, exclude: T.unsafe(nil), response_app: T.unsafe(nil)); end
  ALLOWED_HOSTS_IN_DEVELOPMENT = ::T.let(nil, ::T.untyped)
  IPV4_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME_WITH_PORT = ::T.let(nil, ::T.untyped)
  PORT_REGEX = ::T.let(nil, ::T.untyped)
  VALID_IP_HOSTNAME = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::DefaultResponseApp
  def call(env); end
  RESPONSE_STATUS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::DefaultResponseApp
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

class ActionDispatch::HostAuthorization::Permissions
end

class ActionDispatch::HostAuthorization
end

module ActionDispatch::Http
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  NO_STORE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

class ActionDispatch::Http::ContentDisposition
  def ascii_filename(); end

  def disposition(); end

  def filename(); end

  def initialize(disposition:, filename:); end

  def utf8_filename(); end
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  def self.format(disposition:, filename:); end
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def should_apply_vary_header?(); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::Parameters
  def parameters(); end

  def params(); end

  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def secure_protocol(); end

  def secure_protocol=(val); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(val); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.secure_protocol(); end

  def self.secure_protocol=(val); end

  def self.tld_length(); end

  def self.tld_length=(val); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end

  def to_path(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(**args); end

  def get(path, **args); end

  def head(path, **args); end

  def options(path, **args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def app(); end

  def assertions(); end

  def assertions=(assertions); end

  def assigns(*arg, **arg1, &arg2); end

  def before_setup(); end

  def cookies(*arg, **arg1, &arg2); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*arg, **arg1, &arg2); end

  def follow_redirect!(*arg, **arg1, &arg2); end

  def get(*arg, **arg1, &arg2); end

  def head(*arg, **arg1, &arg2); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*arg, **arg1, &arg2); end

  def post(*arg, **arg1, &arg2); end

  def put(*arg, **arg1, &arg2); end

  def remove!(); end

  def reset!(); end

  def root_session(); end

  def root_session=(root_session); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*arg, **arg1, &arg2); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def headers(*arg, **arg1, &arg2); end

  def host(); end

  def host!(arg); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*arg, **arg1, &arg2); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*arg, **arg1, &arg2); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*arg, **arg1, &arg2); end

  def status_message(*arg, **arg1, &arg2); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args, **options); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Ast
  def glob?(); end

  def initialize(tree, formatted); end

  def names(); end

  def path_params(); end

  def requirements=(requirements); end

  def root(); end

  def route=(route); end

  def terminals(); end

  def tree(); end

  def wildcard_options(); end
end

class ActionDispatch::Journey::Ast
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters); end

  def initialize(routes); end

  def routes(); end
end

class ActionDispatch::Journey::Formatter::MissingRoute
  def constraints(); end

  def initialize(constraints, missing_keys, unmatched_keys, routes, name); end

  def message(); end

  def missing_keys(); end

  def name(); end

  def params(); end

  def path(method_name); end

  def routes(); end

  def unmatched_keys(); end
end

class ActionDispatch::Journey::Formatter::MissingRoute
end

class ActionDispatch::Journey::Formatter::RouteWithParams
  def initialize(route, parameterized_parts, params); end

  def params(); end

  def path(_); end
end

class ActionDispatch::Journey::Formatter::RouteWithParams
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY_END_NODE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
  INITIAL_STATE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, full_string, start_index, end_index); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  DEFAULT_EXP_ANCHORED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
  def regexp(); end

  def regexp=(regexp); end
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def initialize(left, regexp=T.unsafe(nil)); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  GREEDY_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def match?(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def requirements_anchored?(); end

  def requirements_for_missing_keys_check(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def named_captures(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name:, path:, app: T.unsafe(nil), constraints: T.unsafe(nil), required_defaults: T.unsafe(nil), defaults: T.unsafe(nil), request_method_match: T.unsafe(nil), precedence: T.unsafe(nil), scope_options: T.unsafe(nil), internal: T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def scope_options(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route
  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def delete!(target); end

  def each(&block); end

  def initialize(*args); end

  def insert(index, klass, *args, **arg, &block); end

  def insert_after(index, *args, **arg, &block); end

  def insert_before(index, klass, *args, **arg, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def move(target, source); end

  def move_after(target, source); end

  def move_before(target, source); end

  def size(); end

  def swap(target, *args, **arg, &block); end

  def unshift(klass, *args, **arg, &block); end

  def use(klass, *args, **arg, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::MissingController
end

class ActionDispatch::MissingController
end

class ActionDispatch::PermissionsPolicy
  def accelerometer(*sources); end

  def ambient_light_sensor(*sources); end

  def autoplay(*sources); end

  def build(context=T.unsafe(nil)); end

  def camera(*sources); end

  def directives(); end

  def encrypted_media(*sources); end

  def fullscreen(*sources); end

  def geolocation(*sources); end

  def gyroscope(*sources); end

  def magnetometer(*sources); end

  def microphone(*sources); end

  def midi(*sources); end

  def payment(*sources); end

  def picture_in_picture(*sources); end

  def speaker(*sources); end

  def usb(*sources); end

  def vibrate(*sources); end

  def vr(*sources); end
end

class ActionDispatch::PermissionsPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::PermissionsPolicy::Middleware
end

module ActionDispatch::PermissionsPolicy::Request
  def permissions_policy(); end

  def permissions_policy=(policy); end
  POLICY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::PermissionsPolicy::Request
end

class ActionDispatch::PermissionsPolicy
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::ActionDispatch::PermissionsPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::RequestCookieMethods
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def headers(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(val); end

  def key?(key); end

  def local?(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_fullpath(); end

  def original_script_name(); end

  def original_url(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def raw_request_method(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(val); end

  def routes(); end

  def routes=(routes); end

  def send_early_hints(links); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(val); end

  def self.parameter_parsers(); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(val); end
end

module ActionDispatch::RequestCookieMethods
  def authenticated_encrypted_cookie_salt(); end

  def commit_cookie_jar!(); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_same_site_protection(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def have_cookie_jar?(); end

  def key_generator(); end

  def secret_key_base(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end
end

module ActionDispatch::RequestCookieMethods
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app, header:); end
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(val); end

  def default_headers(); end

  def default_headers=(val); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(val); end

  def self.default_headers(); end

  def self.default_headers=(val); end

  def self.merge_default_headers(original, default); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Base
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
  def initialize(width: T.unsafe(nil)); end
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*arg); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  def delete(*args, &block); end

  def get(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set:, ast:, controller:, default_action:, to:, formatted:, via:, options_constraints:, anchor:, scope_params:, options:); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def collection(&block); end

  def draw(name); end

  def match(path, *rest, &block); end

  def member(&block); end

  def namespace(path, options=T.unsafe(nil)); end

  def nested(&block); end

  def new(&block); end

  def resource(*resources, &block); end

  def resources(*resources, &block); end

  def resources_path_names(options); end

  def root(path, options=T.unsafe(nil)); end

  def shallow(); end

  def shallow?(); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

module ActionDispatch::Routing::Mapper::Resources
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil), &block); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil), &block); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  include ::Devise::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def draw(&block); end

  def draw_paths(); end

  def draw_paths=(draw_paths); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def generate_url_helpers(supports_path); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil), method_name=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def _rails_admin(); end

  def main_app(); end

  def rails_admin(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&block); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, method_name, args, inner_options, url_strategy); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name); end

  def route_name(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(value); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*arg, **arg1, &arg2); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil), ssl_default_redirect_status: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
  PERMANENT_REDIRECT_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::ServerTiming
  def call(env); end

  def initialize(app); end
  SERVER_TIMING_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ServerTiming
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

module ActionDispatch::Session
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::DSLRSpecProxyInstaller
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  include ::ActionText::SystemTestHelper
  def initialize(*arg); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

  def self.driver(); end

  def self.driver=(value); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_teardown(); end
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  def self.test_app(); end

  def self.test_app=(val); end
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(val); end

  def incinerate_after(); end

  def incinerate_after=(val); end

  def ingress(); end

  def ingress=(val); end

  def logger(); end

  def logger=(val); end

  def queues(); end

  def queues=(val); end

  def storage_service(); end

  def storage_service=(val); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*arg, **arg1, &arg2); end

  def delivered!(*arg, **arg1, &arg2); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*arg, **arg1, &arg2); end

  def mail(*arg, **arg1, &arg2); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def router(); end

  def router=(val); end
end

class ActionMailbox::Base
  extend ::ActionMailbox::Routing::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionMailbox::Callbacks::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(val); end
end

class ActionMailbox::BaseController
end

class ActionMailbox::BaseController
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

module ActionMailbox::Callbacks::ClassMethods
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::GeneratedAttributeMethods
  include ::ActionMailbox::InboundEmail::GeneratedAssociationMethods
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  include ::ActionMailbox::InboundEmail::Incineratable
  def autosave_associated_records_for_raw_email_attachment(*args); end

  def autosave_associated_records_for_raw_email_blob(*args); end

  def mail(); end

  def processed?(); end

  def source(); end

  def typed_status(); end

  def typed_status=(value); end
  RelationType = ::T.let(nil, ::T.untyped)
end

class ActionMailbox::InboundEmail::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  def with_attached_raw_email(*arg, **arg1, &arg2); end
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
end

module ActionMailbox::InboundEmail::Incineratable
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::MessageId
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
end

module ActionMailbox::InboundEmail::MessageId
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

module ActionMailbox::InboundEmail::Routable
  extend ::ActiveSupport::Concern
end

class ActionMailbox::InboundEmail::Status
  Bounced = ::T.let(nil, ::T.untyped)
  Delivered = ::T.let(nil, ::T.untyped)
  Failed = ::T.let(nil, ::T.untyped)
  Pending = ::T.let(nil, ::T.untyped)
  Processing = ::T.let(nil, ::T.untyped)
end

class ActionMailbox::InboundEmail::Status
  extend ::T::Helpers
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

module ActionMailbox::Ingresses
end

module ActionMailbox::Ingresses::Mailgun
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
end

module ActionMailbox::Ingresses::Mailgun
end

module ActionMailbox::Ingresses::Mandrill
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end

  def health_check(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
end

module ActionMailbox::Ingresses::Mandrill
end

module ActionMailbox::Ingresses::Postmark
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
end

module ActionMailbox::Ingresses::Postmark
end

module ActionMailbox::Ingresses::Relay
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
end

module ActionMailbox::Ingresses::Relay
end

module ActionMailbox::Ingresses::Sendgrid
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
end

module ActionMailbox::Ingresses::Sendgrid
end

module ActionMailbox::Ingresses
end

class ActionMailbox::Record
  include ::ActionMailbox::Record::GeneratedAttributeMethods
  include ::ActionMailbox::Record::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

class ActionMailbox::Record::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::Record::GeneratedRelationMethods
end

class ActionMailbox::Record::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::Record::GeneratedRelationMethods
end

class ActionMailbox::Record::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::Record::GeneratedRelationMethods
end

module ActionMailbox::Record::GeneratedAssociationMethods
end

module ActionMailbox::Record::GeneratedAssociationMethods
end

module ActionMailbox::Record::GeneratedAttributeMethods
end

module ActionMailbox::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::Record::GeneratedRelationMethods
end

module ActionMailbox::Record::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionMailbox::Record
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def mailbox_for(inbound_email); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing::ClassMethods
  def mailbox_for(inbound_email); end

  def route(inbound_email); end

  def routing(routes); end
end

module ActionMailbox::Routing::ClassMethods
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options, &block); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs, &block); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.incinerate(); end

  def self.incinerate=(val); end

  def self.incinerate_after(); end

  def self.incinerate_after=(val); end

  def self.ingress(); end

  def self.ingress=(val); end

  def self.logger(); end

  def self.logger=(val); end

  def self.queues(); end

  def self.queues=(val); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.storage_service(); end

  def self.storage_service=(val); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::AbstractController::Rendering
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(default_params); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(val); end

  def delivery_job(); end

  def delivery_job=(delivery_job); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(delivery_methods); end

  def delivery_methods?(); end

  def email_address_with_name(address, name); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(file_settings); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def letter_opener_settings(); end

  def letter_opener_settings=(letter_opener_settings); end

  def letter_opener_settings?(); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(val); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(sendmail_settings); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(smtp_settings); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(test_settings); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionMailer::Base::HelperMethods
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  def combined_fragment_cache_key(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(value); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(val); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(value); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(value); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(value); end

  def self.delivery_methods?(); end

  def self.email_address_with_name(address, name); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(value); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.letter_opener_settings(); end

  def self.letter_opener_settings=(value); end

  def self.letter_opener_settings?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(val); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(val); end

  def self.preview_path(); end

  def self.preview_path=(val); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(val); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(value); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(val); end

  def self.smtp_settings(); end

  def self.smtp_settings=(value); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(value); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*arg, **arg1, &arg2); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ActionMailer::InlinePreviewInterceptor
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, kwargs: T.unsafe(nil), params: T.unsafe(nil)); end
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args, **arg); end

  def message(); end

  def processed?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args, **arg); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(_mailer_class); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(value); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
end

module ActionPack
  def self.gem_version(); end

  def self.version(); end
end

module ActionText::Attachable
  def as_json(*arg); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_attachable_partial_path(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

module ActionText::Attachables
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Model
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*arg, **arg1, &arg2); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*arg, **arg1, &arg2); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*arg, **arg1, &arg2); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, **arg, &block); end

  def node(); end

  def tag_name(); end

  def tag_name=(val); end

  def to_html(); end

  def to_param(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end

  def self.tag_name(); end

  def self.tag_name=(val); end
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Model
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*arg, **arg1, &arg2); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.attachment_selector(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end

  def self.selector(); end
end

module ActionText::Attachments
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::Caching
end

module ActionText::Attachments::Minification
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attribute
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern
end

class ActionText::Content
  include ::ActionText::Serialization
  include ::ActionText::Rendering
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*arg); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*arg, **arg1, &arg2); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*arg, **arg1, &arg2); end

  def render(*arg, **arg1, &arg2); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def to_html(); end

  def to_partial_path(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  extend ::ActionText::Rendering::ClassMethods
  def self.default_renderer(); end

  def self.default_renderer=(val); end

  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(val); end

  def allowed_tags(); end

  def allowed_tags=(val); end

  def render_action_text_attachment(attachment, locals: T.unsafe(nil)); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(val); end

  def scrubber(); end

  def scrubber=(val); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(val); end

  def self.allowed_tags(); end

  def self.allowed_tags=(val); end

  def self.sanitizer(); end

  def self.sanitizer=(val); end

  def self.scrubber(); end

  def self.scrubber=(val); end
end

class ActionText::EncryptedRichText
  include ::ActionText::EncryptedRichText::GeneratedAttributeMethods
end

class ActionText::EncryptedRichText::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
  include ::ActionText::EncryptedRichText::GeneratedRelationMethods
end

class ActionText::EncryptedRichText::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
  include ::ActionText::EncryptedRichText::GeneratedRelationMethods
end

class ActionText::EncryptedRichText::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
  include ::ActionText::EncryptedRichText::GeneratedRelationMethods
end

module ActionText::EncryptedRichText::GeneratedAttributeMethods
end

module ActionText::EncryptedRichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::EncryptedRichText::GeneratedRelationMethods
end

module ActionText::EncryptedRichText::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActionText::Encryption
  def decrypt(); end

  def encrypt(); end
end

module ActionText::Encryption
end

class ActionText::Engine
end

class ActionText::Engine
end

class ActionText::FixtureSet
end

class ActionText::FixtureSet
  def self.attachment(fixture_set_name, label, column_type: T.unsafe(nil)); end
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

class ActionText::Record
  include ::ActionText::Record::GeneratedAttributeMethods
  include ::ActionText::Record::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

class ActionText::Record::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::Record::GeneratedRelationMethods
end

class ActionText::Record::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::Record::GeneratedRelationMethods
end

class ActionText::Record::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::Record::GeneratedRelationMethods
end

module ActionText::Record::GeneratedAssociationMethods
end

module ActionText::Record::GeneratedAssociationMethods
end

module ActionText::Record::GeneratedAttributeMethods
end

module ActionText::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::Record::GeneratedRelationMethods
end

module ActionText::Record::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionText::Record
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module ActionText::Rendering
end

module ActionText::Rendering::ClassMethods
  def render(*args, &block); end

  def with_renderer(renderer); end
end

module ActionText::Rendering::ClassMethods
end

module ActionText::Rendering
  extend ::ActiveSupport::Concern
end

class ActionText::RichText
  include ::ActionText::RichText::GeneratedAttributeMethods
  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def nil?(*arg, **arg1, &arg2); end

  def present?(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def to_s(*arg, **arg1, &arg2); end

  def to_trix_html(); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

class ActionText::RichText::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
  def purge(); end

  def purge_later(); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds_attachment_ids=(ids); end

  def embeds_blob_ids=(ids); end

  def record_changed?(); end

  def record_previously_changed?(); end
end

module ActionText::RichText::GeneratedAttributeMethods
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::RichText::GeneratedRelationMethods
  def with_attached_embeds(*arg, **arg1, &arg2); end
end

module ActionText::RichText::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActionText::Serialization
  def _dump(*arg); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText::Serialization
  extend ::ActiveSupport::Concern
end

module ActionText::SystemTestHelper
  def fill_in_rich_text_area(locator=T.unsafe(nil), with:); end
end

module ActionText::SystemTestHelper
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(val); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText
  extend ::ActiveSupport::Autoload
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*arg, **arg1, &arg2); end

  def formats(*arg, **arg1, &arg2); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*arg, **arg1, &arg2); end
  NO_DETAILS = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
  def initialize(lookup_context, options); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, template); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::Kaminari::Helpers::HelperMethods
  include ::Kaminari::Helpers::UrlHelper
  include ::SimpleForm::ActionViewExtensions::FormHelper
  include ::Gretel::ViewHelpers
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Devise::Controllers::UrlHelpers
  include ::NestedForm::ViewHelper
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::Sprockets::Rails::Utils
  include ::Haml::Helpers::ActionViewMods
  def _routes(); end

  def _routes=(_routes); end

  def _routes?(); end

  def _run(method, template, locals, buffer, add_to_stack: T.unsafe(nil), &block); end

  def annotate_rendered_view_with_filenames(); end

  def annotate_rendered_view_with_filenames=(val); end

  def assets_environment(); end

  def assets_environment=(assets_environment); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(assets_precompile); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(val); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(check_precompiled_asset); end

  def check_precompiled_asset?(); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(debug_assets); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end

  def default_formats(); end

  def default_formats=(val); end

  def digest_assets(); end

  def digest_assets=(digest_assets); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(val); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def in_rendering_context(options); end

  def initialize(lookup_context, assigns, controller); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def logger=(logger); end

  def logger?(); end

  def lookup_context(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(precompiled_asset_checker); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(prefix_partial_path_with_controller_namespace); end

  def prefix_partial_path_with_controller_namespace?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(resolve_assets_with); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(val); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(unknown_asset_fallback); end

  def unknown_asset_fallback?(); end

  def view_paths(*arg, **arg1, &arg2); end

  def view_paths=(arg); end

  def view_renderer(); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(value); end

  def self._routes?(); end

  def self.annotate_rendered_view_with_filenames(); end

  def self.annotate_rendered_view_with_filenames=(val); end

  def self.assets_environment(); end

  def self.assets_environment=(value); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(value); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(value); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(value); end

  def self.assets_prefix?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(val); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(value); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(value); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end

  def self.default_form_builder(); end

  def self.default_form_builder=(val); end

  def self.default_formats(); end

  def self.default_formats=(val); end

  def self.digest_assets(); end

  def self.digest_assets=(value); end

  def self.digest_assets?(); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(val); end

  def self.logger(); end

  def self.logger=(value); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(value); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(value); end

  def self.prefix_partial_path_with_controller_namespace?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(value); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(val); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(value); end

  def self.unknown_asset_fallback?(); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry
end

class ActionView::CacheExpiry::Executor
  def complete(_); end

  def initialize(watcher:); end

  def run(); end
end

class ActionView::CacheExpiry::Executor
end

class ActionView::CacheExpiry::ViewModificationWatcher
  def execute_if_updated(); end

  def initialize(watcher:, &block); end
end

class ActionView::CacheExpiry::ViewModificationWatcher
end

class ActionView::CacheExpiry
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
end

class ActionView::CollectionRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_collection_derive_partial(collection, context, block); end

  def render_collection_with_partial(collection, partial, context, block); end
end

class ActionView::CollectionRenderer::CollectionIterator
  include ::Enumerable
  def each(&blk); end

  def initialize(collection); end

  def length(); end

  def size(); end
end

class ActionView::CollectionRenderer::CollectionIterator
end

class ActionView::CollectionRenderer::MixedCollectionIterator
  def each_with_info(); end

  def initialize(collection, paths); end
end

class ActionView::CollectionRenderer::MixedCollectionIterator
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
  def initialize(collection, path, variables, relation); end
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
end

class ActionView::CollectionRenderer::SameCollectionIterator
  def each_with_info(); end

  def from_collection(collection); end

  def initialize(collection, path, variables); end
end

class ActionView::CollectionRenderer::SameCollectionIterator
end

class ActionView::CollectionRenderer
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker::RipperTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::RipperTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  extend ::ActiveSupport::Autoload
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path); end

  def path(); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelInstanceTag
  def content_tag(type, options, *arg); end

  def error_message(); end

  def error_wrapping(html_tag); end

  def object(); end

  def tag(type, options, *arg); end
end

module ActionView::Helpers::ActiveModelInstanceTag
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def apply_stylesheet_media_default(); end

  def apply_stylesheet_media_default=(val); end

  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_decoding(); end

  def image_decoding=(val); end

  def image_loading(); end

  def image_loading=(val); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def preload_links_header(); end

  def preload_links_header=(val); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
  MAX_HEADER_SIZE = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetTagHelper
  def self.apply_stylesheet_media_default(); end

  def self.apply_stylesheet_media_default=(val); end

  def self.image_decoding(); end

  def self.image_decoding=(val); end

  def self.image_loading(); end

  def self.image_loading=(val); end

  def self.preload_links_header(); end

  def self.preload_links_header=(val); end
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), digest_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def caching?(); end

  def digest_path_from_template(template); end

  def uncacheable!(); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args, &block); end

  def capture_with_haml(*args, &block); end

  def capture_without_haml(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(*args, &block); end

  def with_output_buffer_with_haml_xss(*args, &block); end

  def with_output_buffer_without_haml_xss(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::ControllerHelper
  def action_name(*arg, **arg1, &arg2); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*arg, **arg1, &arg2); end

  def controller_path(*arg, **arg1, &arg2); end

  def cookies(*arg, **arg1, &arg2); end

  def flash(*arg, **arg1, &arg2); end

  def headers(*arg, **arg1, &arg2); end

  def logger(); end

  def params(*arg, **arg1, &arg2); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*arg, **arg1, &arg2); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*arg, **arg1, &arg2); end

  def session(*arg, **arg1, &arg2); end
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(**options); end
end

module ActionView::Helpers::CspHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

class ActionView::Helpers::FormBuilder
  include ::ActionView::ModelNaming
  include ::SimpleForm::ActionViewExtensions::Builder
  def button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box(method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def collection_check_boxes(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def color_field(method, options=T.unsafe(nil)); end

  def date_field(method, options=T.unsafe(nil)); end

  def date_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_field(method, options=T.unsafe(nil)); end

  def datetime_local_field(method, options=T.unsafe(nil)); end

  def datetime_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def email_field(method, options=T.unsafe(nil)); end

  def emitted_hidden_id?(); end

  def field_helpers(); end

  def field_helpers=(field_helpers); end

  def field_helpers?(); end

  def field_id(method, *suffixes, namespace: T.unsafe(nil), index: T.unsafe(nil)); end

  def field_name(method, *methods, multiple: T.unsafe(nil), index: T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), fields_options=T.unsafe(nil), &block); end

  def file_field(method, options=T.unsafe(nil)); end

  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def hidden_field(method, options=T.unsafe(nil)); end

  def id(); end

  def index(); end

  def initialize(object_name, object, template, options); end

  def label(method, text=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(method, options=T.unsafe(nil)); end

  def multipart(); end

  def multipart=(multipart); end

  def multipart?(); end

  def number_field(method, options=T.unsafe(nil)); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def password_field(method, options=T.unsafe(nil)); end

  def phone_field(method, options=T.unsafe(nil)); end

  def radio_button(method, tag_value, options=T.unsafe(nil)); end

  def range_field(method, options=T.unsafe(nil)); end

  def rich_text_area(method, options=T.unsafe(nil)); end

  def search_field(method, options=T.unsafe(nil)); end

  def select(method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def submit(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field(method, options=T.unsafe(nil)); end

  def text_area(method, options=T.unsafe(nil)); end

  def text_field(method, options=T.unsafe(nil)); end

  def time_field(method, options=T.unsafe(nil)); end

  def time_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_zone_select(method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def to_model(); end

  def to_partial_path(); end

  def url_field(method, options=T.unsafe(nil)); end

  def week_field(method, options=T.unsafe(nil)); end

  def weekday_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

class ActionView::Helpers::FormBuilder
  def self._to_partial_path(); end

  def self.field_helpers(); end

  def self.field_helpers=(value); end

  def self.field_helpers?(); end
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def _object_for_form_builder(object); end

  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(*args, &block); end

  def form_for_with_haml_xss(*args, &block); end

  def form_for_without_haml_xss(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(val); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(val); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def multiple_file_field_include_hidden(); end

  def multiple_file_field_include_hidden=(val); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def rich_text_area(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(val); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(val); end

  def self.multiple_file_field_include_hidden(); end

  def self.multiple_file_field_include_hidden=(val); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def weekday_options_for_select(selected=T.unsafe(nil), index_as_value: T.unsafe(nil), day_format: T.unsafe(nil), beginning_of_week: T.unsafe(nil)); end

  def weekday_select(object, method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def default_enforce_utf8(); end

  def default_enforce_utf8=(val); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(val); end

  def field_id(object_name, method_name, *suffixes, index: T.unsafe(nil), namespace: T.unsafe(nil)); end

  def field_name(object_name, method_name, *method_names, multiple: T.unsafe(nil), index: T.unsafe(nil)); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(*args, &block); end

  def form_tag_with_haml(url_for_options=T.unsafe(nil), options=T.unsafe(nil), *parameters_for_url, &proc); end

  def form_tag_with_haml_xss(*args, &block); end

  def form_tag_without_haml(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def form_tag_without_haml_xss(url_for_options=T.unsafe(nil), options=T.unsafe(nil), *parameters_for_url, &proc); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.default_enforce_utf8(); end

  def self.default_enforce_utf8=(val); end

  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(val); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def class_names(*args); end

  def content_tag(name, *args, &block); end

  def content_tag_with_haml(name, *args, &block); end

  def content_tag_without_haml(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end

  def token_list(*args); end
  ARIA_PREFIXES = ::T.let(nil, ::T.untyped)
  DATA_PREFIXES = ::T.let(nil, ::T.untyped)
  DEFAULT_PRESERVE_OPTIONS = ::T.let(nil, ::T.untyped)
  TAG_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  def self.build_tag_values(*args); end
end

class ActionView::Helpers::Tags::Base
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::ActiveModelInstanceTag
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def initialize(object_name, method_name, template_object, options=T.unsafe(nil)); end

  def render(); end
end

class ActionView::Helpers::Tags::Base
end

class ActionView::Helpers::Tags::CollectionCheckBoxes
  include ::ActionView::Helpers::Tags::CollectionHelpers
  def render(&block); end
end

class ActionView::Helpers::Tags::CollectionCheckBoxes
end

module ActionView::Helpers::Tags::CollectionHelpers
  def initialize(object_name, method_name, template_object, collection, value_method, text_method, options, html_options); end
end

module ActionView::Helpers::Tags::CollectionHelpers
end

class ActionView::Helpers::Tags::CollectionRadioButtons
  include ::ActionView::Helpers::Tags::CollectionHelpers
  def render(&block); end
end

class ActionView::Helpers::Tags::CollectionRadioButtons
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def concat_with_haml_xss(string); end

  def concat_without_haml_xss(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil), &block); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def safe_concat_with_haml_xss(string); end

  def safe_concat_without_haml_xss(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def l(object, **options); end

  def localize(object, **options); end

  def t(key, **options); end

  def translate(key, **options); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(raise_on_missing_translations); end
end

module ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def button_to_generates_button_tag(); end

  def button_to_generates_button_tag=(val); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def phone_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def sms_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
end

module ActionView::Helpers::UrlHelper
  def self.button_to_generates_button_tag(); end

  def self.button_to_generates_button_tag=(val); end
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*arg, **arg1, &arg2); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*arg); end
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
end

class ActionView::LogSubscriber
  include ::Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_collection(event); end

  def render_layout(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def rendered_format(); end

  def rendered_format=(rendered_format); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(registered_details); end
end

class ActionView::MissingTemplate
  include ::DidYouMean::Correctable
  def initialize(paths, path, prefixes, partial, details, *arg); end

  def partial(); end

  def paths(); end

  def prefixes(); end
end

class ActionView::MissingTemplate::Results
  def add(path, score); end

  def initialize(size); end

  def should_record?(score); end

  def to_a(); end
end

class ActionView::MissingTemplate::Results::Result
  def path(); end

  def path=(_); end

  def score(); end

  def score=(_); end
end

class ActionView::MissingTemplate::Results::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionView::MissingTemplate::Results
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

class ActionView::ObjectRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_object_derive_partial(object, context, block); end

  def render_object_with_partial(object, partial, context, block); end
end

class ActionView::ObjectRenderer
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*arg); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialIteration
  def first?(); end

  def index(); end

  def initialize(size); end

  def iterate!(); end

  def last?(); end

  def size(); end
end

class ActionView::PartialIteration
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  def collection_cache(); end

  def collection_cache=(val); end

  def initialize(lookup_context, options); end

  def render(partial, context, block); end
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(val); end
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*arg, **arg1, &arg2); end

  def concat(*args); end

  def each(*arg, **arg1, &arg2); end

  def exists?(path, prefixes, partial, details, details_key, locals); end

  def find(path, prefixes, partial, details, details_key, locals); end

  def find_all(path, prefixes, partial, details, details_key, locals); end

  def include?(*arg, **arg1, &arg2); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*arg, **arg1, &arg2); end

  def push(*args); end

  def size(*arg, **arg1, &arg2); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActionView::RenderParser
  def initialize(name, code); end

  def render_calls(); end
  ALL_KNOWN_KEYS = ::T.let(nil, ::T.untyped)
  RENDER_TYPE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionView::RenderParser::RipperASTParser
  def parse_render_nodes(code); end
end

class ActionView::RenderParser::RipperASTParser::Node
  def argument_nodes(); end

  def call?(); end

  def call_method_name(); end

  def children(); end

  def fcall?(); end

  def fcall_named?(name); end

  def hash?(); end

  def hash_from_body(body); end

  def initialize(type, arr, opts=T.unsafe(nil)); end

  def string?(); end

  def symbol?(); end

  def to_hash(); end

  def to_string(); end

  def to_symbol(); end

  def type(); end

  def variable_name(); end

  def variable_reference?(); end

  def vcall?(); end
end

class ActionView::RenderParser::RipperASTParser::Node
end

class ActionView::RenderParser::RipperASTParser::NodeParser
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(list, item); end

  def on_args_add_block(list, item); end

  def on_args_add_star(list, item); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_dedent(*args); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(list, item); end

  def on_method_add_block(list, item); end

  def on_mlhs_add(list, item); end

  def on_mlhs_add_post(list, item); end

  def on_mlhs_add_star(list, item); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(list, item); end

  def on_mrhs_add_star(list, item); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(list, item); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(list, item); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(list, item); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(list, item); end

  def on_stmts_new(*args); end

  def on_string_add(list, item); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(list, item); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(list, item); end

  def on_word_new(*args); end

  def on_words_add(list, item); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(list, item); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class ActionView::RenderParser::RipperASTParser::NodeParser
end

class ActionView::RenderParser::RipperASTParser::RenderCallExtractor
  def initialize(*args); end

  def render_calls(); end
  METHODS_TO_PARSE = ::T.let(nil, ::T.untyped)
end

class ActionView::RenderParser::RipperASTParser::RenderCallExtractor
end

module ActionView::RenderParser::RipperASTParser
  extend ::ActionView::RenderParser::RipperASTParser
end

class ActionView::RenderParser
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*arg); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def all_template_paths(); end

  def caching(); end

  def caching=(val); end

  def caching?(*arg, **arg1, &arg2); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end
end

ActionView::Resolver::Path = ActionView::TemplatePath

class ActionView::Resolver::PathParser
  def build_path_regex(); end

  def parse(path); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def details(); end

  def details=(_); end

  def path(); end

  def path=(_); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionView::Resolver::PathParser
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(val); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(val); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(val); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, locals:, format: T.unsafe(nil), variant: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def locals(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def render(view, locals, buffer=T.unsafe(nil), add_to_stack: T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def variable(); end

  def variant(); end

  def virtual_path(); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def identifier(); end

  def initialize(string, type); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(default_format); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(value); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(erb_implementation); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(erb_trim_mode); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(escape_ignore_list); end

  def escape_ignore_list?(); end

  def handles_encoding?(); end

  def strip_trailing_newlines(); end

  def strip_trailing_newlines=(strip_trailing_newlines); end

  def strip_trailing_newlines?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(value); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(value); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(value); end

  def self.escape_ignore_list?(); end

  def self.strip_trailing_newlines(); end

  def self.strip_trailing_newlines=(value); end

  def self.strip_trailing_newlines?(); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::RawFile
end

class ActionView::Template::Renderable
  def format(); end

  def identifier(); end

  def initialize(renderable); end

  def render(context, *args); end
end

class ActionView::Template::Renderable
end

module ActionView::Template::Sources
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

module ActionView::Template::Sources
  extend ::ActiveSupport::Autoload
end

class ActionView::Template::Text
  def format(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

module ActionView::Template::Types
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

module ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(type_klass); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
  def self.frozen_string_literal(); end

  def self.frozen_string_literal=(frozen_string_literal); end
end

class ActionView::TemplateDetails
  def format(); end

  def format_or_default(); end

  def handler(); end

  def handler_class(); end

  def initialize(locale, handler, format, variant); end

  def locale(); end

  def matches?(requested); end

  def sort_key_for(requested); end

  def variant(); end
end

class ActionView::TemplateDetails::Requested
  def formats(); end

  def formats_idx(); end

  def handlers(); end

  def handlers_idx(); end

  def initialize(locale:, handlers:, formats:, variants:); end

  def locale(); end

  def locale_idx(); end

  def variants(); end

  def variants_idx(); end
  ANY_HASH = ::T.let(nil, ::T.untyped)
end

class ActionView::TemplateDetails::Requested
end

class ActionView::TemplateDetails
end

class ActionView::TemplatePath
  def ==(other); end

  def eql?(other); end

  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end

  def virtual_path(); end
end

class ActionView::TemplatePath
  def self.build(name, prefix, partial); end

  def self.parse(virtual); end

  def self.virtual(name, prefix, partial); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*arg, **arg1, &arg2); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*arg); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionView::TestCase::HelperMethods
  def _test_case(); end

  def protect_against_forgery?(); end
end

module ActionView::TestCase::HelperMethods
end

class ActionView::TestCase::TestController
  include ::GeneratedUrlHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

module ActionView::TestCase::TestController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::ApplicationHelper
  include ::Pagy::Frontend
  include ::Pagy::UrlHelpers
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
  include ::PreviewHelper
  include ::DeviseHelper
end

module ActionView::TestCase::TestController::HelperMethods
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def details(); end

  def format(*arg, **arg1, &arg2); end

  def handler(*arg, **arg1, &arg2); end

  def initialize(source, identifier, details:, virtual_path:); end

  def locale(*arg, **arg1, &arg2); end

  def variant(*arg, **arg1, &arg2); end

  def virtual_path(); end
end

class ActionView::UnboundTemplate
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*arg, **arg1, &arg2); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*arg, **arg1, &arg2); end

  def view_paths(*arg, **arg1, &arg2); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Base
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(val); end

  def queue_adapter(*arg, **arg1, &arg2); end

  def queue_name_prefix(); end

  def queue_name_prefix=(queue_name_prefix); end

  def queue_name_prefix?(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end
end

class ActiveJob::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(value); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(value); end

  def self._test_adapter(); end

  def self._test_adapter=(value); end

  def self.log_arguments(); end

  def self.log_arguments=(value); end

  def self.log_arguments?(); end

  def self.logger(); end

  def self.logger=(val); end

  def self.priority(); end

  def self.priority=(value); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(value); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(value); end

  def self.queue_name_delimiter?(); end

  def self.queue_name_prefix(); end

  def self.queue_name_prefix=(value); end

  def self.queue_name_prefix?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.retry_jitter(); end

  def self.retry_jitter=(value); end

  def self.return_false_on_aborted_enqueue(); end

  def self.return_false_on_aborted_enqueue=(value); end

  def self.skip_after_callbacks_if_terminated(*args, **arg, &block); end

  def self.skip_after_callbacks_if_terminated=(*args, **arg, &block); end
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*arg, **arg1, &arg2); end

  def perform_now(*arg, **arg1, &arg2); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueue_error(); end

  def enqueue_error=(enqueue_error); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments, **arg); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def set(options=T.unsafe(nil)); end

  def successfully_enqueued=(successfully_enqueued); end

  def successfully_enqueued?(); end

  def timezone(); end

  def timezone=(timezone); end
end

class ActiveJob::DeserializationError
  def initialize(); end
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Execution
  def perform(*arg); end

  def perform_now(); end
end

module ActiveJob::Instrumentation
  def perform_now(); end
end

class ActiveJob::LogSubscriber
  def discard(event); end

  def enqueue(event); end

  def enqueue_at(event); end

  def enqueue_retry(event); end

  def perform(event); end

  def perform_start(event); end

  def retry_stopped(event); end
end

module ActiveJob::Logging
  def perform_now(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*arg); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def at(); end

  def at=(at); end

  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(val); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::ModuleSerializer
  def deserialize(hash); end

  def serialize(constant); end
end

class ActiveJob::Serializers::ObjectSerializer
  def deserialize(json); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  def self.deserialize(*arg, **arg1, &arg2); end

  def self.serialize(*arg, **arg1, &arg2); end

  def self.serialize?(*arg, **arg1, &arg2); end
end

class ActiveJob::Serializers::RangeSerializer
  def deserialize(hash); end

  def serialize(range); end
  KEYS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::TimeObjectSerializer
  def serialize(time); end
  NANO_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end
end

module ActiveJob::Serializers
  def self._additional_serializers(); end

  def self._additional_serializers=(val); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*arg, **arg1, &arg2); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), at: T.unsafe(nil), &block); end

  def performed_jobs(*arg, **arg1, &arg2); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::TestHelper
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::API
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end
end

module ActiveModel::AttributeAssignment
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeMethods
  FORWARD_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forget_change(attr_name); end

  def initialize(attributes); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def freeze(); end

  def initialize(*arg); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, cast_type=T.unsafe(nil), default: T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Dirty
  def as_json(options=T.unsafe(nil)); end

  def attribute_previously_was(attr_name); end

  def attribute_was(attr_name); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def restore_attributes(attr_names=T.unsafe(nil)); end
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::Error
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

class ActiveModel::ForcedMutationTracker
  def finalize_changes(); end
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::Name
  def !~(*arg, **arg1, &arg2); end

  def ==(arg); end

  def ===(arg); end

  def =~(*arg, **arg1, &arg2); end

  def as_json(*arg, **arg1, &arg2); end

  def cache_key(); end

  def collection(); end

  def collection=(collection); end

  def element(); end

  def element=(element); end

  def eql?(*arg, **arg1, &arg2); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def i18n_key=(i18n_key); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil), locale=T.unsafe(nil)); end

  def match?(*arg, **arg1, &arg2); end

  def name(); end

  def name=(name); end

  def param_key(); end

  def param_key=(param_key); end

  def plural(); end

  def plural=(plural); end

  def route_key(); end

  def route_key=(route_key); end

  def singular(); end

  def singular=(singular); end

  def singular_route_key(); end

  def singular_route_key=(singular_route_key); end

  def to_s(*arg, **arg1, &arg2); end

  def to_str(*arg, **arg1, &arg2); end

  def uncountable?(); end
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, **arg); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def original_value(attr_name); end
end

module ActiveModel::SecurePassword
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def attribute_names(); end

  def read_attribute_for_serialization(*arg); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serializers
  VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Serializers::JSON
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::Xml
  def from_xml(xml); end

  def to_xml(options=T.unsafe(nil), &block); end
end

class ActiveModel::Serializers::Xml::Serializer
  def initialize(serializable, options=T.unsafe(nil)); end

  def options(); end

  def serializable_collection(); end

  def serializable_hash(); end

  def serialize(); end
end

class ActiveModel::Serializers::Xml::Serializer::Attribute
  def compute_type(); end

  def decorations(); end

  def initialize(name, serializable, value); end

  def name(); end

  def type(); end

  def value(); end
end

module ActiveModel::Translation
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

module ActiveModel::Type::Helpers::AcceptsMultiparameterTime::InstanceMethods
  def assert_valid_value(value); end

  def cast(value); end

  def serialize(value); end

  def value_constructed_by_mass_assignment?(value); end
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def serialize(value); end
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

class ActiveModel::Type::ImmutableString
  def initialize(**args); end
end

class ActiveModel::Type::Integer
  def initialize(**arg); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args, **arg); end

  def register(type_name, klass=T.unsafe(nil), &block); end
end

class ActiveModel::Type::String
  def to_immutable_string(); end
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(_); end

  def binary?(); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def limit(); end

  def map(value); end

  def precision(); end

  def scale(); end

  def serializable?(value); end

  def serialize(value); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*arg, **arg1, &arg2); end

  def self.register(type_name, klass=T.unsafe(nil), &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

module ActiveModel::Validations
  def read_attribute_for_validation(*arg); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_comparison_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

class ActiveRecord::ActiveJobRequiredError
end

class ActiveRecord::ActiveJobRequiredError
end

class ActiveRecord::AdapterTimeout
end

class ActiveRecord::AdapterTimeout
end

module ActiveRecord::Aggregations
  def reload(*arg); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations::ClassMethods
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError
  include ::DidYouMean::Correctable
  def association_name(); end

  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association, **arg); end

  def insert(attributes, **kwargs); end

  def insert!(attributes, **kwargs); end

  def insert_all(attributes, **kwargs); end

  def insert_all!(attributes, **kwargs); end

  def proxy_association(); end

  def upsert(attributes, **kwargs); end

  def upsert_all(attributes, **kwargs); end
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end
end

class ActiveRecord::Associations::CollectionProxy
  def <<(*records); end

  def _select!(*arg, **arg1, &arg2); end

  def and(*arg, **arg1, &arg2); end

  def and!(*arg, **arg1, &arg2); end

  def annotate(*arg, **arg1, &arg2); end

  def annotate!(*arg, **arg1, &arg2); end

  def annotate_values(*arg, **arg1, &arg2); end

  def annotate_values=(arg); end

  def append(*records); end

  def arel(*arg, **arg1, &arg2); end

  def clear(); end

  def concat(*records); end

  def construct_join_dependency(*arg, **arg1, &arg2); end

  def create_with(*arg, **arg1, &arg2); end

  def create_with!(*arg, **arg1, &arg2); end

  def create_with_value(*arg, **arg1, &arg2); end

  def create_with_value=(arg); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def distinct(*arg, **arg1, &arg2); end

  def distinct!(*arg, **arg1, &arg2); end

  def distinct_value(*arg, **arg1, &arg2); end

  def distinct_value=(arg); end

  def eager_load(*arg, **arg1, &arg2); end

  def eager_load!(*arg, **arg1, &arg2); end

  def eager_load_values(*arg, **arg1, &arg2); end

  def eager_load_values=(arg); end

  def except(*arg, **arg1, &arg2); end

  def excluding(*arg, **arg1, &arg2); end

  def excluding!(*arg, **arg1, &arg2); end

  def extending(*arg, **arg1, &arg2); end

  def extending!(*arg, **arg1, &arg2); end

  def extending_values(*arg, **arg1, &arg2); end

  def extending_values=(arg); end

  def extensions(*arg, **arg1, &arg2); end

  def extract_associated(*arg, **arg1, &arg2); end

  def from(*arg, **arg1, &arg2); end

  def from!(*arg, **arg1, &arg2); end

  def from_clause(*arg, **arg1, &arg2); end

  def from_clause=(arg); end

  def group(*arg, **arg1, &arg2); end

  def group!(*arg, **arg1, &arg2); end

  def group_values(*arg, **arg1, &arg2); end

  def group_values=(arg); end

  def having(*arg, **arg1, &arg2); end

  def having!(*arg, **arg1, &arg2); end

  def having_clause(*arg, **arg1, &arg2); end

  def having_clause=(arg); end

  def in_order_of(*arg, **arg1, &arg2); end

  def includes(*arg, **arg1, &arg2); end

  def includes!(*arg, **arg1, &arg2); end

  def includes_values(*arg, **arg1, &arg2); end

  def includes_values=(arg); end

  def initialize(klass, association, **arg); end

  def insert(*arg, **arg1, &arg2); end

  def insert!(*arg, **arg1, &arg2); end

  def insert_all(*arg, **arg1, &arg2); end

  def insert_all!(*arg, **arg1, &arg2); end

  def invert_where(*arg, **arg1, &arg2); end

  def invert_where!(*arg, **arg1, &arg2); end

  def joins(*arg, **arg1, &arg2); end

  def joins!(*arg, **arg1, &arg2); end

  def joins_values(*arg, **arg1, &arg2); end

  def joins_values=(arg); end

  def left_joins(*arg, **arg1, &arg2); end

  def left_outer_joins(*arg, **arg1, &arg2); end

  def left_outer_joins!(*arg, **arg1, &arg2); end

  def left_outer_joins_values(*arg, **arg1, &arg2); end

  def left_outer_joins_values=(arg); end

  def limit(*arg, **arg1, &arg2); end

  def limit!(*arg, **arg1, &arg2); end

  def limit_value(*arg, **arg1, &arg2); end

  def limit_value=(arg); end

  def load_target(); end

  def lock(*arg, **arg1, &arg2); end

  def lock!(*arg, **arg1, &arg2); end

  def lock_value(*arg, **arg1, &arg2); end

  def lock_value=(arg); end

  def merge(*arg, **arg1, &arg2); end

  def merge!(*arg, **arg1, &arg2); end

  def none(*arg, **arg1, &arg2); end

  def none!(*arg, **arg1, &arg2); end

  def offset(*arg, **arg1, &arg2); end

  def offset!(*arg, **arg1, &arg2); end

  def offset_value(*arg, **arg1, &arg2); end

  def offset_value=(arg); end

  def only(*arg, **arg1, &arg2); end

  def optimizer_hints(*arg, **arg1, &arg2); end

  def optimizer_hints!(*arg, **arg1, &arg2); end

  def optimizer_hints_values(*arg, **arg1, &arg2); end

  def optimizer_hints_values=(arg); end

  def or(*arg, **arg1, &arg2); end

  def or!(*arg, **arg1, &arg2); end

  def order(*arg, **arg1, &arg2); end

  def order!(*arg, **arg1, &arg2); end

  def order_values(*arg, **arg1, &arg2); end

  def order_values=(arg); end

  def preload(*arg, **arg1, &arg2); end

  def preload!(*arg, **arg1, &arg2); end

  def preload_values(*arg, **arg1, &arg2); end

  def preload_values=(arg); end

  def prepend(*args); end

  def proxy_association(); end

  def push(*records); end

  def readonly(*arg, **arg1, &arg2); end

  def readonly!(*arg, **arg1, &arg2); end

  def readonly_value(*arg, **arg1, &arg2); end

  def readonly_value=(arg); end

  def references(*arg, **arg1, &arg2); end

  def references!(*arg, **arg1, &arg2); end

  def references_values(*arg, **arg1, &arg2); end

  def references_values=(arg); end

  def reorder(*arg, **arg1, &arg2); end

  def reorder!(*arg, **arg1, &arg2); end

  def reordering_value(*arg, **arg1, &arg2); end

  def reordering_value=(arg); end

  def replace(other_array); end

  def reselect(*arg, **arg1, &arg2); end

  def reselect!(*arg, **arg1, &arg2); end

  def reset_scope(); end

  def reverse_order(*arg, **arg1, &arg2); end

  def reverse_order!(*arg, **arg1, &arg2); end

  def reverse_order_value(*arg, **arg1, &arg2); end

  def reverse_order_value=(arg); end

  def rewhere(*arg, **arg1, &arg2); end

  def scope(); end

  def scoping(*arg, **arg1, &arg2); end

  def select_values(*arg, **arg1, &arg2); end

  def select_values=(arg); end

  def skip_preloading!(*arg, **arg1, &arg2); end

  def skip_query_cache!(*arg, **arg1, &arg2); end

  def skip_query_cache_value(*arg, **arg1, &arg2); end

  def skip_query_cache_value=(arg); end

  def spawn(*arg, **arg1, &arg2); end

  def strict_loading(*arg, **arg1, &arg2); end

  def strict_loading!(*arg, **arg1, &arg2); end

  def strict_loading_value(*arg, **arg1, &arg2); end

  def strict_loading_value=(arg); end

  def structurally_compatible?(*arg, **arg1, &arg2); end

  def target(); end

  def uniq!(*arg, **arg1, &arg2); end

  def unscope(*arg, **arg1, &arg2); end

  def unscope!(*arg, **arg1, &arg2); end

  def unscope_values(*arg, **arg1, &arg2); end

  def unscope_values=(arg); end

  def upsert(*arg, **arg1, &arg2); end

  def upsert_all(*arg, **arg1, &arg2); end

  def values(*arg, **arg1, &arg2); end

  def where(*arg, **arg1, &arg2); end

  def where!(*arg, **arg1, &arg2); end

  def where_clause(*arg, **arg1, &arg2); end

  def where_clause=(arg); end

  def without(*arg, **arg1, &arg2); end
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActiveRecord::AsynchronousQueriesTracker
  def current_session(); end

  def finalize_session(); end

  def start_session(); end
end

module ActiveRecord::AsynchronousQueriesTracker::NullSession
end

module ActiveRecord::AsynchronousQueriesTracker::NullSession
  def self.active?(); end

  def self.finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker::Session
  def active?(); end

  def finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker::Session
end

class ActiveRecord::AsynchronousQueriesTracker
  def self.complete(asynchronous_queries_tracker); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

class ActiveRecord::AsynchronousQueryInsideTransactionError
end

class ActiveRecord::AsynchronousQueryInsideTransactionError
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def _has_attribute?(attr_name); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_names(); end

  def attribute_present?(attr_name); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def attributes_for_database(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*arg); end

  def saved_change_to_attribute(attr_name); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_for_database(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name, &block); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  def self.dangerous_attribute_methods(); end
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::Validations
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveModel::Dirty
  include ::ActiveModel::Serializers::JSON
  include ::ActiveRecord::SignedId
  include ::ActiveRecord::Encryption::EncryptableRecord
  include ::FriendlyId::UnfriendlyUtils
  include ::Kaminari::ActiveRecordExtension
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  include ::Turbo::Broadcastable
  include ::ActionText::Encryption
  include ::Bullet::SaveWithBulletSupport
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _commit_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def automatic_scope_inversing(); end

  def automatic_scope_inversing?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*arg, **arg1, &arg2); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_role(); end

  def default_role?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_shard(); end

  def default_shard?(); end

  def defined_enums(); end

  def defined_enums?(); end

  def destroy_association_async_job(); end

  def encrypted_attributes(); end

  def encrypted_attributes=(encrypted_attributes); end

  def encrypted_attributes?(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def logger?(); end

  def model_name(*arg, **arg1, &arg2); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_inserts(); end

  def partial_inserts?(); end

  def partial_updates(); end

  def partial_updates?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def primary_key_prefix_type?(); end

  def rails_admin_default_object_label_method(); end

  def record_timestamps(); end

  def record_timestamps=(record_timestamps); end

  def record_timestamps?(); end

  def safe_send(value); end

  def signed_id_verifier_secret(); end

  def signed_id_verifier_secret?(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_class_name(); end

  def store_full_class_name?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_attributes?(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def type_for_attribute(*arg, **arg1, &arg2); end

  def validation_context(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::DelegatedType
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::OrmAdapter::ToAdapter
  extend ::SorbetRails::CustomFinderMethods
  extend ::Devise::Models
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(value); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(value); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(value); end

  def self.aggregate_reflections?(); end

  def self.application_record_class?(); end

  def self.asynchronous_queries_session(); end

  def self.asynchronous_queries_tracker(); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(value); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(value); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(value); end

  def self.attribute_method_matchers?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(value); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.automatic_scope_inversing(); end

  def self.automatic_scope_inversing=(value); end

  def self.automatic_scope_inversing?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(value); end

  def self.belongs_to_required_by_default?(); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(value); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(value); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(value); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connected_to_stack(); end

  def self.connection_class(); end

  def self.connection_class=(b); end

  def self.connection_class?(); end

  def self.connection_class_for_self(); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(handlers); end

  def self.current_preventing_writes(); end

  def self.current_role(); end

  def self.current_shard(); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(value); end

  def self.default_connection_handler?(); end

  def self.default_role(); end

  def self.default_role=(value); end

  def self.default_role?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(value); end

  def self.default_scopes(); end

  def self.default_scopes=(value); end

  def self.default_shard(); end

  def self.default_shard=(value); end

  def self.default_shard?(); end

  def self.defined_enums(); end

  def self.defined_enums=(value); end

  def self.defined_enums?(); end

  def self.destroy_association_async_job(); end

  def self.destroy_association_async_job=(value); end

  def self.encrypted_attributes(); end

  def self.encrypted_attributes=(value); end

  def self.encrypted_attributes?(); end

  def self.enumerate_columns_in_select_statements(); end

  def self.enumerate_columns_in_select_statements=(value); end

  def self.enumerate_columns_in_select_statements?(); end

  def self.has_many_inversing(); end

  def self.has_many_inversing=(value); end

  def self.has_many_inversing?(); end

  def self.immutable_strings_by_default(); end

  def self.immutable_strings_by_default=(value); end

  def self.immutable_strings_by_default?(); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(value); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(value); end

  def self.include_root_in_json?(); end

  def self.inheritance_column(); end

  def self.inheritance_column=(value); end

  def self.inheritance_column?(); end

  def self.inherited(child); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(value); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(value); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.logger?(); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(value); end

  def self.nested_attributes_options?(); end

  def self.partial_inserts(); end

  def self.partial_inserts=(value); end

  def self.partial_inserts?(); end

  def self.partial_updates(); end

  def self.partial_updates=(value); end

  def self.partial_updates?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(value); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(value); end

  def self.primary_key_prefix_type?(); end

  def self.rails_admin(&block); end

  def self.record_timestamps(); end

  def self.record_timestamps=(value); end

  def self.record_timestamps?(); end

  def self.sbr_old_inherited(kls); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(value); end

  def self.schema_migrations_table_name?(); end

  def self.shard_selector(); end

  def self.shard_selector=(value); end

  def self.shard_selector?(); end

  def self.signed_id_verifier_secret(); end

  def self.signed_id_verifier_secret=(value); end

  def self.signed_id_verifier_secret?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(value); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_class_name(); end

  def self.store_full_class_name=(value); end

  def self.store_full_class_name?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(value); end

  def self.store_full_sti_class?(); end

  def self.strict_loading_by_default(); end

  def self.strict_loading_by_default=(value); end

  def self.strict_loading_by_default?(); end

  def self.strict_loading_violation!(owner:, reflection:); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(value); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(value); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(value); end

  def self.time_zone_aware_attributes?(); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(value); end

  def self.time_zone_aware_types?(); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil), &block); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Batches
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(identity_or_column=T.unsafe(nil), &block); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*arg, **arg1); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def all_foreign_keys_valid?(); end

  def async_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_if_write_query(sql); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def connection_class(); end

  def create(*arg); end

  def create_enum(*arg); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value); end

  def delete(*arg); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*arg); end

  def expire(); end

  def extensions(); end

  def field_ordered_value(column, values); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*arg); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements?(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def role(); end

  def rollback_db_transaction(*arg); end

  def rollback_to_savepoint(*arg); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def schema_version(); end

  def seconds_idle(); end

  def shard(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_check_constraints?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_concurrent_connections?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_deferrable_constraints?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_partitioned_indexes?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def throw_away!(); end

  def truncate(*arg); end

  def truncate_tables(*arg); end

  def unprepared_statement(); end

  def update(*arg); end

  def use_metadata_table?(); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end

  def with_instrumenter(instrumenter, &block); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
  TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def lazily_set_schema_cache(); end

  def set_schema_cache(cache); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_check_constraint(expression, options); end

  def add_column(name, type, **options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def check_constraint_adds(); end

  def check_constraint_drops(); end

  def drop_check_constraint(constraint_name); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def export_name_on_schema_dump?(); end

  def expression(); end

  def expression=(_); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  def ==(other); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def limit(*arg, **arg1, &arg2); end

  def name(); end

  def null(); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def sql_type(*arg, **arg1, &arg2); end

  def sql_type_metadata(); end

  def type(*arg, **arg1, &arg2); end

  def virtual?(); end
end

class ActiveRecord::ConnectionAdapters::Column
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def aliased_types(name, fallback); end

  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(role=T.unsafe(nil)); end

  def all_connection_pools(); end

  def clear_active_connections!(role=T.unsafe(nil)); end

  def clear_all_connections!(role=T.unsafe(nil)); end

  def clear_reloadable_connections!(role=T.unsafe(nil)); end

  def connected?(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def connection_pool_list(role=T.unsafe(nil)); end

  def connection_pool_names(); end

  def connection_pools(role=T.unsafe(nil)); end

  def establish_connection(config, owner_name: T.unsafe(nil), role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def flush_idle_connections!(role=T.unsafe(nil)); end

  def prevent_writes(); end

  def prevent_writes=(prevent_writes); end

  def remove_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def retrieve_connection(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def retrieve_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def while_preventing_writes(enabled=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler::StringConnectionOwner
  def current_preventing_writes(); end

  def initialize(name); end

  def name(); end

  def primary_class?(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler::StringConnectionOwner
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def active_connection?(); end

  def async_executor(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connection_class(); end

  def connection_klass(*args, **arg, &block); end

  def connections(); end

  def db_config(); end

  def discard!(); end

  def discarded?(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(pool_config); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def pool_config(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def role(); end

  def schedule_query(future_result); end

  def schema_cache(*arg, **arg1, &arg2); end

  def schema_cache=(arg); end

  def shard(); end

  def size(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def algorithm(); end

  def algorithm=(_); end

  def if_not_exists(); end

  def if_not_exists=(_); end

  def index(); end

  def index=(_); end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def index_name_length(); end

  def max_identifier_length(); end

  def table_alias_length(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record, ensure_finalize=T.unsafe(nil)); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*arg, **arg1, &arg2); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*arg, **arg1, &arg2); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*arg, **arg1, &arg2); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*arg, **arg1, &arg2); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*arg, **arg1, &arg2); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def mark_transaction_written_if_write(sql); end

  def materialize_transactions(*arg, **arg1, &arg2); end

  def open_transactions(*arg, **arg1, &arg2); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*arg, **arg1, &arg2); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil), &block); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*arg, **arg1, &arg2); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

module ActiveRecord::ConnectionAdapters::Deduplicable
  def -@(); end

  def deduplicate(); end
end

module ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
  def new(*arg, **arg1); end

  def registry(); end
end

module ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
end

module ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def deferrable(); end

  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def column_options(); end

  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::LegacyPoolManager
  def get_pool_config(_, shard); end

  def pool_configs(_=T.unsafe(nil)); end

  def remove_pool_config(_, shard); end

  def set_pool_config(role, shard, pool_config); end

  def shard_names(); end
end

class ActiveRecord::ConnectionAdapters::LegacyPoolManager
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name, **arg); end
end

class ActiveRecord::ConnectionAdapters::NullColumn
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def async_executor(); end

  def checkin(_); end

  def connection_class(); end

  def remove(_); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end
end

class ActiveRecord::ConnectionAdapters::NullPool
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record, _=T.unsafe(nil)); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  include ::Mutex_m
  def connection_class(); end

  def connection_specification_name(); end

  def db_config(); end

  def discard_pool!(); end

  def disconnect!(); end

  def initialize(connection_class, db_config, role, shard); end

  def lock(); end

  def locked?(); end

  def pool(); end

  def role(); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def shard(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  def self.discard_pools!(); end
end

class ActiveRecord::ConnectionAdapters::PoolManager
  def get_pool_config(role, shard); end

  def pool_configs(role=T.unsafe(nil)); end

  def remove_pool_config(role, shard); end

  def remove_role(role); end

  def role_names(); end

  def set_pool_config(role, shard, pool_config); end

  def shard_names(); end
end

class ActiveRecord::ConnectionAdapters::PoolManager
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def constraint_validations(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  def array(); end

  def array?(); end

  def enum?(); end

  def fmod(*arg, **arg1, &arg2); end

  def initialize(*arg, serial: T.unsafe(nil), generated: T.unsafe(nil), **arg1); end

  def oid(*arg, **arg1, &arg2); end

  def serial?(); end

  def sql_type(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def primary_key(name, type=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def query(sql, name=T.unsafe(nil)); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  include ::ActiveModel::Type::Helpers::Mutable
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*arg, **arg1, &arg2); end

  def map(value, &block); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
  def real_type_unless_aliased(real_type); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
  ERROR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Interval
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Interval
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Macaddr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Macaddr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Timestamp
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Timestamp
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TimestampWithTimeZone
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TimestampWithTimeZone
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_array_types(); end

  def query_conditions_for_known_type_names(); end

  def query_conditions_for_known_type_types(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  def quote_schema_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def type_cast(value); end

  def unescape_bytea(value); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def all_foreign_keys_valid?(); end

  def disable_referential_integrity(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end

  def add_index(table_name, column_name, **options); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraints(table_name); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, **options); end

  def drop_table(table_name, **options); end

  def encoding(); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), enum_type: T.unsafe(nil), **arg); end

  def update_table_definition(table_name, base); end

  def validate_check_constraint(table_name, **options); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def initialize(*arg, **arg1); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unlogged(); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def create_enum(name, values); end

  def create_unlogged_tables(); end

  def create_unlogged_tables=(create_unlogged_tables); end

  def create_unlogged_tables?(); end

  def datetime_type(); end

  def datetime_type=(datetime_type); end

  def datetime_type?(); end

  def enum_types(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(connection, logger, connection_parameters, config); end

  def postgresql_version(); end

  def reload_type_map(); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  DUPLICATE_DATABASE = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
  def decode(value, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
  TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(value); end

  def self.create_unlogged_tables?(); end

  def self.datetime_type(); end

  def self.datetime_type=(value); end

  def self.datetime_type?(); end

  def self.native_database_types(); end

  def self.new_client(conn_params); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*arg); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*arg); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_bound_value(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, **options); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def dump_to(filename); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def self.load_from(filename); end
end

class ActiveRecord::ConnectionAdapters::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  DEFAULT_DATETIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_check_constraint(table_name, expression, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_columns(table_name, *column_names, type:, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, **options); end

  def add_index_options(table_name, column_name, name: T.unsafe(nil), if_not_exists: T.unsafe(nil), internal: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, **options); end

  def assume_migrated_upto_version(version); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, **options); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraint_options(table_name, expression, options); end

  def check_constraints(table_name); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, id: T.unsafe(nil), primary_key: T.unsafe(nil), force: T.unsafe(nil), **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def distinct_relation_for_primary_key(relation); end

  def drop_join_table(table_1, table_2, **options); end

  def drop_table(table_name, **options); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_algorithm(algorithm); end

  def index_exists?(table_name, column_name, **options); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def quoted_columns_for_index(column_names, options); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_check_constraint(table_name, expression=T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), **options); end

  def remove_columns(table_name, *column_names, type: T.unsafe(nil), **options); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **arg); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def change_null(column_name, null, default=T.unsafe(nil)); end

  def check_constraint(*args, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def remove_check_constraint(*args, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Table
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def check_constraint(expression, **options); end

  def check_constraints(); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(to_table, **options); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_check_constraint_definition(expression, options); end

  def new_column_definition(name, type, **options); end

  def new_foreign_key_definition(to_table, options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record, ensure_finalize=T.unsafe(nil)); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, isolation: T.unsafe(nil), joinable: T.unsafe(nil), run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end

  def written(); end

  def written=(written); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil), _lazy: T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def invalidate!(); end

  def invalidated?(); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*arg, **arg1, &arg2); end

  def clear_all_connections!(*arg, **arg1, &arg2); end

  def clear_cache!(); end

  def clear_query_caches_for_current_thread(); end

  def clear_reloadable_connections!(*arg, **arg1, &arg2); end

  def connected?(); end

  def connected_to_many(*classes, role:, shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  def connecting_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  def connection(); end

  def connection_db_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def establish_connection(config_or_env=T.unsafe(nil)); end

  def flush_idle_connections!(*arg, **arg1, &arg2); end

  def lookup_connection_handler(handler_key); end

  def postgresql_connection(config); end

  def primary_class?(); end

  def prohibit_shard_swapping(enabled=T.unsafe(nil)); end

  def remove_connection(name=T.unsafe(nil)); end

  def retrieve_connection(); end

  def shard_swapping_prohibited?(); end

  def while_preventing_writes(enabled=T.unsafe(nil), &block); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder, &block); end

  def init_with_attributes(attributes, new_record=T.unsafe(nil)); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end

  def strict_loading!(value=T.unsafe(nil), mode: T.unsafe(nil)); end

  def strict_loading?(); end

  def strict_loading_mode(); end

  def strict_loading_n_plus_one_only?(); end

  def values_at(*methods); end
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DatabaseAlreadyExists
end

class ActiveRecord::DatabaseAlreadyExists
end

class ActiveRecord::DatabaseConfigurations
  def any?(*arg, **arg1, &arg2); end

  def configs_for(env_name: T.unsafe(nil), name: T.unsafe(nil), include_replicas: T.unsafe(nil), include_hidden: T.unsafe(nil)); end

  def configurations(); end

  def empty?(); end

  def find_db_config(env); end

  def initialize(configurations=T.unsafe(nil)); end

  def primary?(name); end

  def resolve(config); end
end

class ActiveRecord::DatabaseConfigurations::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::DatabaseConfigurations::ConnectionUrlResolver
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  def _database=(database); end

  def adapter(); end

  def adapter_method(); end

  def checkout_timeout(); end

  def database(); end

  def env_name(); end

  def for_current_env?(); end

  def host(); end

  def idle_timeout(); end

  def initialize(env_name, name); end

  def max_queue(); end

  def max_threads(); end

  def migrations_paths(); end

  def min_threads(); end

  def name(); end

  def owner_name(); end

  def owner_name=(owner_name); end

  def pool(); end

  def reaping_frequency(); end

  def replica?(); end

  def schema_cache_path(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
end

class ActiveRecord::DatabaseConfigurations::HashConfig
  def configuration_hash(); end

  def database_tasks?(); end

  def default_schema_cache_path(); end

  def initialize(env_name, name, configuration_hash); end

  def lazy_schema_cache_path(); end

  def primary?(); end

  def schema_dump(format=T.unsafe(nil)); end

  def socket(); end
end

class ActiveRecord::DatabaseConfigurations::HashConfig
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
  def initialize(env_name, name, url, configuration_hash=T.unsafe(nil)); end

  def url(); end
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
end

class ActiveRecord::DatabaseConfigurations
end

class ActiveRecord::DatabaseConnectionError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::DatabaseConnectionError
  def self.hostname_error(hostname); end

  def self.username_error(username); end
end

module ActiveRecord::DelegatedType
  def delegated_type(role, types:, **options); end
end

module ActiveRecord::DelegatedType
end

module ActiveRecord::Delegation
  def &(*arg, **arg1, &arg2); end

  def +(*arg, **arg1, &arg2); end

  def -(*arg, **arg1, &arg2); end

  def [](*arg, **arg1, &arg2); end

  def as_json(*arg, **arg1, &arg2); end

  def compact(*arg, **arg1, &arg2); end

  def connection(*arg, **arg1, &arg2); end

  def each(*arg, **arg1, &arg2); end

  def encode_with(*arg, **arg1, &arg2); end

  def in_groups(*arg, **arg1, &arg2); end

  def in_groups_of(*arg, **arg1, &arg2); end

  def index(*arg, **arg1, &arg2); end

  def join(*arg, **arg1, &arg2); end

  def length(*arg, **arg1, &arg2); end

  def primary_key(*arg, **arg1, &arg2); end

  def reverse(*arg, **arg1, &arg2); end

  def rindex(*arg, **arg1, &arg2); end

  def rotate(*arg, **arg1, &arg2); end

  def sample(*arg, **arg1, &arg2); end

  def shuffle(*arg, **arg1, &arg2); end

  def slice(*arg, **arg1, &arg2); end

  def split(*arg, **arg1, &arg2); end

  def to_formatted_s(*arg, **arg1, &arg2); end

  def to_fs(*arg, **arg1, &arg2); end

  def to_sentence(*arg, **arg1, &arg2); end

  def to_xml(*arg, **arg1, &arg2); end

  def |(*arg, **arg1, &arg2); end
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DestroyAssociationAsyncError
end

class ActiveRecord::DestroyAssociationAsyncError
end

class ActiveRecord::DestroyAssociationAsyncJob
  def perform(owner_model_name: T.unsafe(nil), owner_id: T.unsafe(nil), association_class: T.unsafe(nil), association_ids: T.unsafe(nil), association_primary_key_column: T.unsafe(nil), ensuring_owner_was_method: T.unsafe(nil)); end
end

class ActiveRecord::DisableJoinsAssociationRelation
  def initialize(klass, key, ids); end

  def key(); end

  def load(); end
end

class ActiveRecord::DisableJoinsAssociationRelation
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, method_name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

module ActiveRecord::Encryption
  include ::ActiveRecord::Encryption::Configurable
  include ::ActiveRecord::Encryption::Contexts
  def config(); end

  def custom_contexts(); end

  def custom_contexts=(obj); end

  def default_context(); end

  def encrypted_attribute_declaration_listeners(); end

  def encrypted_attribute_declaration_listeners=(val); end
end

class ActiveRecord::Encryption::Cipher
  def decrypt(encrypted_message, key:); end

  def encrypt(clean_text, key:, deterministic: T.unsafe(nil)); end

  def iv_length(); end

  def key_length(); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def decrypt(encrypted_message); end

  def encrypt(clear_text); end

  def initialize(secret, deterministic: T.unsafe(nil)); end
  CIPHER_TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def self.iv_length(); end

  def self.key_length(); end
end

class ActiveRecord::Encryption::Cipher
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Encryption::Config
  def add_to_filter_parameters(); end

  def add_to_filter_parameters=(add_to_filter_parameters); end

  def deterministic_key(); end

  def deterministic_key=(deterministic_key); end

  def encrypt_fixtures(); end

  def encrypt_fixtures=(encrypt_fixtures); end

  def excluded_from_filter_parameters(); end

  def excluded_from_filter_parameters=(excluded_from_filter_parameters); end

  def extend_queries(); end

  def extend_queries=(extend_queries); end

  def forced_encoding_for_deterministic_encryption(); end

  def forced_encoding_for_deterministic_encryption=(forced_encoding_for_deterministic_encryption); end

  def key_derivation_salt(); end

  def key_derivation_salt=(key_derivation_salt); end

  def previous=(previous_schemes_properties); end

  def previous_schemes(); end

  def previous_schemes=(previous_schemes); end

  def primary_key(); end

  def primary_key=(primary_key); end

  def store_key_references(); end

  def store_key_references=(store_key_references); end

  def support_unencrypted_data(); end

  def support_unencrypted_data=(support_unencrypted_data); end

  def validate_column_size(); end

  def validate_column_size=(validate_column_size); end
end

class ActiveRecord::Encryption::Config
end

module ActiveRecord::Encryption::Configurable
end

module ActiveRecord::Encryption::Configurable::ClassMethods
  def cipher(*arg, **arg1, &arg2); end

  def configure(primary_key:, deterministic_key:, key_derivation_salt:, **properties); end

  def encrypted_attribute_was_declared(klass, name); end

  def encryptor(*arg, **arg1, &arg2); end

  def frozen_encryption(*arg, **arg1, &arg2); end

  def install_auto_filtered_parameters_hook(application); end

  def key_generator(*arg, **arg1, &arg2); end

  def key_provider(*arg, **arg1, &arg2); end

  def message_serializer(*arg, **arg1, &arg2); end

  def on_encrypted_attribute_declared(&block); end
end

module ActiveRecord::Encryption::Configurable::ClassMethods
end

module ActiveRecord::Encryption::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Encryption::Context
  def cipher(); end

  def cipher=(cipher); end

  def encryptor(); end

  def encryptor=(encryptor); end

  def frozen_encryption(); end

  def frozen_encryption=(frozen_encryption); end

  def frozen_encryption?(); end

  def key_generator(); end

  def key_generator=(key_generator); end

  def key_provider(); end

  def key_provider=(key_provider); end

  def message_serializer(); end

  def message_serializer=(message_serializer); end
  PROPERTIES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Context
end

module ActiveRecord::Encryption::Contexts
end

module ActiveRecord::Encryption::Contexts::ClassMethods
  def context(); end

  def current_custom_context(); end

  def protecting_encrypted_data(&block); end

  def with_encryption_context(properties); end

  def without_encryption(&block); end
end

module ActiveRecord::Encryption::Contexts::ClassMethods
end

module ActiveRecord::Encryption::Contexts
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Encryption::DerivedSecretKeyProvider
  def initialize(passwords); end
end

class ActiveRecord::Encryption::DerivedSecretKeyProvider
end

class ActiveRecord::Encryption::DeterministicKeyProvider
  def initialize(password); end
end

class ActiveRecord::Encryption::DeterministicKeyProvider
end

module ActiveRecord::Encryption::EncryptableRecord
  def ciphertext_for(attribute_name); end

  def decrypt(); end

  def encrypt(); end

  def encrypted_attribute?(attribute_name); end
  ORIGINAL_ATTRIBUTE_PREFIX = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Encryption::EncryptableRecord
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Encryption::EncryptedAttributeType
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(*arg, **arg1, &arg2); end

  def cast_type(); end

  def deterministic?(*arg, **arg1, &arg2); end

  def downcase?(*arg, **arg1, &arg2); end

  def fixed?(*arg, **arg1, &arg2); end

  def initialize(scheme:, cast_type: T.unsafe(nil), previous_type: T.unsafe(nil)); end

  def key_provider(*arg, **arg1, &arg2); end

  def previous_schemes(*arg, **arg1, &arg2); end

  def previous_types(); end

  def scheme(); end

  def with_context(*arg, **arg1, &arg2); end
end

class ActiveRecord::Encryption::EncryptedAttributeType
end

module ActiveRecord::Encryption::EncryptedFixtures
  def initialize(fixture, model_class); end
end

module ActiveRecord::Encryption::EncryptedFixtures
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::Encryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clear_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
  DECRYPT_ERRORS = ::T.let(nil, ::T.untyped)
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
  THRESHOLD_TO_JUSTIFY_COMPRESSION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Encryptor
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
  def active_primary_key(); end

  def decryption_keys(encrypted_message); end

  def encryption_key(); end
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
end

module ActiveRecord::Encryption::Errors
end

class ActiveRecord::Encryption::Errors::Base
end

class ActiveRecord::Encryption::Errors::Base
end

class ActiveRecord::Encryption::Errors::Configuration
end

class ActiveRecord::Encryption::Errors::Configuration
end

class ActiveRecord::Encryption::Errors::Decryption
end

class ActiveRecord::Encryption::Errors::Decryption
end

class ActiveRecord::Encryption::Errors::Encoding
end

class ActiveRecord::Encryption::Errors::Encoding
end

class ActiveRecord::Encryption::Errors::EncryptedContentIntegrity
end

class ActiveRecord::Encryption::Errors::EncryptedContentIntegrity
end

class ActiveRecord::Encryption::Errors::Encryption
end

class ActiveRecord::Encryption::Errors::Encryption
end

class ActiveRecord::Encryption::Errors::ForbiddenClass
end

class ActiveRecord::Encryption::Errors::ForbiddenClass
end

module ActiveRecord::Encryption::Errors
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
  def initialize(value, type); end

  def type(); end

  def value(); end
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
  include ::ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  def find_by(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
  def serialize(data); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::InWithAdditionalValues
  def encryption_aware_type_caster(); end

  def proc_for_binds(); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::InWithAdditionalValues
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
  include ::ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  def exists?(*args); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def where(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
  def self.install_support(); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
  def validate_each(record, attribute, value); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
  def self.install_support(); end
end

class ActiveRecord::Encryption::Key
  def id(); end

  def initialize(secret); end

  def public_tags(); end

  def secret(); end
end

class ActiveRecord::Encryption::Key
  def self.derive_from(password); end
end

class ActiveRecord::Encryption::KeyGenerator
  def derive_key_from(password, length: T.unsafe(nil)); end

  def generate_random_hex_key(length: T.unsafe(nil)); end

  def generate_random_key(length: T.unsafe(nil)); end
end

class ActiveRecord::Encryption::KeyGenerator
end

class ActiveRecord::Encryption::KeyProvider
  def decryption_keys(encrypted_message); end

  def encryption_key(); end

  def initialize(keys); end
end

class ActiveRecord::Encryption::KeyProvider
end

class ActiveRecord::Encryption::Message
  def ==(other_message); end

  def headers(); end

  def headers=(headers); end

  def initialize(payload: T.unsafe(nil), headers: T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
end

class ActiveRecord::Encryption::Message
end

class ActiveRecord::Encryption::MessageSerializer
  def dump(message); end

  def load(serialized_content); end
end

class ActiveRecord::Encryption::MessageSerializer
end

class ActiveRecord::Encryption::NullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::NullEncryptor
end

class ActiveRecord::Encryption::Properties
  def ==(arg); end

  def []=(key, value); end

  def add(other_properties); end

  def auth_tag(); end

  def auth_tag=(value); end

  def compressed(); end

  def compressed=(value); end

  def encoding(); end

  def encoding=(value); end

  def encrypted_data_key(); end

  def encrypted_data_key=(value); end

  def encrypted_data_key_id(); end

  def encrypted_data_key_id=(value); end

  def initialize(initial_properties=T.unsafe(nil)); end

  def iv(); end

  def iv=(value); end

  def method_missing(method, *args, **arg, &block); end

  def to_h(); end

  def validate_value_type(value); end
  ALLOWED_VALUE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_PROPERTIES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Properties
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
end

class ActiveRecord::Encryption::Scheme
  def deterministic?(); end

  def downcase?(); end

  def fixed?(); end

  def ignore_case?(); end

  def initialize(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous_schemes: T.unsafe(nil), **context_properties); end

  def key_provider(); end

  def merge(other_scheme); end

  def previous_schemes(); end

  def previous_schemes=(previous_schemes); end

  def to_h(); end

  def with_context(&block); end
end

class ActiveRecord::Encryption::Scheme
end

module ActiveRecord::Encryption
  extend ::ActiveSupport::Autoload
  extend ::ActiveRecord::Encryption::Configurable::ClassMethods
  extend ::ActiveRecord::Encryption::Contexts::ClassMethods
  def self.config(); end

  def self.custom_contexts(); end

  def self.custom_contexts=(obj); end

  def self.default_context(); end

  def self.encrypted_attribute_declaration_listeners(); end

  def self.encrypted_attribute_declaration_listeners=(val); end
end

module ActiveRecord::Enum
  include ::DEBUGGER__::TrapInterceptor
  def _define_enum(arg0, &blk); end

  def _define_typed_enum(*args, **arg, &blk); end

  def enum(arg0, &blk); end

  def extract_enum_values(arg0, &blk); end

  def gen_typed_enum_values(arg0, &blk); end

  def inherited(base); end

  def old_enum(name=T.unsafe(nil), values=T.unsafe(nil), **options); end

  def typed_enum_reflections(&blk); end
  SR_ENUM_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def serializable?(value, &block); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end
end

class ActiveRecord::Enum::EnumType
end

module ActiveRecord::Enum
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

class ActiveRecord::EnvironmentStorageError
  def initialize(); end
end

class ActiveRecord::EnvironmentStorageError
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  def self.collect(*arg, **arg1, &arg2); end

  def self.collect=(arg); end

  def self.collect?(*arg, **arg1, &arg2); end

  def self.queries(*arg, **arg1, &arg2); end

  def self.reset(*arg, **arg1, &arg2); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def find_sole_by(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def include?(record); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def member?(record); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def sole(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::FutureResult
  def cancel(); end

  def empty?(*arg, **arg1, &arg2); end

  def execute!(connection); end

  def execute_or_skip(); end

  def initialize(pool, *args, **kwargs); end

  def lock_wait(); end

  def pending?(); end

  def result(); end

  def schedule!(session); end

  def to_a(*arg, **arg1, &arg2); end
end

class ActiveRecord::FutureResult::Canceled
end

class ActiveRecord::FutureResult::Canceled
end

class ActiveRecord::FutureResult::EventBuffer
  def flush(); end

  def initialize(future_result, instrumenter); end

  def instrument(name, payload=T.unsafe(nil), &block); end
end

class ActiveRecord::FutureResult::EventBuffer
end

class ActiveRecord::FutureResult::SelectAll
end

class ActiveRecord::FutureResult::SelectAll
end

class ActiveRecord::FutureResult
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  include ::DidYouMean::Correctable
  def initialize(owner_class=T.unsafe(nil), reflection=T.unsafe(nil)); end

  def owner_class(); end

  def reflection(); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InsertAll
  def connection(); end

  def execute(); end

  def initialize(model, inserts, on_duplicate:, update_only: T.unsafe(nil), returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  def inserts(); end

  def keys(); end

  def keys_including_timestamps(); end

  def map_key_with_value(); end

  def model(); end

  def on_duplicate(); end

  def primary_keys(); end

  def record_timestamps?(); end

  def returning(); end

  def skip_duplicates?(); end

  def unique_by(); end

  def updatable_columns(); end

  def update_duplicates?(); end

  def update_only(); end

  def update_sql(); end
end

class ActiveRecord::InsertAll::Builder
  def conflict_target(); end

  def initialize(insert_all); end

  def into(); end

  def keys(*arg, **arg1, &arg2); end

  def keys_including_timestamps(*arg, **arg1, &arg2); end

  def model(); end

  def raw_update_sql(); end

  def raw_update_sql?(); end

  def record_timestamps?(*arg, **arg1, &arg2); end

  def returning(); end

  def skip_duplicates?(*arg, **arg1, &arg2); end

  def touch_model_timestamps_unless(&block); end

  def updatable_columns(); end

  def update_duplicates?(*arg, **arg1, &arg2); end

  def values_list(); end
end

class ActiveRecord::InsertAll::Builder
end

class ActiveRecord::InsertAll
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::InternalMetadata
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.enabled?(); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
  include ::DidYouMean::Correctable
  def associated_class(); end

  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end

  def reflection(); end
end

class ActiveRecord::InverseOfAssociationRecursiveError
  def initialize(reflection=T.unsafe(nil)); end

  def reflection(); end
end

class ActiveRecord::InverseOfAssociationRecursiveError
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Locking::LockingType
  def self.new(subtype); end
end

module ActiveRecord::Locking::Optimistic
  def increment!(*arg, **arg1); end

  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def backtrace_cleaner?(); end

  def sql(event); end

  def strict_loading_violation(event); end
end

class ActiveRecord::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(value); end

  def self.backtrace_cleaner?(); end

  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module ActiveRecord::Middleware
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def update_context(response); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def save(response); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

class ActiveRecord::Middleware::ShardSelector
  def call(env); end

  def initialize(app, resolver, options=T.unsafe(nil)); end

  def options(); end

  def resolver(); end
end

class ActiveRecord::Middleware::ShardSelector
end

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, **arg, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes, &block); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(&block); end

  def verbose(); end

  def verbose=(val); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app, file_watcher: T.unsafe(nil)); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, **arg, &block); end

  def add_check_constraint(*args, **arg, &block); end

  def add_column(*args, **arg, &block); end

  def add_foreign_key(*args, **arg, &block); end

  def add_index(*args, **arg, &block); end

  def add_reference(*args, **arg, &block); end

  def add_timestamps(*args, **arg, &block); end

  def change_column(*args, **arg, &block); end

  def change_column_comment(*args, **arg, &block); end

  def change_column_default(*args, **arg, &block); end

  def change_column_null(*args, **arg, &block); end

  def change_table(table_name, **options); end

  def change_table_comment(*args, **arg, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, **arg, &block); end

  def create_table(*args, **arg, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, **arg, &block); end

  def drop_join_table(*args, **arg, &block); end

  def drop_table(*args, **arg, &block); end

  def enable_extension(*args, **arg, &block); end

  def execute(*args, **arg, &block); end

  def execute_block(*args, **arg, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, **arg, &block); end

  def remove_check_constraint(*args, **arg, &block); end

  def remove_column(*args, **arg, &block); end

  def remove_columns(*args, **arg, &block); end

  def remove_foreign_key(*args, **arg, &block); end

  def remove_index(*args, **arg, &block); end

  def remove_reference(*args, **arg, &block); end

  def remove_timestamps(*args, **arg, &block); end

  def rename_column(*args, **arg, &block); end

  def rename_index(*args, **arg, &block); end

  def rename_table(*args, **arg, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, **arg, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_check_constraint(args, &block); end

  def invert_add_column(args, &block); end

  def invert_add_foreign_key(args, &block); end

  def invert_add_index(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_check_constraint(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_foreign_key(args, &block); end

  def invert_remove_index(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*arg, **options); end

  def references(*arg, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, **options); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def column(name, type, index: T.unsafe(nil), **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V6_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_reference(table_name, ref_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

class ActiveRecord::Migration::Compatibility::V6_0::ReferenceDefinition
end

class ActiveRecord::Migration::Compatibility::V6_0::ReferenceDefinition
end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3
end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3::TableDefinition
  def belongs_to(*args, **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3::TableDefinition
end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3
end

module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
  def belongs_to(*args, **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V6_1
  def add_column(table_name, column_name, type, **options); end

  def create_table(table_name, **options); end
end

class ActiveRecord::Migration::Compatibility::V6_1::PostgreSQLCompat
end

class ActiveRecord::Migration::Compatibility::V6_1::PostgreSQLCompat
  def self.compatible_timestamp_type(type, connection); end
end

module ActiveRecord::Migration::Compatibility::V6_1::TableDefinition
  def column(name, type, index: T.unsafe(nil), **options); end

  def new_column_definition(name, type, **options); end
end

module ActiveRecord::Migration::Compatibility::V6_1::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, **arg, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(val); end
end

class ActiveRecord::MigrationContext
  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil), &block); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration=T.unsafe(nil)); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def pending_migration_versions(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil), &block); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*arg, **arg1, &arg2); end

  def basename(); end

  def disable_ddl_transaction(*arg, **arg1, &arg2); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*arg, **arg1, &arg2); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*arg, **arg1, &arg2); end
end

class ActiveRecord::MigrationProxy
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, schema_migration, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::NoDatabaseError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(_actions); end

  def _actions?(); end

  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::NoDatabaseError
  def self._actions(); end

  def self._actions=(value); end

  def self._actions?(); end

  def self.db_error(db_name); end
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*arg, **arg1); end

  def touch_later(*arg); end
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(_actions); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(value); end

  def self._actions?(); end
end

module ActiveRecord::Persistence
  def previously_new_record?(); end

  def previously_persisted?(); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder
  def [](attr_name, value, operator=T.unsafe(nil)); end

  def build(attribute, value, operator=T.unsafe(nil)); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes, &block); end

  def expand_from_hash(attributes, &block); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_arel_attribute(table_name, column_name, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryLogs
end

module ActiveRecord::QueryLogs
  def self.cache_query_log_tags(); end

  def self.cache_query_log_tags=(val); end

  def self.cached_comment(); end

  def self.cached_comment=(obj); end

  def self.call(sql); end

  def self.clear_cache(); end

  def self.prepend_comment(); end

  def self.prepend_comment=(val); end

  def self.taggings(); end

  def self.taggings=(val); end

  def self.tags(); end

  def self.tags=(val); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def and(other); end

  def and!(other); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_having_clause(opts, rest=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def build_where_clause(opts, rest=T.unsafe(nil)); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def excluding(*records); end

  def excluding!(records); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def in_order_of(column, values); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def invert_where(); end

  def invert_where!(); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def strict_loading(value=T.unsafe(nil)); end

  def strict_loading!(value=T.unsafe(nil)); end

  def strict_loading_value(); end

  def strict_loading_value=(value); end

  def structurally_compatible?(other); end

  def uniq!(name); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(*args); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end

  def without(*records); end
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::QueryMethods
end

module ActiveRecord::Querying
  def _load_from_sql(result_set, &block); end

  def _query_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def and(*arg, **arg1, &arg2); end

  def annotate(*arg, **arg1, &arg2); end

  def any?(*arg, **arg1, &arg2); end

  def average(*arg, **arg1, &arg2); end

  def calculate(*arg, **arg1, &arg2); end

  def count(*arg, **arg1, &arg2); end

  def count_by_sql(sql); end

  def create_or_find_by(*arg, **arg1, &arg2); end

  def create_or_find_by!(*arg, **arg1, &arg2); end

  def create_with(*arg, **arg1, &arg2); end

  def delete_all(*arg, **arg1, &arg2); end

  def delete_by(*arg, **arg1, &arg2); end

  def destroy_all(*arg, **arg1, &arg2); end

  def destroy_by(*arg, **arg1, &arg2); end

  def distinct(*arg, **arg1, &arg2); end

  def eager_load(*arg, **arg1, &arg2); end

  def except(*arg, **arg1, &arg2); end

  def excluding(*arg, **arg1, &arg2); end

  def exists?(*arg, **arg1, &arg2); end

  def extending(*arg, **arg1, &arg2); end

  def extract_associated(*arg, **arg1, &arg2); end

  def fifth(*arg, **arg1, &arg2); end

  def fifth!(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_by(*arg, **arg1, &arg2); end

  def find_by!(*arg, **arg1, &arg2); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*arg, **arg1, &arg2); end

  def find_in_batches(*arg, **arg1, &arg2); end

  def find_or_create_by(*arg, **arg1, &arg2); end

  def find_or_create_by!(*arg, **arg1, &arg2); end

  def find_or_initialize_by(*arg, **arg1, &arg2); end

  def find_sole_by(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def first!(*arg, **arg1, &arg2); end

  def first_or_create(*arg, **arg1, &arg2); end

  def first_or_create!(*arg, **arg1, &arg2); end

  def first_or_initialize(*arg, **arg1, &arg2); end

  def forty_two(*arg, **arg1, &arg2); end

  def forty_two!(*arg, **arg1, &arg2); end

  def fourth(*arg, **arg1, &arg2); end

  def fourth!(*arg, **arg1, &arg2); end

  def from(*arg, **arg1, &arg2); end

  def group(*arg, **arg1, &arg2); end

  def having(*arg, **arg1, &arg2); end

  def ids(*arg, **arg1, &arg2); end

  def in_batches(*arg, **arg1, &arg2); end

  def in_order_of(*arg, **arg1, &arg2); end

  def includes(*arg, **arg1, &arg2); end

  def invert_where(*arg, **arg1, &arg2); end

  def joins(*arg, **arg1, &arg2); end

  def last(*arg, **arg1, &arg2); end

  def last!(*arg, **arg1, &arg2); end

  def left_joins(*arg, **arg1, &arg2); end

  def left_outer_joins(*arg, **arg1, &arg2); end

  def limit(*arg, **arg1, &arg2); end

  def lock(*arg, **arg1, &arg2); end

  def many?(*arg, **arg1, &arg2); end

  def maximum(*arg, **arg1, &arg2); end

  def merge(*arg, **arg1, &arg2); end

  def minimum(*arg, **arg1, &arg2); end

  def none(*arg, **arg1, &arg2); end

  def none?(*arg, **arg1, &arg2); end

  def offset(*arg, **arg1, &arg2); end

  def one?(*arg, **arg1, &arg2); end

  def only(*arg, **arg1, &arg2); end

  def optimizer_hints(*arg, **arg1, &arg2); end

  def or(*arg, **arg1, &arg2); end

  def order(*arg, **arg1, &arg2); end

  def pick(*arg, **arg1, &arg2); end

  def pluck(*arg, **arg1, &arg2); end

  def preload(*arg, **arg1, &arg2); end

  def readonly(*arg, **arg1, &arg2); end

  def references(*arg, **arg1, &arg2); end

  def reorder(*arg, **arg1, &arg2); end

  def reselect(*arg, **arg1, &arg2); end

  def rewhere(*arg, **arg1, &arg2); end

  def second(*arg, **arg1, &arg2); end

  def second!(*arg, **arg1, &arg2); end

  def second_to_last(*arg, **arg1, &arg2); end

  def second_to_last!(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def sole(*arg, **arg1, &arg2); end

  def strict_loading(*arg, **arg1, &arg2); end

  def sum(*arg, **arg1, &arg2); end

  def take(*arg, **arg1, &arg2); end

  def take!(*arg, **arg1, &arg2); end

  def third(*arg, **arg1, &arg2); end

  def third!(*arg, **arg1, &arg2); end

  def third_to_last(*arg, **arg1, &arg2); end

  def third_to_last!(*arg, **arg1, &arg2); end

  def touch_all(*arg, **arg1, &arg2); end

  def unscope(*arg, **arg1, &arg2); end

  def update_all(*arg, **arg1, &arg2); end

  def where(*arg, **arg1, &arg2); end

  def without(*arg, **arg1, &arg2); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Railtie
  SQLITE3_PRODUCTION_WARN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::Reflection::AbstractReflection
  def actual_source_reflection(); end

  def alias_candidate(name); end

  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder=T.unsafe(nil), klass=T.unsafe(nil)); end

  def chain(); end

  def check_validity_of_inverse!(); end

  def class_name(); end

  def constraints(); end

  def counter_cache_column(); end

  def counter_must_be_updated_by_has_many?(); end

  def has_cached_counter?(); end

  def inverse_of(); end

  def inverse_updates_counter_cache?(); end

  def inverse_updates_counter_in_memory?(); end

  def inverse_which_updates_counter_cache(); end

  def join_scope(table, foreign_table, foreign_klass); end

  def join_scopes(table, predicate_builder, klass=T.unsafe(nil), record=T.unsafe(nil)); end

  def klass_join_scope(table, predicate_builder); end

  def scopes(); end

  def strict_loading?(); end

  def table_name(); end

  def through_reflection?(); end
end

class ActiveRecord::Reflection::AbstractReflection
end

class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end

  def active_record(); end

  def autosave=(autosave); end

  def compute_class(name); end

  def initialize(name, scope, options, active_record); end

  def klass(); end

  def name(); end

  def options(); end

  def plural_name(); end

  def scope(); end

  def scope_for(relation, owner=T.unsafe(nil)); end
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::ActiveStorage::Reflection::ReflectionExtension
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  include ::SorbetRails::CustomFinderMethods
  def ==(other); end

  def _exec_scope(*args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def bind_attribute(name, value); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_key_with_version(); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_async(); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def reload(); end

  def reset(); end

  def scheduled?(); end

  def scope_for_create(); end

  def scoping(all_queries: T.unsafe(nil), &block); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update!(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def values_for_queries(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Result
  def [](idx); end

  def cancel(); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def column_types(); end

  def columns(); end

  def each(&block); end

  def empty?(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(n=T.unsafe(nil)); end

  def length(); end

  def result(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end
end

class ActiveRecord::Result
  def self.empty(); end
end

module ActiveRecord::RuntimeRegistry
  def sql_runtime(); end

  def sql_runtime=(runtime); end
end

module ActiveRecord::RuntimeRegistry
  extend ::ActiveRecord::RuntimeRegistry
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  include ::ActiveRecord::Schema::Definition
end

module ActiveRecord::Schema::Definition
  def define(info, &block); end
end

module ActiveRecord::Schema::Definition::ClassMethods
  def define(info=T.unsafe(nil), &block); end
end

module ActiveRecord::Schema::Definition::ClassMethods
end

module ActiveRecord::Schema::Definition
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  extend ::ActiveRecord::Schema::Definition::ClassMethods
end

class ActiveRecord::SchemaDumper
  def chk_ignore_pattern(); end

  def chk_ignore_pattern=(val); end

  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(val); end

  def ignore_tables(); end

  def ignore_tables=(val); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.chk_ignore_pattern(); end

  def self.chk_ignore_pattern=(val); end

  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(val); end

  def self.ignore_tables(); end

  def self.ignore_tables=(val); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def version(); end
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end

  def self.page(num=T.unsafe(nil)); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::SecureToken
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil), &block); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SignedId
  def signed_id(expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

module ActiveRecord::SignedId
  extend ::ActiveSupport::Concern
end

class ActiveRecord::SoleRecordExceeded
  def initialize(record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::SoleRecordExceeded
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other, *rest); end

  def merge!(other, *rest); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
end

class ActiveRecord::StrictLoadingViolationError
end

class ActiveRecord::StrictLoadingViolationError
end

module ActiveRecord::Suppressor
  def self.registry(); end
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_table(); end

  def associated_table(table_name); end

  def associated_with?(table_name); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, reflection=T.unsafe(nil)); end

  def join_foreign_key(*arg, **arg1, &arg2); end

  def join_foreign_type(*arg, **arg1, &arg2); end

  def join_primary_key(*arg, **arg1, &arg2); end

  def polymorphic_association?(); end

  def predicate_builder(); end

  def primary_key(); end

  def reflect_on_aggregation(aggregation_name); end

  def through_association?(); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

class ActiveRecord::TableNotSpecified
end

class ActiveRecord::TableNotSpecified
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(db_config_name, schema_cache_path: T.unsafe(nil)); end

  def charset(configuration, *arguments); end

  def charset_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def clear_schema_cache(filename); end

  def collation(configuration, *arguments); end

  def collation_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def create(configuration, *arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), name=T.unsafe(nil)); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_configs_with_versions(db_configs); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(configuration, *arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_schema(db_config, format=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(version=T.unsafe(nil)); end

  def migrate_status(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def name(); end

  def prepare_all(); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_dump_path(db_config, format=T.unsafe(nil)); end

  def schema_file_type(*args, **arg, &block); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def structure_dump(configuration, *arguments); end

  def structure_load(configuration, *arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(val); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(val); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*arg, **arg1, &arg2); end

  def create(); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*arg, **arg1, &arg2); end

  def collation(); end

  def connection(*arg, **arg1, &arg2); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*arg, **arg1, &arg2); end

  def create(); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def self.using_database_configurations?(); end
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  def set_fixture_class(class_names=T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names=T.unsafe(nil)); end

  def uses_transaction(*methods); end

  def uses_transaction?(method); end
end

module ActiveRecord::TestFixtures::ClassMethods
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::TouchLater
  def before_committed!(); end
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(**arg); end

  def save!(**arg); end

  def touch(*arg, **arg1); end

  def transaction(**options, &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end

  def lookup(symbol, *args, **kwargs); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

class ActiveRecord::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::DecorationRegistration
end

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def initialize(parent=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString

module ActiveRecord::Type::Internal
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveRecord::Type::Internal::Timezone
end

module ActiveRecord::Type::Internal
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def serialize(value); end

  def subtype(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def fetch(lookup_key, &block); end

  def initialize(parent=T.unsafe(nil)); end

  def lookup(lookup_key); end

  def perform_fetch(lookup_key, &block); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

module ActiveRecord::Type
  def self.adapter_name_from(model); end

  def self.add_modifier(*arg, **arg1, &arg2); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::TypeCaster::Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(attr_name); end
end

class ActiveRecord::TypeCaster::Connection
end

class ActiveRecord::TypeCaster::Map
  def initialize(klass); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(name); end
end

class ActiveRecord::TypeCaster::Map
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def save(**options); end

  def save!(**options); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.action_on_strict_loading_violation(); end

  def self.action_on_strict_loading_violation=(action_on_strict_loading_violation); end

  def self.application_record_class(); end

  def self.application_record_class=(application_record_class); end

  def self.async_query_executor(); end

  def self.async_query_executor=(async_query_executor); end

  def self.default_timezone(); end

  def self.default_timezone=(default_timezone); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(dump_schema_after_migration); end

  def self.dump_schemas(); end

  def self.dump_schemas=(dump_schemas); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(error_on_ignored_order); end

  def self.gem_version(); end

  def self.global_executor_concurrency(); end

  def self.global_executor_concurrency=(global_executor_concurrency); end

  def self.global_thread_pool_async_query_executor(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(index_nested_attribute_errors); end

  def self.lazily_load_schema_cache(); end

  def self.lazily_load_schema_cache=(lazily_load_schema_cache); end

  def self.legacy_connection_handling(); end

  def self.legacy_connection_handling=(legacy_connection_handling); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(maintain_test_schema); end

  def self.query_transformers(); end

  def self.query_transformers=(query_transformers); end

  def self.queues(); end

  def self.queues=(queues); end

  def self.reading_role(); end

  def self.reading_role=(reading_role); end

  def self.schema_cache_ignored_tables(); end

  def self.schema_cache_ignored_tables=(schema_cache_ignored_tables); end

  def self.schema_format(); end

  def self.schema_format=(schema_format); end

  def self.suppress_multiple_database_warning(); end

  def self.suppress_multiple_database_warning=(suppress_multiple_database_warning); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(timestamped_migrations); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(verbose_query_logs); end

  def self.verify_foreign_keys_for_fixtures(); end

  def self.verify_foreign_keys_for_fixtures=(verify_foreign_keys_for_fixtures); end

  def self.version(); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(warn_on_records_fetched_greater_than); end

  def self.writing_role(); end

  def self.writing_role=(writing_role); end
end

class ActiveRecordOverrides
  def enum_calls(); end

  def get_enum_call(klass, enum_sym); end

  def store_enum_call(klass, kwargs); end
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(val); end

  def binary_content_type(); end

  def binary_content_type=(val); end

  def content_types_allowed_inline(); end

  def content_types_allowed_inline=(val); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(val); end

  def draw_routes(); end

  def draw_routes=(val); end

  def logger(); end

  def logger=(val); end

  def paths(); end

  def paths=(val); end

  def previewers(); end

  def previewers=(val); end

  def queues(); end

  def queues=(val); end

  def replace_on_assign_to_many(); end

  def replace_on_assign_to_many=(val); end

  def resolve_model_to_route(); end

  def resolve_model_to_route=(val); end

  def routes_prefix(); end

  def routes_prefix=(val); end

  def service_urls_expire_in(); end

  def service_urls_expire_in=(val); end

  def silence_invalid_content_types_warning(); end

  def silence_invalid_content_types_warning=(val); end

  def supported_image_processing_methods(); end

  def supported_image_processing_methods=(val); end

  def track_variants(); end

  def track_variants=(val); end

  def unsupported_image_processing_arguments(); end

  def unsupported_image_processing_arguments=(val); end

  def urls_expire_in(); end

  def urls_expire_in=(val); end

  def variable_content_types(); end

  def variable_content_types=(val); end

  def variant_processor(); end

  def variant_processor=(val); end

  def verifier(); end

  def verifier=(val); end

  def video_preview_arguments(); end

  def video_preview_arguments=(val); end

  def web_image_content_types(); end

  def web_image_content_types=(val); end
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::Analyzer
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::AudioAnalyzer
end

class ActiveStorage::Analyzer::AudioAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer::ImageMagick
end

class ActiveStorage::Analyzer::ImageAnalyzer::ImageMagick
end

class ActiveStorage::Analyzer::ImageAnalyzer::Vips
  ROTATIONS = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Analyzer::ImageAnalyzer::Vips
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end

  def self.analyze_later?(); end
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Changes
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

class ActiveStorage::Attached::Changes::DetachMany
  def attachments(); end

  def detach(); end

  def initialize(name, record, attachments); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachMany
end

class ActiveStorage::Attached::Changes::DetachOne
  def attachment(); end

  def detach(); end

  def initialize(name, record, attachment); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachOne
end

class ActiveStorage::Attached::Changes::PurgeMany
  def attachments(); end

  def initialize(name, record, attachments); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeMany
end

class ActiveStorage::Attached::Changes::PurgeOne
  def attachment(); end

  def initialize(name, record, attachment); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeOne
end

module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, **arg, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def changed_for_autosave?(); end

  def reload(*arg); end
end

module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, **arg, &block); end
end

class ActiveStorage::Attachment
  include ::ActiveStorage::Attachment::GeneratedAttributeMethods
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def purge(); end

  def purge_later(); end

  def signed_id(*arg, **arg1, &arg2); end

  def validate_associated_records_for_blob(*args); end

  def variant(transformations); end
end

class ActiveStorage::Attachment::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def blob_changed?(); end

  def blob_previously_changed?(); end

  def record_changed?(); end

  def record_previously_changed?(); end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Attachment::GeneratedRelationMethods
  def with_all_variant_records(*arg, **arg1, &arg2); end
end

module ActiveStorage::Attachment::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::BaseController
  include ::ActiveStorage::Streaming
  include ::ActionController::Live
  include ::ActiveStorage::SetCurrent
end

class ActiveStorage::BaseController
end

class ActiveStorage::Blob
  include ::ActiveStorage::Blob::GeneratedAttributeMethods
  include ::ActiveStorage::Blob::Analyzable
  include ::ActiveStorage::Blob::Identifiable
  include ::ActionText::Attachable
  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(*args); end

  def autosave_associated_records_for_preview_image_blob(*args); end

  def autosave_associated_records_for_variant_records(*args); end

  def compose(keys); end

  def content_type=(value); end

  def content_type_for_serving(); end

  def custom_metadata(); end

  def custom_metadata=(metadata); end

  def download(&block); end

  def download_chunk(range); end

  def filename(); end

  def forced_disposition_for_serving(); end

  def image?(); end

  def key(); end

  def mirror_later(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service_headers_for_direct_upload(); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def services(); end

  def services=(services); end

  def services?(); end

  def signed_id(purpose: T.unsafe(nil), expires_in: T.unsafe(nil)); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def validate_associated_records_for_attachments(*args); end

  def validate_associated_records_for_variant_records(*args); end

  def video?(); end
  INVALID_VARIABLE_CONTENT_TYPES_DEPRECATED_IN_RAILS_7 = ::T.let(nil, ::T.untyped)
  INVALID_VARIABLE_CONTENT_TYPES_TO_SERVE_AS_BINARY_DEPRECATED_IN_RAILS_7 = ::T.let(nil, ::T.untyped)
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Blob::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::Analyzable
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids=(ids); end

  def variant_record_ids=(ids); end
end

module ActiveStorage::Blob::GeneratedAttributeMethods
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::GeneratedRelationMethods
  def unattached(*arg, **arg1, &arg2); end

  def with_attached_preview_image(*arg, **arg1, &arg2); end
end

module ActiveStorage::Blob::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end

  def identify_without_saving(); end
end

module ActiveStorage::Blob::Identifiable
end

module ActiveStorage::Blob::Representable
  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

module ActiveStorage::Blob::Representable
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Blob
  extend ::ActionText::Attachable::ClassMethods
  def self.build_after_unfurling(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.compose(blobs, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.find_signed(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.find_signed!(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.scope_for_strict_loading(); end

  def self.service(); end

  def self.service=(value); end

  def self.service?(); end

  def self.services(); end

  def self.services=(value); end

  def self.services?(); end
end

module ActiveStorage::Blobs
end

class ActiveStorage::Blobs::ProxyController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::Blobs::ProxyController
end

class ActiveStorage::Blobs::RedirectController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::Blobs::RedirectController
end

module ActiveStorage::Blobs
end

class ActiveStorage::Current
  def host(); end

  def host=(host); end
end

class ActiveStorage::Current
  def self.url_options(); end

  def self.url_options=(value); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DirectUploadsController
end

class ActiveStorage::DiskController
  include ::ActiveStorage::FileServer
  def show(); end

  def update(); end
end

class ActiveStorage::DiskController
end

class ActiveStorage::Downloader
  def initialize(service); end

  def open(key, checksum: T.unsafe(nil), verify: T.unsafe(nil), name: T.unsafe(nil), tmpdir: T.unsafe(nil)); end

  def service(); end
end

class ActiveStorage::Downloader
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::Error
end

class ActiveStorage::Error
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::FileNotFoundError
end

module ActiveStorage::FileServer
end

module ActiveStorage::FileServer
end

class ActiveStorage::Filename
  include ::Comparable
  def as_json(*arg); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::FixtureSet
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveRecord::SecureToken
  def file_fixture_path(); end

  def file_fixture_path?(); end

  def prepare(instance, **attributes); end
end

class ActiveStorage::FixtureSet
  def self.blob(filename:, **attributes); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_mirror(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::LogSubscriber
end

class ActiveStorage::MirrorJob
  def perform(key, checksum:); end
end

class ActiveStorage::Preview
  def blob(); end

  def download(&block); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def url(**options); end

  def variation(); end
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview
end

class ActiveStorage::PreviewError
end

class ActiveStorage::PreviewError
end

class ActiveStorage::Previewer
  def blob(); end

  def initialize(blob); end

  def preview(**options); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
  def self.ffmpeg_exists?(); end

  def self.ffmpeg_path(); end
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

class ActiveStorage::Record
  include ::ActiveStorage::Record::GeneratedAttributeMethods
  include ::ActiveStorage::Record::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

class ActiveStorage::Record::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Record::GeneratedRelationMethods
end

class ActiveStorage::Record::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Record::GeneratedRelationMethods
end

class ActiveStorage::Record::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Record::GeneratedRelationMethods
end

module ActiveStorage::Record::GeneratedAssociationMethods
end

module ActiveStorage::Record::GeneratedAssociationMethods
end

module ActiveStorage::Record::GeneratedAttributeMethods
end

module ActiveStorage::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Record::GeneratedRelationMethods
end

module ActiveStorage::Record::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::Record
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module ActiveStorage::Reflection
end

module ActiveStorage::Reflection::ActiveRecordExtensions
end

module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Reflection::HasAttachedReflection
  def variant(name, transformations); end

  def variants(); end
end

class ActiveStorage::Reflection::HasAttachedReflection
end

class ActiveStorage::Reflection::HasManyAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasManyAttachedReflection
end

class ActiveStorage::Reflection::HasOneAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasOneAttachedReflection
end

module ActiveStorage::Reflection::ReflectionExtension
  def add_attachment_reflection(model, name, reflection); end
end

module ActiveStorage::Reflection::ReflectionExtension
end

module ActiveStorage::Reflection
end

module ActiveStorage::Representations
end

class ActiveStorage::Representations::BaseController
  include ::ActiveStorage::SetBlob
end

class ActiveStorage::Representations::BaseController
end

class ActiveStorage::Representations::ProxyController
  def show(); end
end

class ActiveStorage::Representations::ProxyController
end

class ActiveStorage::Representations::RedirectController
  def show(); end
end

class ActiveStorage::Representations::RedirectController
end

module ActiveStorage::Representations
end

class ActiveStorage::Service
  def compose(source_keys, destination_key, filename: T.unsafe(nil), content_type: T.unsafe(nil), disposition: T.unsafe(nil), custom_metadata: T.unsafe(nil)); end

  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:, custom_metadata: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def open(*args, **options, &block); end

  def public?(); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, **options); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:, custom_metadata: T.unsafe(nil)); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service::DiskService
  def compose(source_keys, destination_key, **arg); end

  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, **arg); end

  def initialize(root:, public: T.unsafe(nil), **options); end

  def path_for(key); end

  def root(); end

  def root=(root); end

  def upload(key, io, checksum: T.unsafe(nil), **arg); end
end

class ActiveStorage::Service::DiskService
end

class ActiveStorage::Service::Registry
  def fetch(name); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Registry
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, name:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end
end

module ActiveStorage::SetBlob
end

module ActiveStorage::SetBlob
  extend ::ActiveSupport::Concern
end

module ActiveStorage::SetCurrent
end

module ActiveStorage::SetCurrent
  extend ::ActiveSupport::Concern
end

module ActiveStorage::Streaming
  include ::ActionController::Rendering
  include ::ActionController::DataStreaming
  include ::ActionController::Live
  DEFAULT_BLOB_STREAMING_DISPOSITION = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::Streaming
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Live::ClassMethods
end

module ActiveStorage::Transformers
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*arg, **arg1, &arg2); end

  def content_type_for_serving(*arg, **arg1, &arg2); end

  def download(&block); end

  def filename(); end

  def forced_disposition_for_serving(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*arg, **arg1, &arg2); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
end

class ActiveStorage::Variant
end

class ActiveStorage::VariantRecord
  include ::ActiveStorage::VariantRecord::GeneratedAttributeMethods
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_image_attachment(*args); end

  def autosave_associated_records_for_image_blob(*args); end
end

class ActiveStorage::VariantRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::VariantRecord::GeneratedRelationMethods
end

class ActiveStorage::VariantRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::VariantRecord::GeneratedRelationMethods
end

class ActiveStorage::VariantRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::VariantRecord::GeneratedRelationMethods
end

module ActiveStorage::VariantRecord::GeneratedAssociationMethods
  def blob_changed?(); end

  def blob_previously_changed?(); end
end

module ActiveStorage::VariantRecord::GeneratedAttributeMethods
end

module ActiveStorage::VariantRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::VariantRecord::GeneratedRelationMethods
  def with_attached_image(*arg, **arg1, &arg2); end
end

module ActiveStorage::VariantRecord::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::VariantWithRecord
  def blob(); end

  def download(*arg, **arg1, &arg2); end

  def image(); end

  def initialize(blob, variation); end

  def key(*arg, **arg1, &arg2); end

  def process(); end

  def processed(); end

  def processed?(); end

  def service(*arg, **arg1, &arg2); end

  def url(*arg, **arg1, &arg2); end

  def variation(); end
end

class ActiveStorage::VariantWithRecord
end

class ActiveStorage::Variation
  def content_type(); end

  def default_to(defaults); end

  def digest(); end

  def format(); end

  def initialize(transformations); end

  def key(); end

  def transform(file, &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  def self.analyzers(); end

  def self.analyzers=(val); end

  def self.binary_content_type(); end

  def self.binary_content_type=(val); end

  def self.content_types_allowed_inline(); end

  def self.content_types_allowed_inline=(val); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(val); end

  def self.draw_routes(); end

  def self.draw_routes=(val); end

  def self.logger(); end

  def self.logger=(val); end

  def self.paths(); end

  def self.paths=(val); end

  def self.previewers(); end

  def self.previewers=(val); end

  def self.queues(); end

  def self.queues=(val); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.replace_on_assign_to_many(); end

  def self.replace_on_assign_to_many=(val); end

  def self.resolve_model_to_route(); end

  def self.resolve_model_to_route=(val); end

  def self.routes_prefix(); end

  def self.routes_prefix=(val); end

  def self.service_urls_expire_in(); end

  def self.service_urls_expire_in=(val); end

  def self.silence_invalid_content_types_warning(); end

  def self.silence_invalid_content_types_warning=(val); end

  def self.supported_image_processing_methods(); end

  def self.supported_image_processing_methods=(val); end

  def self.table_name_prefix(); end

  def self.track_variants(); end

  def self.track_variants=(val); end

  def self.unsupported_image_processing_arguments(); end

  def self.unsupported_image_processing_arguments=(val); end

  def self.urls_expire_in(); end

  def self.urls_expire_in=(val); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(val); end

  def self.variant_processor(); end

  def self.variant_processor=(val); end

  def self.verifier(); end

  def self.verifier=(val); end

  def self.video_preview_arguments(); end

  def self.video_preview_arguments=(val); end

  def self.web_image_content_types(); end

  def self.web_image_content_types=(val); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Coders
  MARK_61 = ::T.let(nil, ::T.untyped)
  MARK_70_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_70_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::ConnectionPoolLike
  def with(); end
end

module ActiveSupport::Cache::ConnectionPoolLike
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, **options); end
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def initialize(namespace: T.unsafe(nil), compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), coder: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def mget_capable?(); end

  def mset_capable?(); end

  def redis(); end

  def redis_options(); end

  def stats(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end

  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(**options); end

  def clear(**options); end

  def decrement(name, amount=T.unsafe(nil), **options); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), **options); end

  def middleware(); end

  def with_local_cache(&block); end
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def define_cached_method(name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

module ActiveSupport::CompareWithRange
  def ===(value); end

  def include?(value); end
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
  def synchronize(&block); end
end

module ActiveSupport::Configurable
  def config(); end
end

class ActiveSupport::CurrentAttributes
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*arg, **arg1, &arg2); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*arg, **arg1, &arg2); end
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnvironmentInquirer
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ErrorReporter
  def handle(error_class=T.unsafe(nil), severity: T.unsafe(nil), context: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def initialize(*subscribers, logger: T.unsafe(nil)); end

  def logger(); end

  def logger=(logger); end

  def record(error_class=T.unsafe(nil), severity: T.unsafe(nil), context: T.unsafe(nil)); end

  def report(error, handled:, severity: T.unsafe(nil), context: T.unsafe(nil)); end

  def set_context(*arg, **arg1, &arg2); end

  def subscribe(subscriber); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::Core
  def changed(modified, added, removed); end

  def common_path(paths); end

  def directories_to_watch(); end

  def finalizer(); end

  def initialize(files, dirs); end

  def normalize_dirs!(); end

  def restart(); end

  def restart?(); end

  def start(); end

  def stop(); end

  def thread_safely(); end

  def updated(); end

  def watching?(file); end
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete(); end

  def complete!(); end

  def run(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active?(); end

  def self.active_key(); end

  def self.error_reporter(); end

  def self.perform(); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(reset: T.unsafe(nil)); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

module ActiveSupport::Executor::TestHelper
  def run(*arg, **arg1, &arg2); end
end

module ActiveSupport::ForkTracker::CoreExt
  def fork(*arg, **arg1, &arg2); end
end

module ActiveSupport::ForkTracker::ModernCoreExt
  def _fork(); end
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.check!(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Chars
  def =~(*arg, **arg1, &arg2); end

  def acts_like_string?(*arg, **arg1, &arg2); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*arg, **arg1, &arg2); end

  def method_missing(method, *args, &block); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

module ActiveSupport::NumericWithFormat
  def to_formatted_s(format=T.unsafe(nil), options=T.unsafe(nil)); end

  def to_fs(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::ParameterFilter
  def filter(params); end

  def filter_param(key, value); end

  def initialize(filters=T.unsafe(nil), mask: T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(params, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks, mask:); end

  def regexps(); end

  def value_for_key(key, value, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def self.compile(filters, mask:); end
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

module ActiveSupport::RangeWithFormat
  def to_formatted_s(format=T.unsafe(nil)); end

  def to_fs(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(check); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(executor); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(value); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(value); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::RubyFeatures
  CLASS_SUBCLASSES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  include ::ActiveSupport::Messages::Rotator
  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def publish_event(event); end

  def start(name, id, payload); end
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*arg, **arg1, &arg2); end

  def flush(); end

  def pop_tags(*arg, **arg1, &arg2); end

  def push_tags(*arg, **arg1, &arg2); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def current_tags(); end

  def current_tags=(current_tags); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def self.extended(base); end
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::Shoulda::Matchers::ActiveModel
  include ::Shoulda::Matchers::ActiveRecord
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def dom_class(*arg, **arg1, &arg2); end

  def dom_id(*arg, **arg1, &arg2); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  extend ::Shoulda::Matchers::ActiveModel
  extend ::Shoulda::Matchers::ActiveRecord
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::Isolation
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork_hooks(); end

  def initialize(worker_count); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  def <<(o); end

  def active_workers?(); end

  def interrupt(); end

  def pop(); end

  def record(reporter, result); end

  def shutdown(); end

  def start_worker(worker_id); end

  def stop_worker(worker_id); end
end

class ActiveSupport::Testing::Parallelization::Worker
  def after_fork(); end

  def initialize(number, url); end

  def perform_job(job); end

  def run_cleanup(); end

  def safe_record(reporter, result); end

  def start(); end

  def work_from_queue(); end
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

class ActiveSupport::Testing::ParallelizeExecutor
  def <<(work); end

  def initialize(size:, with:, threshold: T.unsafe(nil)); end

  def parallelize_with(); end

  def shutdown(); end

  def size(); end

  def start(); end

  def threshold(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbed?(); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  NOT_SET = ::T.let(nil, ::T.untyped)
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport
  def self.escape_html_entities_in_json(*arg, **arg1, &arg2); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*arg, **arg1, &arg2); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.time_precision(*arg, **arg1, &arg2); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*arg, **arg1, &arg2); end

  def self.use_standard_json_time_format=(arg); end
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::Template
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::NormalizeCharacterClasses
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module AnnotateModels::FilePatterns
  ACTIVEADMIN_DIR = ::T.let(nil, ::T.untyped)
  BLUEPRINTS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  BLUEPRINTS_TEST_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_SPEC_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_TEST_DIR = ::T.let(nil, ::T.untyped)
  EXEMPLARS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  EXEMPLARS_TEST_DIR = ::T.let(nil, ::T.untyped)
  FABRICATORS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FABRICATORS_TEST_DIR = ::T.let(nil, ::T.untyped)
  FACTORY_BOT_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FACTORY_BOT_TEST_DIR = ::T.let(nil, ::T.untyped)
  FIXTURE_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FIXTURE_TEST_DIR = ::T.let(nil, ::T.untyped)
  HELPER_DIR = ::T.let(nil, ::T.untyped)
  MODEL_TEST_DIR = ::T.let(nil, ::T.untyped)
  REQUEST_SPEC_DIR = ::T.let(nil, ::T.untyped)
  ROUTING_SPEC_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_TEST_DIR = ::T.let(nil, ::T.untyped)
  SPEC_MODEL_DIR = ::T.let(nil, ::T.untyped)
  UNIT_TEST_DIR = ::T.let(nil, ::T.untyped)
end

class AnnotateRoutes::HeaderGenerator
  HEADER_ROW = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  PREFIX_MD = ::T.let(nil, ::T.untyped)
end

class ApplicationController
  include ::GeneratedUrlHelpers
  include ::Pagy::CountlessExtra
end

module ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::ApplicationHelper
  include ::Pagy::Frontend
  include ::Pagy::UrlHelpers
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
  include ::PreviewHelper
  include ::DeviseHelper
end

module ApplicationController::HelperMethods
end

module ApplicationHelper
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  RelationType = ::T.let(nil, ::T.untyped)
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
end

class ApplicationRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Relation
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ApplicationRecord::GeneratedRelationMethods
end

module ApplicationRecord::GeneratedRelationMethods
  extend ::Mutex_m
end

class ApplicationRecord
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end

  def type_caster(); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil), &block); end

  def initialize(left, right); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil), &block); end

  def initialize(*arg); end

  def preparable(); end

  def preparable=(preparable); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def initialize(quoter, delegate_collector); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
end

module Arel::Crud
  def compile_delete(key=T.unsafe(nil), having_clause=T.unsafe(nil), group_values_columns=T.unsafe(nil)); end

  def compile_insert(values); end

  def compile_update(values, key=T.unsafe(nil), having_clause=T.unsafe(nil), group_values_columns=T.unsafe(nil)); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  include ::Arel::TreeManager::StatementMethods
  def from(relation); end

  def group(columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def coalesce(*exprs); end

  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

module Arel::FilterPredications
  def filter(expr); end
end

module Arel::FilterPredications
end

class Arel::InsertManager
  def columns(); end

  def create_values(values); end

  def create_values_list(rows); end

  def initialize(table=T.unsafe(nil)); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
end

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def infinite?(); end

  def initialize(value); end

  def unboundable?(); end

  def value(); end

  def value_before_type_cast(); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  def ==(other); end

  def case(); end

  def case=(arg); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(value, attribute); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(values); end

  def values(); end
end

class Arel::Nodes::Comment
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Contains
  def initialize(left, right); end
end

class Arel::Nodes::Contains
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def ==(other); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

module Arel::Nodes::FetchAttribute
  def fetch_attribute(); end
end

module Arel::Nodes::FetchAttribute
end

class Arel::Nodes::Filter
  include ::Arel::WindowPredications
end

class Arel::Nodes::Filter
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  include ::Arel::FilterPredications
  def ==(other); end

  def alias(); end

  def alias=(arg); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
  def fetch_attribute(&block); end
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::HomogeneousIn
  def ==(other); end

  def attribute(); end

  def casted_values(); end

  def column_name(); end

  def eql?(other); end

  def fetch_attribute(&block); end

  def initialize(values, attribute, type); end

  def ivars(); end

  def left(); end

  def proc_for_binds(); end

  def right(); end

  def table_name(); end

  def type(); end

  def values(); end
end

class Arel::Nodes::HomogeneousIn
end

class Arel::Nodes::In
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil)); end

  def relation(); end

  def relation=(relation); end

  def select(); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LeadingJoin
end

class Arel::Nodes::LeadingJoin
end

class Arel::Nodes::LessThan
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  def and(right); end

  def equality?(); end

  def fetch_attribute(); end

  def invert(); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::NodeExpression
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::NodeExpression
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NullsFirst
  def reverse(); end
end

class Arel::Nodes::NullsFirst
end

class Arel::Nodes::NullsLast
  def reverse(); end
end

class Arel::Nodes::NullsLast
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
  def fetch_attribute(&block); end
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
  def nulls_first(); end

  def nulls_last(); end
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Overlaps
  def initialize(left, right); end
end

class Arel::Nodes::Overlaps
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def infinite?(); end

  def value_before_type_cast(); end

  def value_for_database(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def comment(); end

  def comment=(comment); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def initialize(relation=T.unsafe(nil)); end

  def optimizer_hints(); end

  def optimizer_hints=(optimizer_hints); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end

  def fetch_attribute(); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(name); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def initialize(relation=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::ValuesList
  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def contains(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def is_distinct_from(other); end

  def is_not_distinct_from(other); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def overlaps(other); end

  def quoted_array(others); end

  def when(right); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def comment(*values); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def lateral(table_name=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def optimizer_hints(*hints); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where(expr); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::FactoryMethods
  include ::Arel::AliasPredication
  def ==(other); end

  def [](name, table=T.unsafe(nil)); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), klass: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(name); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end
end

module Arel::TreeManager::StatementMethods
  def key(); end

  def key=(key); end

  def offset(offset); end

  def order(*expr); end

  def take(limit); end

  def where(expr); end

  def wheres=(exprs); end
end

module Arel::TreeManager::StatementMethods
end

class Arel::TreeManager
end

class Arel::UpdateManager
  include ::Arel::TreeManager::StatementMethods
  def group(columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def set(values); end

  def table(table); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object, collector=T.unsafe(nil)); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Arel::Visitors
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value, &block); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::FriendlyId::UnfriendlyUtils
  def abbrev(pattern=T.unsafe(nil)); end

  def deconstruct(); end

  def intersect?(arg); end

  def place(*values); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  DEFAULT_COST = ::T.let(nil, ::T.untyped)
  MAX_COST = ::T.let(nil, ::T.untyped)
  MAX_SALT_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_SECRET_BYTESIZE = ::T.let(nil, ::T.untyped)
  MIN_COST = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  def self.autodetect_cost(salt); end

  def self.calibrate(upper_time_limit_in_ms); end

  def self.cost(); end

  def self.cost=(cost); end

  def self.generate_salt(cost=T.unsafe(nil)); end

  def self.hash_secret(secret, salt, _=T.unsafe(nil)); end

  def self.valid_salt?(salt); end

  def self.valid_secret?(secret); end
end

class BCrypt::Password
  def ==(secret); end

  def checksum(); end

  def cost(); end

  def initialize(raw_hash); end

  def is_password?(secret); end

  def salt(); end

  def version(); end
end

class BCrypt::Password
  def self.create(secret, options=T.unsafe(nil)); end

  def self.valid_hash?(h); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end

  def to_h(); end
end

module BetterErrors
  VERSION = ::T.let(nil, ::T.untyped)
end

class BetterErrors::CodeFormatter
  FILE_TYPES = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Editor
  KNOWN_EDITORS = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Middleware
  ALLOWED_IPS = ::T.let(nil, ::T.untyped)
  CSRF_TOKEN_COOKIE_NAME = ::T.let(nil, ::T.untyped)
end

module BetterErrors::REPL
  PROVIDERS = ::T.let(nil, ::T.untyped)
end

module BetterHtml
  VERSION = ::T.let(nil, ::T.untyped)
end

class BetterHtml::AST::Iterator
  def initialize(types, &block); end

  def traverse(node); end

  def traverse_all(nodes); end
end

class BetterHtml::AST::Iterator
  def self.descendants(root_node, type); end
end

class BetterHtml::AST::Node
  def descendants(*types); end

  def loc(); end

  def location(); end
end

class BetterHtml::BetterErb
  def content_types(); end

  def content_types=(val); end
end

module BetterHtml::BetterErb::ConditionalImplementation
  def call(template, source=T.unsafe(nil)); end
end

class BetterHtml::BetterErb::ErubiImplementation
end

module BetterHtml::BetterErb::RuntimeChecks
  def initialize(erb, config: T.unsafe(nil), **options); end

  def validate!(); end
end

class BetterHtml::BetterErb::ValidatedOutputBuffer
  def html_safe(); end
end

class BetterHtml::BetterErb::ValidatedOutputBuffer::Context
  def initialize(output, context, code, auto_escape); end

  def safe_after_attribute_name_append=(value); end

  def safe_after_equal_append=(value); end

  def safe_attribute_name_append=(value); end

  def safe_comment_append=(value); end

  def safe_none_append=(value); end

  def safe_quoted_value_append=(value); end

  def safe_rawtext_append=(value); end

  def safe_space_after_attribute_append=(value); end

  def safe_tag_append=(value); end

  def safe_tag_name_append=(value); end

  def safe_unquoted_value_append=(value); end
end

class BetterHtml::BetterErb::ValidatedOutputBuffer
  def self.wrap(output, context, code, auto_escape); end
end

class BetterHtml::BetterErb
  def self.content_types(); end

  def self.content_types=(val); end

  def self.prepend!(); end
end

class BetterHtml::Config
  def javascript_attribute_name?(name); end

  def javascript_safe_method?(name); end

  def lodash_safe_javascript_expression?(code); end
end

class BetterHtml::Errors
  def add(arg); end
end

module BetterHtml::Helpers
  def html_attributes(args); end
end

class BetterHtml::HtmlAttributes
  def initialize(data); end
end

class BetterHtml::Parser
  def ast(); end

  def initialize(buffer, template_language: T.unsafe(nil)); end

  def nodes_with_type(*type); end

  def parser_errors(); end

  def template_language(); end
  INTERPOLATION_TYPES = ::T.let(nil, ::T.untyped)
end

class BetterHtml::Parser::Error
  def initialize(message, location:); end

  def loc(); end

  def location(); end
end

class BetterHtml::Tokenizer::BaseErb
  def current_position(); end

  def initialize(buffer); end

  def tokens(); end
  EXPR_TRIM_MATCHER = ::T.let(nil, ::T.untyped)
  REGEXP_WITHOUT_TRIM = ::T.let(nil, ::T.untyped)
  STMT_TRIM_MATCHER = ::T.let(nil, ::T.untyped)
end

class BetterHtml::Tokenizer::HtmlErb
  def parser(); end
end

class BetterHtml::Tokenizer::HtmlLodash
  def initialize(buffer); end

  def lodash_escape(); end

  def lodash_escape=(val); end

  def lodash_evaluate(); end

  def lodash_evaluate=(val); end

  def lodash_interpolate(); end

  def lodash_interpolate=(val); end

  def parser(); end

  def tokens(); end
end

class BetterHtml::Tokenizer::HtmlLodash
  def self.lodash_escape(); end

  def self.lodash_escape=(val); end

  def self.lodash_evaluate(); end

  def self.lodash_evaluate=(val); end

  def self.lodash_interpolate(); end

  def self.lodash_interpolate=(val); end
end

class BetterHtml::Tokenizer::Location
  def initialize(buffer, begin_pos, end_pos); end

  def line_range(); end

  def line_source_with_underline(); end

  def offset(offset); end

  def range(); end

  def start_column(); end

  def start_line(); end

  def stop_column(); end

  def stop_line(); end
end

class BetterHtml::Tokenizer::Token
  def initialize(type:, loc:); end

  def loc(); end

  def type(); end
end

class BetterHtml::Tokenizer::TokenArray
  def any?(); end

  def current(); end

  def empty?(); end

  def initialize(list); end

  def last(); end

  def pop(); end

  def shift(); end

  def size(); end

  def trim(type); end
end

module BetterHtml
  def self.config(); end

  def self.config=(new_config); end

  def self.configure(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

Bindex = Skiptrace

class Binding
  def b(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def break(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def clone(); end

  def console(); end

  def irb(); end
end

module BindingOfCaller
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bootsnap
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache
  UNCOMPILABLE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache::YAML
  SUPPORTED_INTERNAL_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  FALLBACK_SCAN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Store
  CURRENT_VERSION = ::T.let(nil, ::T.untyped)
  VERSION_KEY = ::T.let(nil, ::T.untyped)
end

module Brakeman
  CONFIG_FILES = ::T.let(nil, ::T.untyped)
  Empty_Ignore_Note_Exit_Code = ::T.let(nil, ::T.untyped)
  Errors_Found_Exit_Code = ::T.let(nil, ::T.untyped)
  Missing_Checks_Exit_Code = ::T.let(nil, ::T.untyped)
  No_App_Found_Exit_Code = ::T.let(nil, ::T.untyped)
  Not_Latest_Version_Exit_Code = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
  Warnings_Found_Exit_Code = ::T.let(nil, ::T.untyped)
end

module Bullet::ActiveJob
end

module Bullet::ActiveJob
  def self.included(base); end
end

module Bullet::ActiveRecord
  def self.enable(); end
end

module Bullet::Notification
end

class Bullet::Notification::Base
  def associations(); end

  def associations_str(); end

  def base_class(); end

  def body(); end

  def body_with_caller(); end

  def call_stack_messages(); end

  def eql?(other); end

  def initialize(base_class, association_or_associations, path=T.unsafe(nil)); end

  def klazz_associations_str(); end

  def notification_data(); end

  def notifier(); end

  def notifier=(notifier); end

  def notify_inline(); end

  def notify_out_of_channel(); end

  def path(); end

  def short_notice(); end

  def title(); end

  def url(); end

  def url=(url); end

  def whoami(); end
end

class Bullet::Notification::Base
end

class Bullet::Notification::CounterCache
end

class Bullet::Notification::CounterCache
end

class Bullet::Notification::NPlusOneQuery
  def initialize(callers, base_class, associations, path=T.unsafe(nil)); end
end

class Bullet::Notification::NPlusOneQuery
end

class Bullet::Notification::UnoptimizedQueryError
end

class Bullet::Notification::UnoptimizedQueryError
end

class Bullet::Notification::UnusedEagerLoading
  def initialize(callers, base_class, associations, path=T.unsafe(nil)); end
end

class Bullet::Notification::UnusedEagerLoading
end

module Bullet::Notification
end

class Bullet::NotificationCollector
  def add(value); end

  def collection(); end

  def notifications_present?(); end

  def reset(); end
end

class Bullet::NotificationCollector
end

class Bullet::Rack
  def append_to_html_body(response_body, content); end

  def call(env); end

  def empty?(response); end

  def file?(headers); end

  def footer_note(); end

  def html_request?(headers, response); end

  def initialize(app); end

  def response_body(response); end

  def set_header(headers, header_name, header_array); end

  def sse?(headers); end
end

module Bullet::Registry
end

class Bullet::Registry::Association
  def merge(base, associations); end

  def similarly_associated(base, associations); end
end

class Bullet::Registry::Association
end

class Bullet::Registry::Base
  def [](key); end

  def add(key, value); end

  def delete(base); end

  def each(&block); end

  def include?(key, value); end

  def registry(); end

  def select(*args, &block); end
end

class Bullet::Registry::Base
end

class Bullet::Registry::Object
  def add(bullet_key); end

  def include?(bullet_key); end
end

class Bullet::Registry::Object
end

module Bullet::Registry
end

module Bullet::SaveWithBulletSupport
  def _create_record(*arg); end
end

module Bullet::StackTraceFilter
  IS_RUBY_19 = ::T.let(nil, ::T.untyped)
  VENDOR_PATH = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::Audit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::Audit::Database
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  USER_PATH = ::T.let(nil, ::T.untyped)
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end

  def github(); end

  def ref(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::Dsl
  def check_primary_source_safety(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::RemoteSpecification
  def required_rubygems_version(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def missing_specs(); end
end

class Bundler::StubSpecification
  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BreakCommand
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(arg, arg1, arg2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CatchCommand
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, **arg, &block); end

  def context(); end

  def errmsg(*args, **arg, &block); end

  def frame(); end

  def help(*args, **arg, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, **arg, &block); end

  def pr(*args, **arg, &block); end

  def prc(*args, **arg, &block); end

  def print(*args, **arg, &block); end

  def processor(); end

  def prv(*args, **arg, &block); end

  def puts(*args, **arg, &block); end
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandProcessor
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, **arg, &block); end

  def confirm(*args, **arg, &block); end

  def context(); end

  def errmsg(*args, **arg, &block); end

  def frame(*args, **arg, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, **arg, &block); end

  def prc(*args, **arg, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, **arg, &block); end

  def puts(*args, **arg, &block); end

  def repl(); end
end

class Byebug::ConditionCommand
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, **arg, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*arg); end

  def frame_class(*arg); end

  def frame_file(*arg); end

  def frame_line(*arg); end

  def frame_method(*arg); end

  def frame_self(*arg); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, **arg, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*arg); end

  def step_out(*arg); end

  def step_over(*arg); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::DebugCommand
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::FrameCommand
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ToggleHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::VarHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::HistoryCommand
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::ListCommand
  def amend_final(*args, **arg, &block); end

  def execute(); end

  def max_line(*args, **arg, &block); end

  def size(*args, **arg, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::MethodCommand
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RestartCommand
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::SetCommand
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StepCommand
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, **arg, &block); end
end

module Byebug::Subcommands::ClassMethods
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands
  def self.included(command); end
end

class Byebug::ThreadCommand::CurrentCommand
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::AllCommand
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Byebug
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class CLAide::ANSI
  COLORS = ::T.let(nil, ::T.untyped)
  DEFAULT_BACKGROUND_COLOR = ::T.let(nil, ::T.untyped)
  DEFAULT_FOREGROUND_COLOR = ::T.let(nil, ::T.untyped)
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
  TEXT_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  TEXT_DISABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class CLAide::Argument
  ELLIPSIS = ::T.let(nil, ::T.untyped)
end

class CLAide::Command
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_ROOT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class CLAide::Command::Banner
  DESCRIPTION_SPACES = ::T.let(nil, ::T.untyped)
  MAX_WIDTH = ::T.let(nil, ::T.untyped)
  SUBCOMMAND_BULLET_SIZE = ::T.let(nil, ::T.untyped)
  TEXT_INDENT = ::T.let(nil, ::T.untyped)
end

class CSV
  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def external_encoding(*args, **arg, &block); end

  def fcntl(*args, **arg, &block); end

  def fileno(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def fsync(*args, **arg, &block); end

  def internal_encoding(*args, **arg, &block); end

  def isatty(*args, **arg, &block); end

  def pid(*args, **arg, &block); end

  def pos(*args, **arg, &block); end

  def pos=(*args, **arg, &block); end

  def reopen(*args, **arg, &block); end

  def seek(*args, **arg, &block); end

  def string(*args, **arg, &block); end

  def sync(*args, **arg, &block); end

  def sync=(*args, **arg, &block); end

  def tell(*args, **arg, &block); end

  def truncate(*args, **arg, &block); end

  def tty?(*args, **arg, &block); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

module CSV::InputRecordSeparator
end

module CSV::InputRecordSeparator
  def self.value(); end
end

class CSV::MalformedCSVError
  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
  STRING_SCANNER_SCAN_ACCEPT_STRING = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, row_separator, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(arg); end
end

class CSV::Parser::Scanner
end

class CSV::Parser
end

class CSV::Row
  def dig(index_or_header, *indexes); end

  def each_pair(&block); end

  def empty?(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def to_ary(*arg); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def table(); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Ambiguous
end

class Capybara::Ambiguous
end

class Capybara::CapybaraError
end

class Capybara::CapybaraError
end

class Capybara::Config
  def allow_gumbo(); end

  def allow_gumbo=(val); end

  def always_include_port(*args, **arg, &block); end

  def always_include_port=(*args, **arg, &block); end

  def app(); end

  def app=(app); end

  def app_host(*args, **arg, &block); end

  def app_host=(*args, **arg, &block); end

  def asset_host(*args, **arg, &block); end

  def asset_host=(*args, **arg, &block); end

  def automatic_label_click(*args, **arg, &block); end

  def automatic_label_click=(*args, **arg, &block); end

  def automatic_reload(*args, **arg, &block); end

  def automatic_reload=(*args, **arg, &block); end

  def default_driver(); end

  def default_driver=(default_driver); end

  def default_host(*args, **arg, &block); end

  def default_host=(*args, **arg, &block); end

  def default_max_wait_time(*args, **arg, &block); end

  def default_max_wait_time=(*args, **arg, &block); end

  def default_normalize_ws(*args, **arg, &block); end

  def default_normalize_ws=(*args, **arg, &block); end

  def default_selector(*args, **arg, &block); end

  def default_selector=(*args, **arg, &block); end

  def default_set_options(*args, **arg, &block); end

  def default_set_options=(*args, **arg, &block); end

  def deprecate(method, alternate_method, once: T.unsafe(nil)); end

  def disable_animation(*args, **arg, &block); end

  def disable_animation=(*args, **arg, &block); end

  def enable_aria_label(*args, **arg, &block); end

  def enable_aria_label=(*args, **arg, &block); end

  def enable_aria_role(*args, **arg, &block); end

  def enable_aria_role=(*args, **arg, &block); end

  def exact(*args, **arg, &block); end

  def exact=(*args, **arg, &block); end

  def exact_text(*args, **arg, &block); end

  def exact_text=(*args, **arg, &block); end

  def ignore_hidden_elements(*args, **arg, &block); end

  def ignore_hidden_elements=(*args, **arg, &block); end

  def javascript_driver(); end

  def javascript_driver=(javascript_driver); end

  def match(*args, **arg, &block); end

  def match=(*args, **arg, &block); end

  def predicates_wait(*args, **arg, &block); end

  def predicates_wait=(*args, **arg, &block); end

  def raise_server_errors(*args, **arg, &block); end

  def raise_server_errors=(*args, **arg, &block); end

  def reuse_server(); end

  def reuse_server=(reuse_server); end

  def run_server(*args, **arg, &block); end

  def run_server=(*args, **arg, &block); end

  def save_path(*args, **arg, &block); end

  def save_path=(*args, **arg, &block); end

  def server(); end

  def server=(name); end

  def server_errors(*args, **arg, &block); end

  def server_errors=(*args, **arg, &block); end

  def server_host(*args, **arg, &block); end

  def server_host=(*args, **arg, &block); end

  def server_port(*args, **arg, &block); end

  def server_port=(*args, **arg, &block); end

  def session_options(); end

  def test_id(*args, **arg, &block); end

  def test_id=(*args, **arg, &block); end

  def threadsafe(); end

  def threadsafe=(bool); end

  def use_html5_parsing(); end

  def use_html5_parsing=(use_html5_parsing); end

  def visible_text_only(*args, **arg, &block); end

  def visible_text_only=(*args, **arg, &block); end

  def w3c_click_offset(*args, **arg, &block); end

  def w3c_click_offset=(*args, **arg, &block); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  extend ::Forwardable
end

module Capybara::DSL
  include ::Capybara::DSLRSpecProxyInstaller
  def accept_alert(*arg, **arg1, &arg2); end

  def accept_confirm(*arg, **arg1, &arg2); end

  def accept_prompt(*arg, **arg1, &arg2); end

  def all(*arg, **arg1, &arg2); end

  def assert_all_of_selectors(*arg, **arg1, &arg2); end

  def assert_any_of_selectors(*arg, **arg1, &arg2); end

  def assert_current_path(*arg, **arg1, &arg2); end

  def assert_no_current_path(*arg, **arg1, &arg2); end

  def assert_no_selector(*arg, **arg1, &arg2); end

  def assert_no_text(*arg, **arg1, &arg2); end

  def assert_no_title(*arg, **arg1, &arg2); end

  def assert_none_of_selectors(*arg, **arg1, &arg2); end

  def assert_selector(*arg, **arg1, &arg2); end

  def assert_text(*arg, **arg1, &arg2); end

  def assert_title(*arg, **arg1, &arg2); end

  def attach_file(*arg, **arg1, &arg2); end

  def body(*arg, **arg1, &arg2); end

  def check(*arg, **arg1, &arg2); end

  def choose(*arg, **arg1, &arg2); end

  def click_button(*arg, **arg1, &arg2); end

  def click_link(*arg, **arg1, &arg2); end

  def click_link_or_button(*arg, **arg1, &arg2); end

  def click_on(*arg, **arg1, &arg2); end

  def current_host(*arg, **arg1, &arg2); end

  def current_path(*arg, **arg1, &arg2); end

  def current_scope(*arg, **arg1, &arg2); end

  def current_url(*arg, **arg1, &arg2); end

  def current_window(*arg, **arg1, &arg2); end

  def dismiss_confirm(*arg, **arg1, &arg2); end

  def dismiss_prompt(*arg, **arg1, &arg2); end

  def evaluate_script(*arg, **arg1, &arg2); end

  def execute_script(*arg, **arg1, &arg2); end

  def fill_in(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_button(*arg, **arg1, &arg2); end

  def find_by_id(*arg, **arg1, &arg2); end

  def find_field(*arg, **arg1, &arg2); end

  def find_link(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def go_back(*arg, **arg1, &arg2); end

  def go_forward(*arg, **arg1, &arg2); end

  def has_button?(*arg, **arg1, &arg2); end

  def has_checked_field?(*arg, **arg1, &arg2); end

  def has_content?(*arg, **arg1, &arg2); end

  def has_css?(*arg, **arg1, &arg2); end

  def has_current_path?(*arg, **arg1, &arg2); end

  def has_field?(*arg, **arg1, &arg2); end

  def has_link?(*arg, **arg1, &arg2); end

  def has_no_button?(*arg, **arg1, &arg2); end

  def has_no_checked_field?(*arg, **arg1, &arg2); end

  def has_no_content?(*arg, **arg1, &arg2); end

  def has_no_css?(*arg, **arg1, &arg2); end

  def has_no_current_path?(*arg, **arg1, &arg2); end

  def has_no_field?(*arg, **arg1, &arg2); end

  def has_no_link?(*arg, **arg1, &arg2); end

  def has_no_select?(*arg, **arg1, &arg2); end

  def has_no_selector?(*arg, **arg1, &arg2); end

  def has_no_table?(*arg, **arg1, &arg2); end

  def has_no_text?(*arg, **arg1, &arg2); end

  def has_no_title?(*arg, **arg1, &arg2); end

  def has_no_unchecked_field?(*arg, **arg1, &arg2); end

  def has_no_xpath?(*arg, **arg1, &arg2); end

  def has_select?(*arg, **arg1, &arg2); end

  def has_selector?(*arg, **arg1, &arg2); end

  def has_table?(*arg, **arg1, &arg2); end

  def has_text?(*arg, **arg1, &arg2); end

  def has_title?(*arg, **arg1, &arg2); end

  def has_unchecked_field?(*arg, **arg1, &arg2); end

  def has_xpath?(*arg, **arg1, &arg2); end

  def html(*arg, **arg1, &arg2); end

  def open_new_window(*arg, **arg1, &arg2); end

  def page(); end

  def query(*arg, **arg1, &arg2); end

  def refresh(*arg, **arg1, &arg2); end

  def refute_selector(*arg, **arg1, &arg2); end

  def reset_session!(*arg, **arg1, &arg2); end

  def response_headers(*arg, **arg1, &arg2); end

  def save_and_open_page(*arg, **arg1, &arg2); end

  def save_and_open_screenshot(*arg, **arg1, &arg2); end

  def save_page(*arg, **arg1, &arg2); end

  def save_screenshot(*arg, **arg1, &arg2); end

  def screenshot_and_open_image(); end

  def screenshot_and_save_page(); end

  def scroll_by(*arg, **arg1, &arg2); end

  def scroll_to(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def send_keys(*arg, **arg1, &arg2); end

  def source(*arg, **arg1, &arg2); end

  def status_code(*arg, **arg1, &arg2); end

  def switch_to_frame(*arg, **arg1, &arg2); end

  def switch_to_window(*arg, **arg1, &arg2); end

  def text(*arg, **arg1, &arg2); end

  def title(*arg, **arg1, &arg2); end

  def uncheck(*arg, **arg1, &arg2); end

  def unselect(*arg, **arg1, &arg2); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*arg, **arg1, &arg2); end

  def window_opened_by(*arg, **arg1, &arg2); end

  def windows(*arg, **arg1, &arg2); end

  def within(*arg, **arg1, &arg2); end

  def within_element(*arg, **arg1, &arg2); end

  def within_fieldset(*arg, **arg1, &arg2); end

  def within_frame(*arg, **arg1, &arg2); end

  def within_table(*arg, **arg1, &arg2); end

  def within_window(*arg, **arg1, &arg2); end
end

module Capybara::DSL
  def self.extended(base); end
end

module Capybara::DSLRSpecProxyInstaller
end

module Capybara::DSLRSpecProxyInstaller
  def self.prepended(base); end
end

module Capybara::Driver
end

class Capybara::Driver::Base
  def accept_modal(type, **options, &blk); end

  def active_element(); end

  def close_window(handle); end

  def current_url(); end

  def current_window_handle(); end

  def dismiss_modal(type, **options, &blk); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def find_css(query, **options); end

  def find_xpath(query, **options); end

  def frame_title(); end

  def frame_url(); end

  def fullscreen_window(handle); end

  def go_back(); end

  def go_forward(); end

  def html(); end

  def invalid_element_errors(); end

  def maximize_window(handle); end

  def needs_server?(); end

  def no_such_window_error(); end

  def open_new_window(); end

  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def response_headers(); end

  def save_screenshot(path, **options); end

  def send_keys(*arg); end

  def session=(session); end

  def session_options(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(handle); end

  def visit(path); end

  def wait?(); end

  def window_handles(); end

  def window_size(handle); end
end

class Capybara::Driver::Base
end

class Capybara::Driver::Node
  def ==(other); end

  def [](name); end

  def all_text(); end

  def checked?(); end

  def click(keys=T.unsafe(nil), **options); end

  def disabled?(); end

  def double_click(keys=T.unsafe(nil), **options); end

  def drag_to(element, **options); end

  def driver(); end

  def drop(*args); end

  def hover(); end

  def initial_cache(); end

  def initialize(driver, native, initial_cache=T.unsafe(nil)); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(keys=T.unsafe(nil), **options); end

  def scroll_by(x, y); end

  def scroll_to(element, alignment, position=T.unsafe(nil)); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(styles); end

  def tag_name(); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end

  def visible_text(); end
end

class Capybara::Driver::Node
end

module Capybara::Driver
end

class Capybara::DriverNotFoundError
end

class Capybara::DriverNotFoundError
end

class Capybara::ElementNotFound
end

class Capybara::ElementNotFound
end

class Capybara::ExpectationNotMet
end

class Capybara::ExpectationNotMet
end

class Capybara::FileNotFound
end

class Capybara::FileNotFound
end

class Capybara::FrozenInTime
end

class Capybara::FrozenInTime
end

module Capybara::Helpers
end

class Capybara::Helpers::Timer
  def expired?(); end

  def initialize(expire_in); end

  def stalled?(); end
end

class Capybara::Helpers::Timer
end

module Capybara::Helpers
  def self.declension(singular, plural, count); end

  def self.filter_backtrace(trace); end

  def self.inject_asset_host(html, host: T.unsafe(nil)); end

  def self.monotonic_time(); end

  def self.normalize_whitespace(text); end

  def self.timer(expire_in:); end

  def self.to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.warn(message, uplevel: T.unsafe(nil)); end
end

class Capybara::InfiniteRedirectError
end

class Capybara::InfiniteRedirectError
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args, **kwargs, &optional_filter_block); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args, **kwargs, &optional_filter_block); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args, **kwargs, &optional_filter_block); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args, **kwargs, &optional_filter_block); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args, **kwargs, &optional_filter_block); end

  def assert_no_title(*args, **kwargs, &optional_filter_block); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args, **kwargs, &optional_filter_block); end

  def assert_title(*args, **kwargs, &optional_filter_block); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_ancestor(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args, **kwargs, &optional_filter_block); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args, **kwargs, &optional_filter_block); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_sibling(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args, **kwargs, &optional_filter_block); end

  def refute_title(*args, **kwargs, &optional_filter_block); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
end

module Capybara::Minitest
end

class Capybara::ModalNotFound
end

class Capybara::ModalNotFound
end

module Capybara::Node
end

module Capybara::Node::Actions
  def attach_file(locator=T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  def check(locator=T.unsafe(nil), **options); end

  def choose(locator=T.unsafe(nil), **options); end

  def click_button(locator=T.unsafe(nil), **options); end

  def click_link(locator=T.unsafe(nil), **options); end

  def click_link_or_button(locator=T.unsafe(nil), **options); end

  def click_on(locator=T.unsafe(nil), **options); end

  def fill_in(locator=T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  def select(value=T.unsafe(nil), from: T.unsafe(nil), **options); end

  def uncheck(locator=T.unsafe(nil), **options); end

  def unselect(value=T.unsafe(nil), from: T.unsafe(nil), **options); end
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::Actions
end

class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers
  def base(); end

  def catch_error?(error, errors=T.unsafe(nil)); end

  def driver(); end

  def find_css(css, **options); end

  def find_xpath(xpath, **options); end

  def initialize(session, base); end

  def query_scope(); end

  def reload(); end

  def session(); end

  def session_options(); end

  def synchronize(seconds=T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node(); end
end

class Capybara::Node::Base
end

class Capybara::Node::Document
  include ::Capybara::Node::DocumentMatchers
  def evaluate_script(*args); end

  def execute_script(*args); end

  def scroll_to(*args, quirks: T.unsafe(nil), **options); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end
end

class Capybara::Node::Document
end

module Capybara::Node::DocumentMatchers
  def assert_no_title(title, **options); end

  def assert_title(title, **options); end

  def has_no_title?(title, **options); end

  def has_title?(title, **options); end
end

module Capybara::Node::DocumentMatchers
end

class Capybara::Node::Element
  def [](attribute); end

  def allow_reload!(idx=T.unsafe(nil)); end

  def checked?(); end

  def click(*keys, **options); end

  def disabled?(); end

  def double_click(*keys, **options); end

  def drag_to(node, **options); end

  def drop(*args); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def flash(); end

  def hover(); end

  def initial_cache(); end

  def initialize(session, base, query_scope, query); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(*keys, **options); end

  def scroll_to(pos_or_el_or_x, y=T.unsafe(nil), align: T.unsafe(nil), offset: T.unsafe(nil)); end

  def select_option(wait: T.unsafe(nil)); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(*styles); end

  def tag_name(); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def trigger(event); end

  def unselect_option(wait: T.unsafe(nil)); end

  def value(); end

  def visible?(); end
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
end

module Capybara::Node::Finders
  def all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def ancestor(*args, **options, &optional_filter_block); end

  def find(*args, **options, &optional_filter_block); end

  def find_all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def find_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_by_id(id, **options, &optional_filter_block); end

  def find_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def first(*args, **options, &optional_filter_block); end

  def sibling(*args, **options, &optional_filter_block); end
end

module Capybara::Node::Finders
end

module Capybara::Node::Matchers
  def ==(other); end

  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(styles=T.unsafe(nil), **options); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_text(type_or_text, *args, **opts); end

  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_style(styles=T.unsafe(nil), **options); end

  def assert_text(type_or_text, *args, **opts); end

  def has_ancestor?(*args, **options, &optional_filter_block); end

  def has_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_content?(*args, **options); end

  def has_css?(path, **options, &optional_filter_block); end

  def has_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_ancestor?(*args, **options, &optional_filter_block); end

  def has_no_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_content?(*args, **options); end

  def has_no_css?(path, **options, &optional_filter_block); end

  def has_no_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_selector?(*args, **options, &optional_filter_block); end

  def has_no_sibling?(*args, **options, &optional_filter_block); end

  def has_no_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_text?(*args, **options); end

  def has_no_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_xpath?(path, **options, &optional_filter_block); end

  def has_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_selector?(*args, **options, &optional_filter_block); end

  def has_sibling?(*args, **options, &optional_filter_block); end

  def has_style?(styles=T.unsafe(nil), **options); end

  def has_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_text?(*args, **options); end

  def has_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_xpath?(path, **options, &optional_filter_block); end

  def matches_css?(css, **options, &optional_filter_block); end

  def matches_selector?(*args, **options, &optional_filter_block); end

  def matches_style?(styles=T.unsafe(nil), **options); end

  def matches_xpath?(xpath, **options, &optional_filter_block); end

  def not_matches_css?(css, **options, &optional_filter_block); end

  def not_matches_selector?(*args, **options, &optional_filter_block); end

  def not_matches_xpath?(xpath, **options, &optional_filter_block); end
end

module Capybara::Node::Matchers
end

class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers
  def [](name); end

  def allow_reload!(*arg); end

  def checked?(); end

  def disabled?(); end

  def find_css(css, **_options); end

  def find_xpath(xpath, **_options); end

  def initial_cache(); end

  def initialize(native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def readonly?(); end

  def selected?(); end

  def session_options(); end

  def synchronize(_seconds=T.unsafe(nil)); end

  def tag_name(); end

  def text(_type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end

  def value(); end

  def visible?(check_ancestors=T.unsafe(nil)); end
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Simple
end

module Capybara::Node
end

class Capybara::NotSupportedByDriverError
end

class Capybara::NotSupportedByDriverError
end

module Capybara::Queries
end

class Capybara::Queries::ActiveElementQuery
  def initialize(**options); end

  def resolve_for(session); end
end

class Capybara::Queries::ActiveElementQuery
end

class Capybara::Queries::AncestorQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::AncestorQuery
end

class Capybara::Queries::BaseQuery
  def expects_none?(); end

  def failure_message(); end

  def initialize(options); end

  def matches_count?(count); end

  def negative_failure_message(); end

  def options(); end

  def session_options(); end

  def session_options=(session_options); end

  def wait(); end
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  def self.wait(options, default=T.unsafe(nil)); end
end

class Capybara::Queries::CurrentPathQuery
  def initialize(expected_path, **options, &optional_filter_block); end

  def resolves_for?(session); end
end

class Capybara::Queries::CurrentPathQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::SelectorQuery
  def applied_description(); end

  def css(); end

  def description(only_applied=T.unsafe(nil)); end

  def exact?(); end

  def expression(); end

  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), enable_aria_role: T.unsafe(nil), test_id: T.unsafe(nil), selector_format: T.unsafe(nil), order: T.unsafe(nil), **options, &filter_block); end

  def label(); end

  def locator(); end

  def match(); end

  def matches_filters?(node, node_filter_errors=T.unsafe(nil)); end

  def name(); end

  def resolve_for(node, exact=T.unsafe(nil)); end

  def selector(); end

  def supports_exact?(); end

  def visible(); end

  def xpath(exact=T.unsafe(nil)); end
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
end

class Capybara::Queries::SiblingQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::SiblingQuery
end

class Capybara::Queries::StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::StyleQuery
end

class Capybara::Queries::TextQuery
  def description(); end

  def initialize(type=T.unsafe(nil), expected_text, session_options:, **options); end

  def resolve_for(node); end
end

class Capybara::Queries::TextQuery
end

class Capybara::Queries::TitleQuery
  def initialize(expected_title, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::TitleQuery
end

module Capybara::Queries
end

module Capybara::RSpecMatcherProxies
  def all(*args, **kwargs, &block); end

  def within(*args, **kwargs, &block); end
end

module Capybara::RSpecMatcherProxies
end

module Capybara::RSpecMatcherProxyInstaller
end

module Capybara::RSpecMatcherProxyInstaller::ClassMethods
  def included(base); end
end

module Capybara::RSpecMatcherProxyInstaller::ClassMethods
end

module Capybara::RSpecMatcherProxyInstaller
  def self.prepended(base); end
end

module Capybara::RSpecMatchers
  def become_closed(**options); end

  def have_all_of_selectors(*args, **kw_args, &optional_filter_block); end

  def have_ancestor(*args, **kw_args, &optional_filter_block); end

  def have_any_of_selectors(*args, **kw_args, &optional_filter_block); end

  def have_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_checked_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_content(text_or_type, *args, **options); end

  def have_css(expr, **options, &optional_filter_block); end

  def have_current_path(path, **options, &optional_filter_block); end

  def have_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_no_ancestor(*args, **kw_args, &optional_filter_block); end

  def have_no_button(*args, **kw_args, &optional_filter_block); end

  def have_no_checked_field(*args, **kw_args, &optional_filter_block); end

  def have_no_content(*args, **kw_args, &optional_filter_block); end

  def have_no_css(*args, **kw_args, &optional_filter_block); end

  def have_no_current_path(*args, **kw_args, &optional_filter_block); end

  def have_no_field(*args, **kw_args, &optional_filter_block); end

  def have_no_link(*args, **kw_args, &optional_filter_block); end

  def have_no_select(*args, **kw_args, &optional_filter_block); end

  def have_no_selector(*args, **kw_args, &optional_filter_block); end

  def have_no_sibling(*args, **kw_args, &optional_filter_block); end

  def have_no_table(*args, **kw_args, &optional_filter_block); end

  def have_no_text(*args, **kw_args, &optional_filter_block); end

  def have_no_title(*args, **kw_args, &optional_filter_block); end

  def have_no_unchecked_field(*args, **kw_args, &optional_filter_block); end

  def have_no_xpath(*args, **kw_args, &optional_filter_block); end

  def have_none_of_selectors(*args, **kw_args, &optional_filter_block); end

  def have_select(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_selector(*args, **kw_args, &optional_filter_block); end

  def have_sibling(*args, **kw_args, &optional_filter_block); end

  def have_style(styles=T.unsafe(nil), **options); end

  def have_table(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_text(text_or_type, *args, **options); end

  def have_title(title, **options); end

  def have_unchecked_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_xpath(expr, **options, &optional_filter_block); end

  def match_css(expr, **options, &optional_filter_block); end

  def match_selector(*args, **kw_args, &optional_filter_block); end

  def match_style(styles=T.unsafe(nil), **options); end

  def match_xpath(expr, **options, &optional_filter_block); end

  def not_match_css(*args, **kw_args, &optional_filter_block); end

  def not_match_selector(*args, **kw_args, &optional_filter_block); end

  def not_match_xpath(*args, **kw_args, &optional_filter_block); end
end

module Capybara::RSpecMatchers::CountSugar
  def at_least(number); end

  def at_most(number); end

  def exactly(number); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

module Capybara::RSpecMatchers::CountSugar
end

module Capybara::RSpecMatchers::Matchers
end

class Capybara::RSpecMatchers::Matchers::Base
  include ::Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(*args, **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::Base
end

class Capybara::RSpecMatchers::Matchers::BecomeClosed
  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(options); end

  def matches?(window); end
end

class Capybara::RSpecMatchers::Matchers::BecomeClosed
end

module Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def and(matcher); end

  def and_then(matcher); end

  def or(matcher); end
end

class Capybara::RSpecMatchers::Matchers::Compound::And
  include ::Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

class Capybara::RSpecMatchers::Matchers::Compound::And
end

class Capybara::RSpecMatchers::Matchers::Compound::CapybaraEvaluator
  def initialize(actual); end

  def matcher_matches?(matcher); end

  def reset(); end
end

class Capybara::RSpecMatchers::Matchers::Compound::CapybaraEvaluator
end

class Capybara::RSpecMatchers::Matchers::Compound::Or
  include ::Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

class Capybara::RSpecMatchers::Matchers::Compound::Or
end

module Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
  def match(_expected, actual); end

  def sync_element(el); end
end

module Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

module Capybara::RSpecMatchers::Matchers::Compound
end

class Capybara::RSpecMatchers::Matchers::CountableWrappedElementMatcher
  include ::Capybara::RSpecMatchers::CountSugar
  include ::Capybara::RSpecMatchers::SpatialSugar
end

class Capybara::RSpecMatchers::Matchers::CountableWrappedElementMatcher
end

class Capybara::RSpecMatchers::Matchers::HaveAllSelectors
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveAllSelectors
end

class Capybara::RSpecMatchers::Matchers::HaveAncestor
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveAncestor
end

class Capybara::RSpecMatchers::Matchers::HaveAnySelectors
  def description(); end

  def does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveAnySelectors
end

class Capybara::RSpecMatchers::Matchers::HaveCurrentPath
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveCurrentPath
end

class Capybara::RSpecMatchers::Matchers::HaveNoSelectors
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveNoSelectors
end

class Capybara::RSpecMatchers::Matchers::HaveSelector
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveSelector
end

class Capybara::RSpecMatchers::Matchers::HaveSibling
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveSibling
end

class Capybara::RSpecMatchers::Matchers::HaveStyle
  def initialize(*args, **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::HaveStyle
end

class Capybara::RSpecMatchers::Matchers::HaveText
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def format(content); end
end

class Capybara::RSpecMatchers::Matchers::HaveText
end

class Capybara::RSpecMatchers::Matchers::HaveTitle
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveTitle
end

class Capybara::RSpecMatchers::Matchers::MatchSelector
end

class Capybara::RSpecMatchers::Matchers::MatchSelector
end

class Capybara::RSpecMatchers::Matchers::MatchStyle
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end

  def initialize(styles=T.unsafe(nil), **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::MatchStyle
end

class Capybara::RSpecMatchers::Matchers::NegatedMatcher
  include ::Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(actual); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(matcher); end

  def matches?(actual); end
end

class Capybara::RSpecMatchers::Matchers::NegatedMatcher
end

class Capybara::RSpecMatchers::Matchers::WrappedElementMatcher
  def does_not_match?(actual); end

  def matches?(actual); end
end

class Capybara::RSpecMatchers::Matchers::WrappedElementMatcher
end

module Capybara::RSpecMatchers::Matchers
end

module Capybara::RSpecMatchers::SpatialSugar
  def above(el); end

  def below(el); end

  def left_of(el); end

  def near(el); end

  def right_of(el); end
end

module Capybara::RSpecMatchers::SpatialSugar
end

module Capybara::RSpecMatchers
end

module Capybara::RackTest
end

class Capybara::RackTest::Browser
  include ::Rack::Test::Methods
  def app(); end

  def build_uri(path); end

  def current_host(); end

  def current_host=(current_host); end

  def current_url(); end

  def dom(); end

  def driver(); end

  def find(format, selector); end

  def follow(method, path, **attributes); end

  def html(); end

  def initialize(driver); end

  def options(); end

  def process(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def process_and_follow_redirects(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def refresh(); end

  def request_path(); end

  def reset_cache!(); end

  def reset_host!(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
end

class Capybara::RackTest::Browser
end

class Capybara::RackTest::CSSHandlers
  include ::Kernel
  include ::DEBUGGER__::TrapInterceptor
  def disabled(list); end

  def enabled(list); end
end

class Capybara::RackTest::CSSHandlers
end

class Capybara::RackTest::Driver
  def app(); end

  def browser(); end

  def delete(*args, &block); end

  def dom(); end

  def find_css(selector); end

  def find_xpath(selector); end

  def follow(method, path, **attributes); end

  def follow_redirects?(); end

  def get(*args, &block); end

  def header(key, value); end

  def initialize(app, **options); end

  def options(); end

  def post(*args, &block); end

  def put(*args, &block); end

  def redirect_limit(); end

  def request(); end

  def response(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Form
  def multipart?(); end

  def params(button); end

  def submit(button); end
end

class Capybara::RackTest::Form::NilUploadedFile
  def initialize(); end

  def read(); end

  def size(); end
end

class Capybara::RackTest::Form::NilUploadedFile
end

class Capybara::RackTest::Form::ParamsHash
  def to_params_hash(); end
end

class Capybara::RackTest::Form::ParamsHash
end

class Capybara::RackTest::Form
end

class Capybara::RackTest::Node
  def [](*arg, **arg1, &arg2); end

  def all_text(*arg, **arg1, &arg2); end

  def checkbox?(); end

  def checkbox_or_radio?(field=T.unsafe(nil)); end

  def checked?(*arg, **arg1, &arg2); end

  def click(*arg, **arg1, &arg2); end

  def disabled?(*arg, **arg1, &arg2); end

  def displayed_text(check_ancestor: T.unsafe(nil)); end

  def find_css(*arg, **arg1, &arg2); end

  def find_xpath(*arg, **arg1, &arg2); end

  def input_field?(); end

  def path(*arg, **arg1, &arg2); end

  def radio?(); end

  def range?(); end

  def readonly?(*arg, **arg1, &arg2); end

  def select_option(*arg, **arg1, &arg2); end

  def selected?(*arg, **arg1, &arg2); end

  def set(*arg, **arg1, &arg2); end

  def style(*arg, **arg1, &arg2); end

  def tag_name(*arg, **arg1, &arg2); end

  def text_or_password?(); end

  def textarea?(); end

  def unselect_option(*arg, **arg1, &arg2); end

  def value(*arg, **arg1, &arg2); end

  def visible?(*arg, **arg1, &arg2); end

  def visible_text(*arg, **arg1, &arg2); end
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
end

module Capybara::RackTest
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlySessionConfig
  def always_include_port=(_); end

  def app_host=(_); end

  def asset_host=(_); end

  def automatic_label_click=(_); end

  def automatic_reload=(_); end

  def default_host=(_); end

  def default_max_wait_time=(_); end

  def default_normalize_ws=(_); end

  def default_selector=(_); end

  def default_set_options=(_); end

  def disable_animation=(_); end

  def enable_aria_label=(_); end

  def enable_aria_role=(_); end

  def exact=(_); end

  def exact_text=(_); end

  def ignore_hidden_elements=(_); end

  def match=(_); end

  def predicates_wait=(_); end

  def raise_server_errors=(_); end

  def run_server=(_); end

  def save_path=(_); end

  def server_errors=(_); end

  def server_host=(_); end

  def server_port=(_); end

  def test_id=(_); end

  def visible_text_only=(_); end

  def w3c_click_offset=(_); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::ReadOnlySessionConfig
end

class Capybara::RegistrationContainer
  def [](name); end

  def []=(name, value); end

  def method_missing(method_name, *args, **options, &block); end

  def names(); end
end

class Capybara::RegistrationContainer
end

class Capybara::Result
  include ::Enumerable
  def [](*args); end

  def allow_reload!(); end

  def at(*args); end

  def compare_count(); end

  def each(&block); end

  def empty?(); end

  def failure_message(); end

  def index(*arg); end

  def initialize(elements, query); end

  def inspect(*args, **arg, &block); end

  def last(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def matches_count?(); end

  def negative_failure_message(); end

  def sample(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def unfiltered_size(); end

  def values_at(*args, **arg, &block); end
end

class Capybara::Result
  extend ::Forwardable
end

class Capybara::ScopeError
end

class Capybara::ScopeError
end

class Capybara::Screenshot::Callbacks::CallbackSet
  def call(*args); end
end

module Capybara::Screenshot::Callbacks::ClassMethods
  def callbacks(); end

  def define_callback(name); end

  def run_callbacks(name, *args); end
end

module Capybara::Screenshot::Callbacks::InstanceMethods
  def run_callbacks(name, *args); end
end

module Capybara::Screenshot::Callbacks
  def self.included(receiver); end
end

class Capybara::Screenshot::Pruner
  def initialize(strategy); end

  def prune_old_screenshots(); end

  def strategy(); end
end

class Capybara::Screenshot::Saver
  def capybara(); end

  def clear_save_path(); end

  def display_image(); end

  def file_base_name(); end

  def html_path(); end

  def html_saved?(); end

  def initialize(capybara, page, html_save=T.unsafe(nil), filename_prefix=T.unsafe(nil)); end

  def output_screenshot_path(); end

  def page(); end

  def save(); end

  def save_html(); end

  def save_screenshot(); end

  def screenshot_path(); end

  def screenshot_saved?(); end
end

class Capybara::Screenshot::Saver
  def self.after_save_html(&block); end

  def self.after_save_screenshot(&block); end
end

module Capybara::Screenshot
  def self.after_save_html(&block); end

  def self.after_save_screenshot(&block); end

  def self.append_random(); end

  def self.append_random=(append_random); end

  def self.append_screenshot_path=(value); end

  def self.append_timestamp(); end

  def self.append_timestamp=(append_timestamp); end

  def self.autosave_on_failure(); end

  def self.autosave_on_failure=(autosave_on_failure); end

  def self.capybara_root(); end

  def self.capybara_tmp_path(); end

  def self.capybara_tmp_path=(path); end

  def self.filename_prefix_for(test_type, test); end

  def self.filename_prefix_formatters(); end

  def self.filename_prefix_formatters=(filename_prefix_formatters); end

  def self.final_session_name(); end

  def self.final_session_name=(final_session_name); end

  def self.new_saver(*args); end

  def self.prune(options=T.unsafe(nil)); end

  def self.prune_strategy(); end

  def self.prune_strategy=(prune_strategy); end

  def self.register_driver(driver, &block); end

  def self.register_filename_prefix_formatter(test_type, &block); end

  def self.registered_drivers(); end

  def self.registered_drivers=(registered_drivers); end

  def self.reset_prune_history(); end

  def self.s3_configuration(); end

  def self.s3_configuration=(s3_configuration); end

  def self.s3_object_configuration(); end

  def self.s3_object_configuration=(s3_object_configuration); end

  def self.screen_shot_and_open_image(); end

  def self.screen_shot_and_save_page(); end

  def self.screenshot_and_open_image(); end

  def self.screenshot_and_save_page(); end

  def self.webkit_options(); end

  def self.webkit_options=(webkit_options); end
end

class Capybara::Selector
  def add_error(error_msg); end

  def builder(expr=T.unsafe(nil)); end

  def call(locator, **options); end

  def current_format(); end

  def enable_aria_label(); end

  def enable_aria_role(); end

  def errors(); end

  def expression_for(name, locator, config: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def format(); end

  def initialize(definition, config:, format:); end

  def test_id(); end

  def with_filter_errors(errors); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS::Splitter
  def split(css); end
end

class Capybara::Selector::CSS::Splitter
end

class Capybara::Selector::CSS
  def self.escape(str); end

  def self.escape_char(char); end

  def self.split(css); end
end

class Capybara::Selector::CSSBuilder
  def add_attribute_conditions(**attributes); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::CSSBuilder
end

class Capybara::Selector::Definition
  def css(*allowed_filters, &block); end

  def custom_filters(); end

  def default_format(); end

  def default_visibility(fallback=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe(*args, **arg, &block); end

  def describe_all_expression_filters(**opts); end

  def describe_expression_filters(&block); end

  def describe_node_filters(&block); end

  def description(*args, **arg, &block); end

  def expression_filter(*args, **arg, &block); end

  def expression_filters(); end

  def expressions(); end

  def filter(*args, **arg, &block); end

  def filter_set(name, filters_to_use=T.unsafe(nil)); end

  def initialize(name, locator_type: T.unsafe(nil), raw_locator: T.unsafe(nil), supports_exact: T.unsafe(nil), &block); end

  def label(label=T.unsafe(nil)); end

  def locator_filter(*types, **options, &block); end

  def locator_types(); end

  def match(&block); end

  def match?(locator); end

  def name(); end

  def node_filter(*args, **arg, &block); end

  def node_filters(); end

  def raw_locator?(); end

  def supports_exact?(); end

  def visible(default_visibility=T.unsafe(nil), &block); end

  def xpath(*allowed_filters, &block); end
end

class Capybara::Selector::Definition
  extend ::Forwardable
end

class Capybara::Selector::FilterSet
  def describe(what=T.unsafe(nil), &block); end

  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end

  def descriptions(); end

  def expression_filter(name, *types, **options, &block); end

  def expression_filter_descriptions(); end

  def expression_filters(); end

  def filter(names, *types, **options, &block); end

  def import(name, filters=T.unsafe(nil)); end

  def initialize(name, &block); end

  def node_filter(names, *types, **options, &block); end

  def node_filter_descriptions(); end

  def node_filters(); end

  def undeclared_descriptions(); end
end

class Capybara::Selector::FilterSet
  def self.[](name); end

  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end
end

module Capybara::Selector::Filters
end

class Capybara::Selector::Filters::Base
  def boolean?(); end

  def default(); end

  def default?(); end

  def format(); end

  def handles_option?(option_name); end

  def initialize(name, matcher, block, **options); end

  def matcher?(); end

  def skip?(value); end
end

class Capybara::Selector::Filters::Base
end

class Capybara::Selector::Filters::ExpressionFilter
  def apply_filter(expr, name, value, selector); end
end

class Capybara::Selector::Filters::ExpressionFilter
end

class Capybara::Selector::Filters::IdentityExpressionFilter
  def apply_filter(expr, _name, _value, _ctx); end

  def initialize(name); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter
end

class Capybara::Selector::Filters::LocatorFilter
  def initialize(block, **options); end

  def matches?(node, value, context=T.unsafe(nil), exact:); end
end

class Capybara::Selector::Filters::LocatorFilter
end

class Capybara::Selector::Filters::NodeFilter
  def matches?(node, name, value, context=T.unsafe(nil)); end
end

class Capybara::Selector::Filters::NodeFilter
end

module Capybara::Selector::Filters
end

class Capybara::Selector::RegexpDisassembler
  def alternated_substrings(); end

  def initialize(regexp); end

  def substrings(); end
end

class Capybara::Selector::RegexpDisassembler
end

class Capybara::Selector::XPathBuilder
  def add_attribute_conditions(**conditions); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::XPathBuilder
end

class Capybara::Selector
  def self.[](name); end

  def self.add(name, **options, &block); end

  def self.all(); end

  def self.for(locator); end

  def self.remove(name); end

  def self.update(name, &block); end
end

module Capybara::Selenium
end

module Capybara::Selenium::ChromeLogs
  def available_log_types(); end

  def commands(command); end

  def log(type); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::ChromeLogs
end

class Capybara::Selenium::ChromeNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def click(*arg, **arg1); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::ChromeNode
end

class Capybara::Selenium::Driver
  include ::Capybara::Selenium::Find
  def accept_modal(_type, **options); end

  def app(); end

  def browser(); end

  def dismiss_modal(_type, **options); end

  def frame_obscured_at?(x:, y:); end

  def initialize(app, **options); end

  def open_new_window(kind=T.unsafe(nil)); end

  def options(); end

  def quit(); end

  def save_screenshot(path, **_options); end

  def send_keys(*args); end

  def title(); end
  CAPS_VERSION = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::ChromeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def download_path=(path); end

  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::FirefoxDriver
end

module Capybara::Selenium::Driver::FirefoxDriver
  def self.extended(driver); end

  def self.w3c?(driver); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
end

module Capybara::Selenium::Driver::SafariDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::SafariDriver
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def self.extended(driver); end

  def self.pause_broken?(sel_driver); end
end

class Capybara::Selenium::Driver
  def self.load_selenium(); end

  def self.register_specialization(browser_name, specialization); end

  def self.selenium_webdriver_version(); end

  def self.specializations(); end
end

class Capybara::Selenium::EdgeNode
  include ::Capybara::Selenium::Node::Html5Drag
  def click(*arg); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::EdgeNode
end

module Capybara::Selenium::Find
  def find_css(selector, uses_visibility: T.unsafe(nil), texts: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end

  def find_xpath(selector, uses_visibility: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end
end

module Capybara::Selenium::Find
end

class Capybara::Selenium::FirefoxNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def drop(*args); end

  def focused?(); end
end

class Capybara::Selenium::FirefoxNode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::Node
  include ::Capybara::Selenium::Find
  include ::Capybara::Selenium::Scroll
  def content_editable?(); end

  def drag_to(element, drop_modifiers: T.unsafe(nil), **arg); end

  def drop(*_); end

  def obscured?(x: T.unsafe(nil), y: T.unsafe(nil)); end

  def scroll_if_needed(); end

  def scroll_to_center(); end
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
  RAPID_APPEND_TEXT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::FileInputClickEmulation
  def click(keys=T.unsafe(nil), **options); end
end

module Capybara::Selenium::Node::FileInputClickEmulation
end

module Capybara::Selenium::Node::Html5Drag
  def drag_to(element, html5: T.unsafe(nil), delay: T.unsafe(nil), drop_modifiers: T.unsafe(nil)); end
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
end

class Capybara::Selenium::Node::ModifierKeysStack
  def include?(key); end

  def pop(); end

  def press(key); end

  def push(); end
end

class Capybara::Selenium::Node::ModifierKeysStack
end

class Capybara::Selenium::Node
end

class Capybara::Selenium::SafariNode
  def set_text(value, clear: T.unsafe(nil), **_unused); end
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::SafariNode
end

module Capybara::Selenium::Scroll
  def scroll_by(x, y); end

  def scroll_to(element, location, position=T.unsafe(nil)); end
  SCROLL_POSITIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Scroll
end

module Capybara::Selenium
end

class Capybara::Server
  def app(); end

  def base_url(); end

  def boot(); end

  def error(); end

  def host(); end

  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  def port(); end

  def reset_error!(); end

  def responsive?(); end

  def using_ssl?(); end

  def wait_for_pending_requests(); end
end

class Capybara::Server::AnimationDisabler
  def call(env); end

  def initialize(app); end
  DISABLE_CSS_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
  DISABLE_JS_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  def self.selector_for(css_or_bool); end
end

class Capybara::Server::Checker
  def initialize(host, port); end

  def request(&block); end

  def ssl?(); end
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
end

class Capybara::Server::Middleware
  def call(env); end

  def clear_error(); end

  def error(); end

  def initialize(app, server_errors, extra_middleware=T.unsafe(nil)); end

  def pending_requests(); end

  def pending_requests?(); end
end

class Capybara::Server::Middleware::Counter
  def decrement(uri); end

  def increment(uri); end

  def positive?(); end

  def value(); end
end

class Capybara::Server::Middleware::Counter
end

class Capybara::Server::Middleware
end

class Capybara::Server
  def self.ports(); end
end

class Capybara::Session
  include ::Capybara::SessionMatchers
  include ::Capybara::SessionScreenshotOverrides
  def accept_alert(text=T.unsafe(nil), **options, &blk); end

  def accept_confirm(text=T.unsafe(nil), **options, &blk); end

  def accept_prompt(text=T.unsafe(nil), **options, &blk); end

  def active_element(); end

  def all(*arg, **arg1, &arg2); end

  def app(); end

  def assert_all_of_selectors(*arg, **arg1, &arg2); end

  def assert_any_of_selectors(*arg, **arg1, &arg2); end

  def assert_no_selector(*arg, **arg1, &arg2); end

  def assert_no_text(*arg, **arg1, &arg2); end

  def assert_no_title(*arg, **arg1, &arg2); end

  def assert_none_of_selectors(*arg, **arg1, &arg2); end

  def assert_selector(*arg, **arg1, &arg2); end

  def assert_text(*arg, **arg1, &arg2); end

  def assert_title(*arg, **arg1, &arg2); end

  def attach_file(*arg, **arg1, &arg2); end

  def body(); end

  def check(*arg, **arg1, &arg2); end

  def choose(*arg, **arg1, &arg2); end

  def cleanup!(); end

  def click_button(*arg, **arg1, &arg2); end

  def click_link(*arg, **arg1, &arg2); end

  def click_link_or_button(*arg, **arg1, &arg2); end

  def click_on(*arg, **arg1, &arg2); end

  def config(); end

  def configure(); end

  def current_host(); end

  def current_path(); end

  def current_scope(); end

  def current_url(); end

  def current_window(); end

  def dismiss_confirm(text=T.unsafe(nil), **options, &blk); end

  def dismiss_prompt(text=T.unsafe(nil), **options, &blk); end

  def document(); end

  def driver(); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def fill_in(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_button(*arg, **arg1, &arg2); end

  def find_by_id(*arg, **arg1, &arg2); end

  def find_field(*arg, **arg1, &arg2); end

  def find_link(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def go_back(); end

  def go_forward(); end

  def has_button?(*arg, **arg1, &arg2); end

  def has_checked_field?(*arg, **arg1, &arg2); end

  def has_content?(*arg, **arg1, &arg2); end

  def has_css?(*arg, **arg1, &arg2); end

  def has_field?(*arg, **arg1, &arg2); end

  def has_link?(*arg, **arg1, &arg2); end

  def has_no_button?(*arg, **arg1, &arg2); end

  def has_no_checked_field?(*arg, **arg1, &arg2); end

  def has_no_content?(*arg, **arg1, &arg2); end

  def has_no_css?(*arg, **arg1, &arg2); end

  def has_no_field?(*arg, **arg1, &arg2); end

  def has_no_link?(*arg, **arg1, &arg2); end

  def has_no_select?(*arg, **arg1, &arg2); end

  def has_no_selector?(*arg, **arg1, &arg2); end

  def has_no_table?(*arg, **arg1, &arg2); end

  def has_no_text?(*arg, **arg1, &arg2); end

  def has_no_title?(*arg, **arg1, &arg2); end

  def has_no_unchecked_field?(*arg, **arg1, &arg2); end

  def has_no_xpath?(*arg, **arg1, &arg2); end

  def has_select?(*arg, **arg1, &arg2); end

  def has_selector?(*arg, **arg1, &arg2); end

  def has_table?(*arg, **arg1, &arg2); end

  def has_text?(*arg, **arg1, &arg2); end

  def has_title?(*arg, **arg1, &arg2); end

  def has_unchecked_field?(*arg, **arg1, &arg2); end

  def has_xpath?(*arg, **arg1, &arg2); end

  def html(); end

  def initialize(mode, app=T.unsafe(nil)); end

  def mode(); end

  def open_new_window(kind=T.unsafe(nil)); end

  def query(*arg, **arg1, &arg2); end

  def quit(); end

  def raise_server_error!(); end

  def refresh(); end

  def refute_selector(*arg, **arg1, &arg2); end

  def reset!(); end

  def reset_session!(); end

  def response_headers(); end

  def save_and_open_page(path=T.unsafe(nil)); end

  def save_and_open_screenshot(path=T.unsafe(nil), **options); end

  def save_page(path=T.unsafe(nil)); end

  def save_screenshot(path=T.unsafe(nil), **options); end

  def scroll_by(*arg, **arg1, &arg2); end

  def scroll_to(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def send_keys(*args, **kw_args); end

  def server(); end

  def server_url(); end

  def source(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(window=T.unsafe(nil), **options, &window_locator); end

  def synchronized(); end

  def synchronized=(synchronized); end

  def text(*arg, **arg1, &arg2); end

  def title(*arg, **arg1, &arg2); end

  def uncheck(*arg, **arg1, &arg2); end

  def unselect(*arg, **arg1, &arg2); end

  def using_wait_time(seconds, &block); end

  def visit(visit_uri); end

  def window_opened_by(**options); end

  def windows(); end

  def within(*args, **kw_args); end

  def within_element(*args, **kw_args); end

  def within_fieldset(locator, &block); end

  def within_frame(*args, **kw_args); end

  def within_table(locator, &block); end
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  def self.instance_created?(); end
end

class Capybara::SessionConfig
  def always_include_port(); end

  def always_include_port=(always_include_port); end

  def app_host(); end

  def app_host=(url); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def automatic_label_click(); end

  def automatic_label_click=(automatic_label_click); end

  def automatic_reload(); end

  def automatic_reload=(automatic_reload); end

  def default_host(); end

  def default_host=(url); end

  def default_max_wait_time(); end

  def default_max_wait_time=(default_max_wait_time); end

  def default_normalize_ws(); end

  def default_normalize_ws=(default_normalize_ws); end

  def default_selector(); end

  def default_selector=(default_selector); end

  def default_set_options(); end

  def default_set_options=(default_set_options); end

  def disable_animation(); end

  def disable_animation=(disable_animation); end

  def enable_aria_label(); end

  def enable_aria_label=(enable_aria_label); end

  def enable_aria_role(); end

  def enable_aria_role=(enable_aria_role); end

  def exact(); end

  def exact=(exact); end

  def exact_text(); end

  def exact_text=(exact_text); end

  def ignore_hidden_elements(); end

  def ignore_hidden_elements=(ignore_hidden_elements); end

  def match(); end

  def match=(match); end

  def predicates_wait(); end

  def predicates_wait=(predicates_wait); end

  def raise_server_errors(); end

  def raise_server_errors=(raise_server_errors); end

  def run_server(); end

  def run_server=(run_server); end

  def save_path(); end

  def save_path=(save_path); end

  def server_errors(); end

  def server_errors=(errors); end

  def server_host(); end

  def server_host=(server_host); end

  def server_port(); end

  def server_port=(server_port); end

  def test_id(); end

  def test_id=(id); end

  def visible_text_only(); end

  def visible_text_only=(visible_text_only); end

  def w3c_click_offset(); end

  def w3c_click_offset=(w3c_click_offset); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
end

module Capybara::SessionMatchers
  def assert_current_path(path, **options, &optional_filter_block); end

  def assert_no_current_path(path, **options, &optional_filter_block); end

  def has_current_path?(path, **options, &optional_filter_block); end

  def has_no_current_path?(path, **options, &optional_filter_block); end
end

module Capybara::SessionMatchers
end

module Capybara::SessionScreenshotOverrides
  def within_window(window_or_handle); end
end

class Capybara::UnselectNotAllowed
end

class Capybara::UnselectNotAllowed
end

class Capybara::Window
  def ==(other); end

  def close(); end

  def closed?(); end

  def current?(); end

  def eql?(other); end

  def exists?(); end

  def fullscreen(); end

  def handle(); end

  def initialize(session, handle); end

  def maximize(); end

  def resize_to(width, height); end

  def session(); end

  def size(); end
end

class Capybara::Window
end

class Capybara::WindowError
end

class Capybara::WindowError
end

module Capybara
  extend ::Capybara::DSL
  extend ::Capybara::DSLRSpecProxyInstaller
  def self.HTML(html); end

  def self.add_selector(name, **options, &block); end

  def self.allow_gumbo(*args, **arg, &block); end

  def self.allow_gumbo=(*args, **arg, &block); end

  def self.always_include_port(*args, **arg, &block); end

  def self.always_include_port=(*args, **arg, &block); end

  def self.app(*args, **arg, &block); end

  def self.app=(*args, **arg, &block); end

  def self.app_host(*args, **arg, &block); end

  def self.app_host=(*args, **arg, &block); end

  def self.asset_host(*args, **arg, &block); end

  def self.asset_host=(*args, **arg, &block); end

  def self.automatic_label_click(*args, **arg, &block); end

  def self.automatic_label_click=(*args, **arg, &block); end

  def self.automatic_reload(*args, **arg, &block); end

  def self.automatic_reload=(*args, **arg, &block); end

  def self.configure(); end

  def self.current_driver(); end

  def self.current_driver=(name); end

  def self.current_session(); end

  def self.default_driver(*args, **arg, &block); end

  def self.default_driver=(*args, **arg, &block); end

  def self.default_host(*args, **arg, &block); end

  def self.default_host=(*args, **arg, &block); end

  def self.default_max_wait_time(*args, **arg, &block); end

  def self.default_max_wait_time=(*args, **arg, &block); end

  def self.default_normalize_ws(*args, **arg, &block); end

  def self.default_normalize_ws=(*args, **arg, &block); end

  def self.default_selector(*args, **arg, &block); end

  def self.default_selector=(*args, **arg, &block); end

  def self.default_set_options(*args, **arg, &block); end

  def self.default_set_options=(*args, **arg, &block); end

  def self.disable_animation(*args, **arg, &block); end

  def self.disable_animation=(*args, **arg, &block); end

  def self.drivers(); end

  def self.enable_aria_label(*args, **arg, &block); end

  def self.enable_aria_label=(*args, **arg, &block); end

  def self.enable_aria_role(*args, **arg, &block); end

  def self.enable_aria_role=(*args, **arg, &block); end

  def self.exact(*args, **arg, &block); end

  def self.exact=(*args, **arg, &block); end

  def self.exact_text(*args, **arg, &block); end

  def self.exact_text=(*args, **arg, &block); end

  def self.ignore_hidden_elements(*args, **arg, &block); end

  def self.ignore_hidden_elements=(*args, **arg, &block); end

  def self.javascript_driver(*args, **arg, &block); end

  def self.javascript_driver=(*args, **arg, &block); end

  def self.match(*args, **arg, &block); end

  def self.match=(*args, **arg, &block); end

  def self.mode(); end

  def self.modify_selector(name, &block); end

  def self.predicates_wait(*args, **arg, &block); end

  def self.predicates_wait=(*args, **arg, &block); end

  def self.raise_server_errors(*args, **arg, &block); end

  def self.raise_server_errors=(*args, **arg, &block); end

  def self.register_driver(name, &block); end

  def self.register_server(name, &block); end

  def self.reset!(); end

  def self.reset_sessions!(); end

  def self.reuse_server(*args, **arg, &block); end

  def self.reuse_server=(*args, **arg, &block); end

  def self.run_default_server(app, port); end

  def self.run_server(*args, **arg, &block); end

  def self.run_server=(*args, **arg, &block); end

  def self.save_path(*args, **arg, &block); end

  def self.save_path=(*args, **arg, &block); end

  def self.server(*args, **arg, &block); end

  def self.server=(*args, **arg, &block); end

  def self.server_errors(*args, **arg, &block); end

  def self.server_errors=(*args, **arg, &block); end

  def self.server_host(*args, **arg, &block); end

  def self.server_host=(*args, **arg, &block); end

  def self.server_port(*args, **arg, &block); end

  def self.server_port=(*args, **arg, &block); end

  def self.servers(); end

  def self.session_name(); end

  def self.session_name=(name); end

  def self.session_options(); end

  def self.string(html); end

  def self.test_id(*args, **arg, &block); end

  def self.test_id=(*args, **arg, &block); end

  def self.threadsafe(*args, **arg, &block); end

  def self.threadsafe=(*args, **arg, &block); end

  def self.use_default_driver(); end

  def self.use_html5_parsing(*args, **arg, &block); end

  def self.use_html5_parsing=(*args, **arg, &block); end

  def self.using_driver(driver); end

  def self.using_session(name_or_session, &block); end

  def self.using_wait_time(seconds); end

  def self.visible_text_only(*args, **arg, &block); end

  def self.visible_text_only=(*args, **arg, &block); end

  def self.w3c_click_offset(*args, **arg, &block); end

  def self.w3c_click_offset=(*args, **arg, &block); end
end

module CapybaraScreenshot::Helpers
  def black(text); end

  def blue(text); end

  def bright_black(text); end

  def bright_blue(text); end

  def bright_cyan(text); end

  def bright_green(text); end

  def bright_magenta(text); end

  def bright_purple(text); end

  def bright_red(text); end

  def bright_white(text); end

  def bright_yellow(text); end

  def cyan(text); end

  def green(text); end

  def magenta(text); end

  def purple(text); end

  def red(text); end

  def white(text); end

  def yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module CharDet
  ACO = ::T.let(nil, ::T.untyped)
  ACV = ::T.let(nil, ::T.untyped)
  ASC = ::T.let(nil, ::T.untyped)
  ASO = ::T.let(nil, ::T.untyped)
  ASS = ::T.let(nil, ::T.untyped)
  ASV = ::T.let(nil, ::T.untyped)
  BIG5_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  BIG5_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  BIG5_cls = ::T.let(nil, ::T.untyped)
  BIG5_st = ::T.let(nil, ::T.untyped)
  Big5CharLenTable = ::T.let(nil, ::T.untyped)
  Big5CharToFreqOrder = ::T.let(nil, ::T.untyped)
  Big5SMModel = ::T.let(nil, ::T.untyped)
  BulgarianLangModel = ::T.let(nil, ::T.untyped)
  CLASS_NUM = ::T.let(nil, ::T.untyped)
  DONT_KNOW = ::T.let(nil, ::T.untyped)
  EDetecting = ::T.let(nil, ::T.untyped)
  EError = ::T.let(nil, ::T.untyped)
  EEscAscii = ::T.let(nil, ::T.untyped)
  EFoundIt = ::T.let(nil, ::T.untyped)
  EHighbyte = ::T.let(nil, ::T.untyped)
  EItsMe = ::T.let(nil, ::T.untyped)
  ENOUGH_DATA_THRESHOLD = ::T.let(nil, ::T.untyped)
  ENOUGH_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  ENotMe = ::T.let(nil, ::T.untyped)
  EPureAscii = ::T.let(nil, ::T.untyped)
  EStart = ::T.let(nil, ::T.untyped)
  EUCJPCharLenTable = ::T.let(nil, ::T.untyped)
  EUCJPSMModel = ::T.let(nil, ::T.untyped)
  EUCJP_cls = ::T.let(nil, ::T.untyped)
  EUCJP_st = ::T.let(nil, ::T.untyped)
  EUCKRCharLenTable = ::T.let(nil, ::T.untyped)
  EUCKRCharToFreqOrder = ::T.let(nil, ::T.untyped)
  EUCKRSMModel = ::T.let(nil, ::T.untyped)
  EUCKR_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  EUCKR_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  EUCKR_cls = ::T.let(nil, ::T.untyped)
  EUCKR_st = ::T.let(nil, ::T.untyped)
  EUCTWCharLenTable = ::T.let(nil, ::T.untyped)
  EUCTWCharToFreqOrder = ::T.let(nil, ::T.untyped)
  EUCTWSMModel = ::T.let(nil, ::T.untyped)
  EUCTW_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  EUCTW_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  EUCTW_cls = ::T.let(nil, ::T.untyped)
  EUCTW_st = ::T.let(nil, ::T.untyped)
  FINAL_KAF = ::T.let(nil, ::T.untyped)
  FINAL_MEM = ::T.let(nil, ::T.untyped)
  FINAL_NUN = ::T.let(nil, ::T.untyped)
  FINAL_PE = ::T.let(nil, ::T.untyped)
  FINAL_TSADI = ::T.let(nil, ::T.untyped)
  FREQ_CAT_NUM = ::T.let(nil, ::T.untyped)
  GB18030CharLenTable = ::T.let(nil, ::T.untyped)
  GB18030CharToFreqOrder = ::T.let(nil, ::T.untyped)
  GB18030SMModel = ::T.let(nil, ::T.untyped)
  GB18030_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  GB18030_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  GB18030_cls = ::T.let(nil, ::T.untyped)
  GB18030_st = ::T.let(nil, ::T.untyped)
  GreekLangModel = ::T.let(nil, ::T.untyped)
  HZCharLenTable = ::T.let(nil, ::T.untyped)
  HZSMModel = ::T.let(nil, ::T.untyped)
  HZ_cls = ::T.let(nil, ::T.untyped)
  HZ_st = ::T.let(nil, ::T.untyped)
  HebrewLangModel = ::T.let(nil, ::T.untyped)
  HungarianLangModel = ::T.let(nil, ::T.untyped)
  IBM855_CharToOrderMap = ::T.let(nil, ::T.untyped)
  IBM866_CharToOrderMap = ::T.let(nil, ::T.untyped)
  ISO2022CNCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022CNSMModel = ::T.let(nil, ::T.untyped)
  ISO2022CN_cls = ::T.let(nil, ::T.untyped)
  ISO2022CN_st = ::T.let(nil, ::T.untyped)
  ISO2022JPCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022JPSMModel = ::T.let(nil, ::T.untyped)
  ISO2022JP_cls = ::T.let(nil, ::T.untyped)
  ISO2022JP_st = ::T.let(nil, ::T.untyped)
  ISO2022KRCharLenTable = ::T.let(nil, ::T.untyped)
  ISO2022KRSMModel = ::T.let(nil, ::T.untyped)
  ISO2022KR_cls = ::T.let(nil, ::T.untyped)
  ISO2022KR_st = ::T.let(nil, ::T.untyped)
  Ibm855Model = ::T.let(nil, ::T.untyped)
  Ibm866Model = ::T.let(nil, ::T.untyped)
  JISCharToFreqOrder = ::T.let(nil, ::T.untyped)
  JIS_TABLE_SIZE = ::T.let(nil, ::T.untyped)
  JIS_TYPICAL_DISTRIBUTION_RATIO = ::T.let(nil, ::T.untyped)
  JP2_CHAR_CONTEXT = ::T.let(nil, ::T.untyped)
  KOI8R_CharToOrderMap = ::T.let(nil, ::T.untyped)
  Koi8rModel = ::T.let(nil, ::T.untyped)
  LOGICAL_HEBREW_NAME = ::T.let(nil, ::T.untyped)
  Latin1ClassModel = ::T.let(nil, ::T.untyped)
  Latin1_CharToClass = ::T.let(nil, ::T.untyped)
  Latin2HungarianModel = ::T.let(nil, ::T.untyped)
  Latin2_HungarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Latin5BulgarianModel = ::T.let(nil, ::T.untyped)
  Latin5CyrillicModel = ::T.let(nil, ::T.untyped)
  Latin5_BulgarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Latin7GreekModel = ::T.let(nil, ::T.untyped)
  Latin7_CharToOrderMap = ::T.let(nil, ::T.untyped)
  MAX_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  MINIMUM_DATA_THRESHOLD = ::T.let(nil, ::T.untyped)
  MINIMUM_THRESHOLD = ::T.let(nil, ::T.untyped)
  MIN_FINAL_CHAR_DISTANCE = ::T.let(nil, ::T.untyped)
  MIN_MODEL_DISTANCE = ::T.let(nil, ::T.untyped)
  MacCyrillicModel = ::T.let(nil, ::T.untyped)
  NEGATIVE_SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  NORMAL_KAF = ::T.let(nil, ::T.untyped)
  NORMAL_MEM = ::T.let(nil, ::T.untyped)
  NORMAL_NUN = ::T.let(nil, ::T.untyped)
  NORMAL_PE = ::T.let(nil, ::T.untyped)
  NORMAL_TSADI = ::T.let(nil, ::T.untyped)
  NUMBER_OF_SEQ_CAT = ::T.let(nil, ::T.untyped)
  NUM_OF_CATEGORY = ::T.let(nil, ::T.untyped)
  ONE_CHAR_PROB = ::T.let(nil, ::T.untyped)
  OTH = ::T.let(nil, ::T.untyped)
  POSITIVE_CAT = ::T.let(nil, ::T.untyped)
  POSITIVE_SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  RussianLangModel = ::T.let(nil, ::T.untyped)
  SAMPLE_SIZE = ::T.let(nil, ::T.untyped)
  SB_ENOUGH_REL_THRESHOLD = ::T.let(nil, ::T.untyped)
  SHORTCUT_THRESHOLD = ::T.let(nil, ::T.untyped)
  SJISCharLenTable = ::T.let(nil, ::T.untyped)
  SJISSMModel = ::T.let(nil, ::T.untyped)
  SJIS_cls = ::T.let(nil, ::T.untyped)
  SJIS_st = ::T.let(nil, ::T.untyped)
  SURE_NO = ::T.let(nil, ::T.untyped)
  SURE_YES = ::T.let(nil, ::T.untyped)
  SYMBOL_CAT_ORDER = ::T.let(nil, ::T.untyped)
  TIS620CharToOrderMap = ::T.let(nil, ::T.untyped)
  TIS620ThaiModel = ::T.let(nil, ::T.untyped)
  ThaiLangModel = ::T.let(nil, ::T.untyped)
  UCS2BECharLenTable = ::T.let(nil, ::T.untyped)
  UCS2BESMModel = ::T.let(nil, ::T.untyped)
  UCS2BE_cls = ::T.let(nil, ::T.untyped)
  UCS2BE_st = ::T.let(nil, ::T.untyped)
  UCS2LECharLenTable = ::T.let(nil, ::T.untyped)
  UCS2LESMModel = ::T.let(nil, ::T.untyped)
  UCS2LE_cls = ::T.let(nil, ::T.untyped)
  UCS2LE_st = ::T.let(nil, ::T.untyped)
  UDF = ::T.let(nil, ::T.untyped)
  UTF8CharLenTable = ::T.let(nil, ::T.untyped)
  UTF8SMModel = ::T.let(nil, ::T.untyped)
  UTF8_cls = ::T.let(nil, ::T.untyped)
  UTF8_st = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISUAL_HEBREW_NAME = ::T.let(nil, ::T.untyped)
  Win1250HungarianCharToOrderMap = ::T.let(nil, ::T.untyped)
  Win1250HungarianModel = ::T.let(nil, ::T.untyped)
  Win1251BulgarianModel = ::T.let(nil, ::T.untyped)
  Win1251CyrillicModel = ::T.let(nil, ::T.untyped)
  Win1253GreekModel = ::T.let(nil, ::T.untyped)
  Win1253_CharToOrderMap = ::T.let(nil, ::T.untyped)
  Win1255HebrewModel = ::T.let(nil, ::T.untyped)
  Win1255_CharToOrderMap = ::T.let(nil, ::T.untyped)
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractIO
  def _stdin=(io); end

  def inherit!(); end

  def stderr(); end

  def stderr=(io); end

  def stdin(); end

  def stdout(); end

  def stdout=(io); end
end

class ChildProcess::AbstractProcess
  def alive?(); end

  def crashed?(); end

  def cwd(); end

  def cwd=(cwd); end

  def detach(); end

  def detach=(detach); end

  def duplex(); end

  def duplex=(duplex); end

  def environment(); end

  def exit_code(); end

  def exited?(); end

  def initialize(args); end

  def io(); end

  def leader(); end

  def leader=(leader); end

  def pid(); end

  def poll_for_exit(timeout); end

  def start(); end

  def started?(); end

  def stop(timeout=T.unsafe(nil)); end

  def wait(); end
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ChildProcess::MissingFFIError
  def initialize(); end
end

class ChildProcess::MissingPlatformError
  def initialize(); end
end

module ChildProcess
  def self.arch(); end

  def self.build(*args); end

  def self.close_on_exec(file); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.new(*args); end

  def self.os(); end

  def self.platform(); end

  def self.platform_name(); end

  def self.posix_spawn=(bool); end

  def self.posix_spawn?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class Class
  def json_creatable?(); end
end

module CodeAnalyzer
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeAnalyzer::AnalyzerException
end

class CodeAnalyzer::AnalyzerException
end

class CodeAnalyzer::Checker
  def add_warning(message, filename=T.unsafe(nil), line_number=T.unsafe(nil)); end

  def interesting_files(); end

  def interesting_nodes(); end

  def node_end(node); end

  def node_start(node); end

  def parse_file?(node_file); end

  def warnings(); end
end

class CodeAnalyzer::Checker
  def self.add_callback(*names, &block); end

  def self.callbacks(); end

  def self.get_callbacks(name); end

  def self.interesting_files(*file_patterns); end

  def self.interesting_nodes(*nodes); end
end

module CodeAnalyzer::CheckingVisitor
end

class CodeAnalyzer::CheckingVisitor::Base
  def after_check(); end

  def initialize(options=T.unsafe(nil)); end

  def warnings(); end
end

class CodeAnalyzer::CheckingVisitor::Base
end

class CodeAnalyzer::CheckingVisitor::Default
  def check(filename, content); end

  def check_node(node); end

  def parse(filename, content); end
end

class CodeAnalyzer::CheckingVisitor::Default
end

class CodeAnalyzer::CheckingVisitor::Plain
  def check(filename, content); end
end

class CodeAnalyzer::CheckingVisitor::Plain
end

module CodeAnalyzer::CheckingVisitor
end

class CodeAnalyzer::Nil
  def array_size(); end

  def hash_size(); end

  def method_missing(method_sym, *arguments, &block); end
end

class CodeAnalyzer::Warning
  def filename(); end

  def initialize(options=T.unsafe(nil)); end

  def line_number(); end

  def message(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*arg, **arg1); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
end

class CodeRay::Scanners::Java
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Ruby
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*arg); end

  def to_s(); end

  def tokens(*arg); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

class CodeRay::WordList::CaseIgnoring
end

class CodeRay::WordList
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

module Colored2
  COLORS = ::T.let(nil, ::T.untyped)
  EFFECTS = ::T.let(nil, ::T.untyped)
end

class Complex
  def to_d(*args); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Cork
  VERSION = ::T.let(nil, ::T.untyped)
end

module Coverage
  def self.resume(); end

  def self.setup(*arg); end

  def self.state(); end

  def self.suspend(); end
end

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__
  CONFIG = ::T.let(nil, ::T.untyped)
  CONFIG_MAP = ::T.let(nil, ::T.untyped)
  CONFIG_SET = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
  METHOD_ADDED_TRACKER = ::T.let(nil, ::T.untyped)
  SESSION = ::T.let(nil, ::T.untyped)
  SHORT_INSPECT_LENGTH = ::T.let(nil, ::T.untyped)
  SO_VERSION = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::Color
  SUPPORT_COLORABLE_OPTION = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Console
  def deactivate(); end

  def history(); end

  def history_file(); end

  def load_history(); end

  def load_history_if_not_loaded(); end

  def parse_input(buff, commands); end

  def read_history_file(); end

  def readline(prompt); end

  def readline_setup(prompt); end
  FH = ::T.let(nil, ::T.untyped)
  SIGWINCH_SUPPORTED = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::ForkInterceptor
  def _fork(); end
end

class DEBUGGER__::FrameInfo
  BLOCK_LABL_REGEXP = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Session
  BREAK_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::ThreadClient
  SKIP_GLOBAL_LIST = ::T.let(nil, ::T.untyped)
  SPECIAL_LOCAL_VARS = ::T.let(nil, ::T.untyped)
  SUPPORT_TARGET_THREAD = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::TrapInterceptor
  def trap(sig, *command, &command_proc); end
end

class DEBUGGER__::UI_LocalConsole
  def activate(session, on_fork: T.unsafe(nil)); end

  def after_fork_parent(); end

  def ask(prompt); end

  def deactivate(); end

  def puts(str=T.unsafe(nil)); end

  def quit(n); end

  def readline(prompt=T.unsafe(nil)); end

  def remote?(); end

  def setup_interrupt(); end

  def width(); end
end

module DEBUGGER__
  def self.compare_path(a, b); end

  def self.info(msg); end

  def self.log(level, msg); end

  def self.method_added(tp); end

  def self.safe_inspect(obj, max_length: T.unsafe(nil), short: T.unsafe(nil)); end

  def self.step_in(&b); end

  def self.warn(msg); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

module Danger
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  GEM_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Danger::EmojiMapper
  DATA = ::T.let(nil, ::T.untyped)
  TYPE_TO_EMOJI = ::T.let(nil, ::T.untyped)
end

class Danger::FindRepoInfoFromURL
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXPBB = ::T.let(nil, ::T.untyped)
end

module Danger::Helpers::CommentsParsingHelper
  GITHUB_OLD_REGEX = ::T.let(nil, ::T.untyped)
  NEW_REGEX = ::T.let(nil, ::T.untyped)
end

class Danger::LocalOnlyGitRepo
  BASE_VAR = ::T.let(nil, ::T.untyped)
  HEAD_VAR = ::T.let(nil, ::T.untyped)
end

class Danger::PrySetup
  DANGERFILE_COPY = ::T.let(nil, ::T.untyped)
end

class Danger::RequestSources::GitHubSource::Review
  EVENT_APPROVE = ::T.let(nil, ::T.untyped)
  EVENT_COMMENT = ::T.let(nil, ::T.untyped)
  EVENT_REQUEST_CHANGES = ::T.let(nil, ::T.untyped)
  STATUS_APPROVED = ::T.let(nil, ::T.untyped)
  STATUS_COMMENTED = ::T.let(nil, ::T.untyped)
  STATUS_PENDING = ::T.let(nil, ::T.untyped)
  STATUS_REQUESTED_CHANGES = ::T.let(nil, ::T.untyped)
end

class Danger::RequestSources::GitLab
  FIRST_GITLAB_GEM_WITH_VERSION_CHECK = ::T.let(nil, ::T.untyped)
  FIRST_VERSION_WITH_INLINE_COMMENTS = ::T.let(nil, ::T.untyped)
end

class Danger::RequestSources::RequestSource
  DANGER_REPO_NAME = ::T.let(nil, ::T.untyped)
end

class Danger::Violation
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

module Dartsass
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date
  def infinite?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DateTime
  def acts_like_time?(); end
end

class DateTime
  def self.new(*arg); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Devise
  ALL = ::T.let(nil, ::T.untyped)
  CONTROLLERS = ::T.let(nil, ::T.untyped)
  NO_INPUT = ::T.let(nil, ::T.untyped)
  ROUTES = ::T.let(nil, ::T.untyped)
  STRATEGIES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
  URL_HELPERS = ::T.let(nil, ::T.untyped)
end

class Devise::ConfirmationsController
  def after_confirmation_path_for(resource_name, resource); end

  def after_resending_confirmation_instructions_path_for(resource_name); end

  def create(); end

  def new(); end

  def show(); end
end

module Devise::Controllers::Helpers
  def authenticate_user!(opts=T.unsafe(nil)); end

  def current_user(); end

  def user_session(); end

  def user_signed_in?(); end
end

module Devise::Controllers::Rememberable
  def forget_cookie_values(resource); end

  def forget_me(resource); end

  def remember_cookie_values(resource); end

  def remember_key(resource, scope); end

  def remember_me(resource); end

  def remember_me_is_active?(resource); end
end

module Devise::Controllers::Rememberable
  def self.cookie_values(); end
end

module Devise::Controllers::UrlHelpers
  def cancel_registration_path(resource_or_scope, *args); end

  def cancel_registration_url(resource_or_scope, *args); end

  def confirmation_path(resource_or_scope, *args); end

  def confirmation_url(resource_or_scope, *args); end

  def destroy_session_path(resource_or_scope, *args); end

  def destroy_session_url(resource_or_scope, *args); end

  def edit_password_path(resource_or_scope, *args); end

  def edit_password_url(resource_or_scope, *args); end

  def edit_registration_path(resource_or_scope, *args); end

  def edit_registration_url(resource_or_scope, *args); end

  def new_confirmation_path(resource_or_scope, *args); end

  def new_confirmation_url(resource_or_scope, *args); end

  def new_password_path(resource_or_scope, *args); end

  def new_password_url(resource_or_scope, *args); end

  def new_registration_path(resource_or_scope, *args); end

  def new_registration_url(resource_or_scope, *args); end

  def new_session_path(resource_or_scope, *args); end

  def new_session_url(resource_or_scope, *args); end

  def new_unlock_path(resource_or_scope, *args); end

  def new_unlock_url(resource_or_scope, *args); end

  def password_path(resource_or_scope, *args); end

  def password_url(resource_or_scope, *args); end

  def registration_path(resource_or_scope, *args); end

  def registration_url(resource_or_scope, *args); end

  def session_path(resource_or_scope, *args); end

  def session_url(resource_or_scope, *args); end

  def unlock_path(resource_or_scope, *args); end

  def unlock_url(resource_or_scope, *args); end
end

module Devise::Controllers::UrlHelpers
  def self.generate_helpers!(routes=T.unsafe(nil)); end

  def self.remove_helpers!(); end
end

class Devise::Delegator
  def call(env); end

  def failure_app(env); end
end

Devise::DeprecatedConstantAccessor = ActiveSupport::Deprecation::DeprecatedConstantAccessor

module Devise::Encryptor
  def self.compare(klass, hashed_password, password); end

  def self.digest(klass, password); end
end

class Devise::FailureApp
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::ActionController::Redirecting
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def attempted_path(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def flash(*arg, **arg1, &arg2); end

  def http_auth(); end

  def http_auth?(); end

  def http_auth_body(); end

  def http_auth_header?(); end

  def i18n_message(default=T.unsafe(nil)); end

  def i18n_options(options); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def logger(); end

  def logger=(value); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def recall(); end

  def recall_app(app); end

  def recall_response_code(_original_response_code); end

  def redirect(); end

  def redirect_url(); end

  def relative_url_root(); end

  def relative_url_root?(); end

  def request_format(); end

  def respond(); end

  def route(scope); end

  def scope(); end

  def scope_class(); end

  def scope_url(); end

  def skip_format?(); end

  def store_location!(); end

  def warden(); end

  def warden_message(); end

  def warden_options(); end
end

class Devise::FailureApp
  extend ::AbstractController::UrlFor::ClassMethods
  def self.call(env); end

  def self.default_url_options(*args); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end
end

class Devise::Hooks::Proxy
  include ::Devise::Controllers::Rememberable
  include ::Devise::Controllers::SignInOut
  def cookies(*arg, **arg1, &arg2); end

  def initialize(warden); end

  def request(*arg, **arg1, &arg2); end

  def session(); end

  def warden(); end
end

class Devise::Hooks::Proxy
end

class Devise::Mailer
  def confirmation_instructions(record, token, opts=T.unsafe(nil)); end

  def email_changed(record, opts=T.unsafe(nil)); end

  def password_change(record, opts=T.unsafe(nil)); end

  def reset_password_instructions(record, token, opts=T.unsafe(nil)); end

  def unlock_instructions(record, token, opts=T.unsafe(nil)); end
end

module Devise::Mailers::Helpers
  def devise_mail(record, action, opts=T.unsafe(nil), &block); end

  def devise_mapping(); end

  def headers_for(action, opts); end

  def initialize_from_record(record); end

  def mailer_from(mapping); end

  def mailer_reply_to(mapping); end

  def mailer_sender(mapping, sender=T.unsafe(nil)); end

  def resource(); end

  def scope_name(); end

  def subject_for(key); end

  def template_paths(); end
end

module Devise::Models::Authenticatable
  UNSAFE_ATTRIBUTES_FOR_SERIALIZATION = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Confirmable
  def active_for_authentication?(); end

  def after_confirmation(); end

  def confirm(args=T.unsafe(nil)); end

  def confirmation_period_expired?(); end

  def confirmation_period_valid?(); end

  def confirmation_required?(); end

  def confirmed?(); end

  def generate_confirmation_token(); end

  def generate_confirmation_token!(); end

  def inactive_message(); end

  def initialize(*args, &block); end

  def pending_any_confirmation(); end

  def pending_reconfirmation?(); end

  def postpone_email_change?(); end

  def postpone_email_change_until_confirmation_and_regenerate_confirmation_token(); end

  def reconfirmation_required?(); end

  def resend_confirmation_instructions(); end

  def send_confirmation_instructions(); end

  def send_confirmation_notification?(); end

  def send_email_changed_notification?(); end

  def send_on_create_confirmation_instructions(); end

  def send_reconfirmation_instructions(); end

  def skip_confirmation!(); end

  def skip_confirmation_notification!(); end

  def skip_reconfirmation!(); end

  def skip_reconfirmation_in_callback!(); end
end

module Devise::Models::Confirmable::ClassMethods
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(value); end

  def confirm_by_token(confirmation_token); end

  def confirm_within(); end

  def confirm_within=(value); end

  def confirmation_keys(); end

  def confirmation_keys=(value); end

  def find_by_unconfirmed_email_with_errors(attributes=T.unsafe(nil)); end

  def reconfirmable(); end

  def reconfirmable=(value); end

  def send_confirmation_instructions(attributes=T.unsafe(nil)); end
end

module Devise::Models::Confirmable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Confirmable
  def self.required_fields(klass); end
end

module Devise::Models::DatabaseAuthenticatable
  def after_database_authentication(); end

  def authenticatable_salt(); end

  def clean_up_passwords(); end

  def destroy_with_password(current_password); end

  def initialize(*args, &block); end

  def password=(new_password); end

  def password_digest(password); end

  def send_email_changed_notification(); end

  def send_email_changed_notification?(); end

  def send_password_change_notification(); end

  def send_password_change_notification?(); end

  def skip_email_changed_notification!(); end

  def skip_password_change_notification!(); end

  def update_with_password(params, *options); end

  def update_without_password(params, *options); end

  def valid_password?(password); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def find_for_database_authentication(conditions); end

  def pepper(); end

  def pepper=(value); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(value); end

  def send_password_change_notification(); end

  def send_password_change_notification=(value); end

  def stretches(); end

  def stretches=(value); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::DatabaseAuthenticatable
  def self.required_fields(klass); end
end

module Devise::Models::Lockable
  def access_locked?(); end

  def active_for_authentication?(); end

  def attempts_exceeded?(); end

  def if_access_locked(); end

  def inactive_message(); end

  def increment_failed_attempts(); end

  def last_attempt?(); end

  def lock_access!(opts=T.unsafe(nil)); end

  def lock_expired?(); end

  def lock_strategy_enabled?(*arg, **arg1, &arg2); end

  def resend_unlock_instructions(); end

  def reset_failed_attempts!(); end

  def send_unlock_instructions(); end

  def unauthenticated_message(); end

  def unlock_access!(); end

  def unlock_strategy_enabled?(*arg, **arg1, &arg2); end

  def valid_for_authentication?(); end
end

module Devise::Models::Lockable::ClassMethods
  def last_attempt_warning(); end

  def last_attempt_warning=(value); end

  def lock_strategy(); end

  def lock_strategy=(value); end

  def lock_strategy_enabled?(strategy); end

  def maximum_attempts(); end

  def maximum_attempts=(value); end

  def send_unlock_instructions(attributes=T.unsafe(nil)); end

  def unlock_access_by_token(unlock_token); end

  def unlock_in(); end

  def unlock_in=(value); end

  def unlock_keys(); end

  def unlock_keys=(value); end

  def unlock_strategy(); end

  def unlock_strategy=(value); end

  def unlock_strategy_enabled?(strategy); end
  BOTH_STRATEGIES = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Lockable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Lockable
  def self.required_fields(klass); end
end

module Devise::Models::Recoverable
  def clear_reset_password_token(); end

  def clear_reset_password_token?(); end

  def reset_password(new_password, new_password_confirmation); end

  def reset_password_period_valid?(); end

  def send_reset_password_instructions(); end

  def send_reset_password_instructions_notification(token); end

  def set_reset_password_token(); end
end

module Devise::Models::Recoverable::ClassMethods
  def reset_password_by_token(attributes=T.unsafe(nil)); end

  def reset_password_keys(); end

  def reset_password_keys=(value); end

  def reset_password_within(); end

  def reset_password_within=(value); end

  def send_reset_password_instructions(attributes=T.unsafe(nil)); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(value); end

  def with_reset_password_token(token); end
end

module Devise::Models::Recoverable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Recoverable
  def self.required_fields(klass); end
end

module Devise::Models::Registerable::ClassMethods
  def new_with_session(params, session); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(value); end
end

module Devise::Models::Registerable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Registerable
  def self.required_fields(klass); end
end

module Devise::Models::Rememberable
  def after_remembered(); end

  def extend_remember_period(); end

  def forget_me!(); end

  def remember_expires_at(); end

  def remember_me(); end

  def remember_me!(); end

  def remember_me=(remember_me); end

  def remember_me?(token, generated_at); end

  def rememberable_options(); end

  def rememberable_value(); end
end

module Devise::Models::Rememberable::ClassMethods
  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(value); end

  def extend_remember_period(); end

  def extend_remember_period=(value); end

  def remember_for(); end

  def remember_for=(value); end

  def remember_token(); end

  def rememberable_options(); end

  def rememberable_options=(value); end

  def serialize_from_cookie(*args); end

  def serialize_into_cookie(record); end
end

module Devise::Models::Rememberable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Rememberable
  def self.required_fields(klass); end
end

module Devise::Models::Timeoutable
  def timedout?(last_access); end

  def timeout_in(); end
end

module Devise::Models::Timeoutable::ClassMethods
  def timeout_in(); end

  def timeout_in=(value); end
end

module Devise::Models::Timeoutable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Timeoutable
  def self.required_fields(klass); end
end

module Devise::Models::Trackable
  def extract_ip_from(request); end

  def update_tracked_fields(request); end

  def update_tracked_fields!(request); end
end

module Devise::Models::Trackable
  def self.required_fields(klass); end
end

module Devise::Models::Validatable
  def email_required?(); end

  def password_required?(); end
  VALIDATIONS = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Validatable::ClassMethods
  def email_regexp(); end

  def email_regexp=(value); end

  def password_length(); end

  def password_length=(value); end
end

module Devise::Models::Validatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Validatable
  def self.assert_validations_api!(base); end

  def self.included(base); end

  def self.required_fields(klass); end
end

class Devise::OmniauthCallbacksController
  def after_omniauth_failure_path_for(scope); end

  def failed_strategy(); end

  def failure(); end

  def failure_message(); end

  def passthru(); end
end

class Devise::ParameterFilter
  def filter(conditions); end

  def filtered_hash_by_method_for_given_keys(conditions, method, condition_keys); end

  def initialize(case_insensitive_keys, strip_whitespace_keys); end

  def stringify_params(conditions); end
end

class Devise::ParameterFilter
end

class Devise::ParameterSanitizer
  def initialize(resource_class, resource_name, params); end

  def permit(action, keys: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def sanitize(action); end
  DEFAULT_PERMITTED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Devise::ParameterSanitizer
end

class Devise::PasswordsController
  def after_resetting_password_path_for(resource); end

  def after_sending_reset_password_instructions_path_for(resource_name); end

  def assert_reset_token_passed(); end

  def create(); end

  def edit(); end

  def new(); end

  def unlockable?(resource); end

  def update(); end
end

class Devise::RegistrationsController
  def account_update_params(); end

  def after_inactive_sign_up_path_for(resource); end

  def after_sign_up_path_for(resource); end

  def after_update_path_for(resource); end

  def authenticate_scope!(); end

  def build_resource(hash=T.unsafe(nil)); end

  def cancel(); end

  def create(); end

  def destroy(); end

  def edit(); end

  def new(); end

  def sign_up(resource_name, resource); end

  def sign_up_params(); end

  def update(); end

  def update_needs_confirmation?(resource, previous); end

  def update_resource(resource, params); end
end

class Devise::SecretKeyFinder
  def find(); end

  def initialize(application); end
end

class Devise::SessionsController
  def auth_options(); end

  def create(); end

  def destroy(); end

  def new(); end

  def serialize_options(resource); end

  def sign_in_params(); end
end

class Devise::Strategies::Authenticatable
  def authentication_hash(); end

  def authentication_hash=(authentication_hash); end

  def authentication_type(); end

  def authentication_type=(authentication_type); end

  def clean_up_csrf?(); end

  def password(); end

  def password=(password); end
end

class Devise::Strategies::Base
  def mapping(); end
end

class Devise::Strategies::DatabaseAuthenticatable
  def authenticate!(); end
end

class Devise::Strategies::Rememberable
  def authenticate!(); end
end

module Devise::Test::ControllerHelpers
  def _catch_warden(&block); end

  def _process_unauthenticated(env, options=T.unsafe(nil)); end

  def process(*arg, **arg1); end

  def setup_controller_for_warden(); end

  def sign_in(resource, deprecated=T.unsafe(nil), scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def warden(); end
end

module Devise::Test::ControllerHelpers
  extend ::ActiveSupport::Concern
end

module Devise::Test::IntegrationHelpers
  def setup_integration_for_devise(); end

  def sign_in(resource, scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def teardown_integration_for_devise(); end
end

module Devise::Test::IntegrationHelpers
  def self.included(base); end
end

module Devise::TestHelpers
end

module Devise::TestHelpers
  def self.included(base); end
end

class Devise::TimeInflector
  include ::ActionView::Helpers::DateHelper
end

class Devise::TimeInflector
  def self.instance(); end

  def self.time_ago_in_words(*arg, **arg1, &arg2); end
end

class Devise::TokenGenerator
  def digest(klass, column, value); end

  def generate(klass, column); end

  def initialize(key_generator, digest=T.unsafe(nil)); end
end

class Devise::UnlocksController
  def after_sending_unlock_instructions_path_for(resource); end

  def after_unlock_path_for(resource); end

  def create(); end

  def new(); end

  def show(); end
end

class DeviseController
  def assert_is_devise_resource!(); end

  def clean_up_passwords(object); end

  def devise_i18n_options(options); end

  def devise_mapping(); end

  def find_message(kind, options=T.unsafe(nil)); end

  def navigational_formats(); end

  def require_no_authentication(); end

  def resource(); end

  def resource=(new_resource); end

  def resource_class(); end

  def resource_name(); end

  def resource_params(); end

  def respond_with_navigational(*args, &block); end

  def scope_name(); end

  def set_flash_message(key, kind, options=T.unsafe(nil)); end

  def set_flash_message!(key, kind, options=T.unsafe(nil)); end

  def set_minimum_password_length(); end

  def signed_in_resource(); end

  def successfully_sent?(resource); end

  def translation_scope(); end

  def unknown_action!(msg); end
end

module DeviseController::HelperMethods
  include ::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::ApplicationHelper
  include ::Pagy::Frontend
  include ::Pagy::UrlHelpers
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
  include ::PreviewHelper
  include ::DeviseHelper
  def devise_mapping(*args, **arg, &block); end

  def resource(*args, **arg, &block); end

  def resource_class(*args, **arg, &block); end

  def resource_name(*args, **arg, &block); end

  def resource_params(*args, **arg, &block); end

  def scope_name(*args, **arg, &block); end

  def signed_in_resource(*args, **arg, &block); end
end

module DeviseHelper
  def devise_error_messages!(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Diff::LCS
  def diff(other, callbacks=T.unsafe(nil), &block); end

  def lcs(other, &block); end

  def patch(patchset); end

  def patch!(patchset); end

  def patch_me(patchset); end

  def sdiff(other, callbacks=T.unsafe(nil), &block); end

  def traverse_balanced(other, callbacks=T.unsafe(nil), &block); end

  def traverse_sequences(other, callbacks=T.unsafe(nil), &block); end

  def unpatch(patchset); end

  def unpatch!(patchset); end

  def unpatch_me(patchset); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Block
  def changes(); end

  def diff_size(); end

  def initialize(chunk); end

  def insert(); end

  def op(); end

  def remove(); end
end

class Diff::LCS::Change
  def ==(other); end

  def action(); end

  def adding?(); end

  def changed?(); end

  def deleting?(); end

  def element(); end

  def finished_a?(); end

  def finished_b?(); end

  def initialize(*args); end

  def inspect(*_args); end

  def position(); end

  def to_a(); end

  def to_ary(); end

  def unchanged?(); end
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

class Diff::LCS::Change
  def self.from_a(arr); end

  def self.valid_action?(action); end
end

class Diff::LCS::ContextChange
  def new_element(); end

  def new_position(); end

  def old_element(); end

  def old_position(); end
end

class Diff::LCS::ContextChange
  def self.simplify(event); end
end

class Diff::LCS::ContextDiffCallbacks
  def change(event); end
end

class Diff::LCS::DefaultCallbacks
  def self.change(event); end

  def self.discard_a(event); end

  def self.discard_b(event); end

  def self.match(event); end
end

class Diff::LCS::DiffCallbacks
  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def finish(); end

  def match(_event); end
end

class Diff::LCS::Hunk
  def blocks(); end

  def diff(format, last=T.unsafe(nil)); end

  def end_new(); end

  def end_old(); end

  def file_length_difference(); end

  def flag_context(); end

  def flag_context=(context); end

  def initialize(data_old, data_new, piece, flag_context, file_length_difference); end

  def merge(hunk); end

  def missing_last_newline?(data); end

  def overlaps?(hunk); end

  def start_new(); end

  def start_old(); end

  def unshift(hunk); end
end

module Diff::LCS::Internals
  def self.analyze_patchset(patchset, depth=T.unsafe(nil)); end

  def self.intuit_diff_direction(src, patchset, limit=T.unsafe(nil)); end

  def self.lcs(a, b); end
end

class Diff::LCS::SDiffCallbacks
  def change(event); end

  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def match(event); end
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.callbacks_for(callbacks); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.unpatch!(src, patchset); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.use_rfc4122_namespaced_uuids(); end

  def self.use_rfc4122_namespaced_uuids=(val); end

  def self.uuid_from_hash(hash_class, namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(arg); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
  def backtrace(); end

  def backtrace_locations(); end
  FILTER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, **arg, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, **arg, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

module Docile
  def self.dsl_eval(dsl, *args, **arg, &block); end

  def self.dsl_eval_immutable(dsl, *args, **arg, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, **arg, &block); end
end

class Dotenv::Environment
  def apply(); end

  def apply!(); end

  def filename(); end

  def initialize(filename, is_load=T.unsafe(nil)); end

  def load(is_load=T.unsafe(nil)); end

  def read(); end
end

class Dotenv::MissingKeys
  def initialize(keys); end
end

class Dotenv::Parser
  def call(); end

  def initialize(string, is_load=T.unsafe(nil)); end
  LINE = ::T.let(nil, ::T.untyped)
end

class Dotenv::Parser
  def self.call(string, is_load=T.unsafe(nil)); end

  def self.substitutions(); end
end

class Dotenv::Railtie
  def load(); end

  def overload(); end

  def root(); end
end

class Dotenv::Railtie
  def self.load(); end
end

module Dotenv::Substitutions::Command
  def self.call(value, _env, _is_load); end
end

module Dotenv::Substitutions::Variable
  def self.call(value, env, is_load); end
end

module Dotenv
  def self.ignoring_nonexistent_files(); end

  def self.instrument(name, payload=T.unsafe(nil), &block); end

  def self.instrumenter(); end

  def self.instrumenter=(instrumenter); end

  def self.load(*filenames); end

  def self.load!(*filenames); end

  def self.overload(*filenames); end

  def self.overload!(*filenames); end

  def self.parse(*filenames); end

  def self.require_keys(*keys); end

  def self.with(*filenames); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module Ed25519
  KEY_SIZE = ::T.let(nil, ::T.untyped)
  SIGNATURE_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Ed25519::Provider
end

module Ed25519::Provider::Ref10
end

module Ed25519::Provider::Ref10
  def self.create_keypair(arg); end

  def self.sign(arg, arg1); end

  def self.verify(arg, arg1, arg2); end
end

module Ed25519::Provider
end

class Ed25519::SigningKey
  def initialize(seed); end

  def keypair(); end

  def seed(); end

  def sign(message); end

  def to_bytes(); end

  def to_str(); end

  def verify_key(); end
end

class Ed25519::SigningKey
  def self.from_keypair(keypair); end

  def self.generate(); end
end

class Ed25519::VerifyKey
  def initialize(key); end

  def to_bytes(); end

  def to_str(); end

  def verify(signature, message); end
end

module Ed25519
  def self.provider(); end

  def self.provider=(provider); end

  def self.self_test(); end

  def self.validate_key_bytes(key_bytes); end
end

class Encoding
  def _dump(*arg); end
  CESU_8 = ::T.let(nil, ::T.untyped)
  CP720 = ::T.let(nil, ::T.untyped)
  IBM720 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*arg); end
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def compact(); end

  def sum(identity=T.unsafe(nil), &block); end
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  MATCH_METHOD = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Erubis
  EMPTY_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Erubis::ArrayBufferEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ArrayBufferEnhancer
  def self.desc(); end
end

module Erubis::ArrayEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ArrayEnhancer
  def self.desc(); end
end

module Erubis::Basic::Converter
  def add_expr(src, code, indicator); end

  def convert_input(src, input); end

  def init_converter(properties=T.unsafe(nil)); end

  def pattern(); end

  def pattern=(pattern); end

  def trim(); end

  def trim=(trim); end
  DEFAULT_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubis::Basic::Converter
  def self.pattern_regexp(pattern); end

  def self.supported_properties(); end
end

module Erubis::BiPatternEnhancer
  def add_text(src, text); end

  def bipattern=(pat); end

  def initialize(input, properties=T.unsafe(nil)); end
end

module Erubis::BiPatternEnhancer
  def self.desc(); end
end

class Erubis::Context
  def [](key); end

  def []=(key, value); end

  def each(&blk); end

  def initialize(hash=T.unsafe(nil)); end

  def keys(); end

  def to_hash(); end

  def update(context_or_hash); end
end

module Erubis::Converter
  def convert(input); end

  def convert_input(codebuf, input); end

  def detect_spaces_at_bol(text, is_bol); end

  def escape(); end

  def escape=(escape); end

  def init_converter(properties=T.unsafe(nil)); end

  def postamble(); end

  def postamble=(postamble); end

  def preamble(); end

  def preamble=(preamble); end
end

module Erubis::Converter
  def self.supported_properties(); end
end

module Erubis::DeleteIndentEnhancer
  def convert_input(src, input); end
end

module Erubis::DeleteIndentEnhancer
  def self.desc(); end
end

class Erubis::Engine
  def convert!(input); end

  def initialize(input=T.unsafe(nil), properties=T.unsafe(nil)); end

  def process(input, context=T.unsafe(nil), filename=T.unsafe(nil)); end

  def process_proc(proc_obj, context=T.unsafe(nil), filename=T.unsafe(nil)); end
end

class Erubis::Engine
  def self.load_file(filename, properties=T.unsafe(nil)); end
end

module Erubis::ErboutEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ErboutEnhancer
  def self.desc(); end
end

module Erubis::EscapeEnhancer
  def add_expr(src, code, indicator); end
end

module Erubis::EscapeEnhancer
  def self.desc(); end
end

module Erubis::Evaluator
  def evaluate(*args); end

  def filename(); end

  def filename=(filename); end

  def init_evaluator(properties); end

  def result(*args); end

  def src(); end

  def src=(src); end
end

module Erubis::Evaluator
  def self.supported_properties(); end
end

module Erubis::Generator
  def add_expr_debug(src, code); end

  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_stmt(src, code); end

  def add_text(src, text); end

  def escape_text(text); end

  def escaped_expr(code); end

  def escapefunc(); end

  def escapefunc=(escapefunc); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::Generator
  def self.supported_properties(); end
end

module Erubis::HeaderFooterEnhancer
  def add_text(src, text); end

  def convert(input); end

  def footer(); end

  def footer=(footer); end

  def header(); end

  def header=(header); end
  HEADER_FOOTER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Erubis::HeaderFooterEnhancer
  def self.desc(); end
end

module Erubis::InterpolationEnhancer
  def _add_text_to_str(str, text); end

  def add_expr_escaped(str, code); end

  def add_expr_literal(str, code); end

  def add_text(src, text); end

  def convert_input(src, input); end
end

module Erubis::InterpolationEnhancer
  def self.desc(); end
end

module Erubis::NoCodeEnhancer
  def add_expr(src, code, indicator); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_stmt(src, code); end

  def add_text(src, text); end
end

module Erubis::NoCodeEnhancer
  def self.desc(); end
end

module Erubis::NoTextEnhancer
  def add_text(src, text); end
end

module Erubis::NoTextEnhancer
  def self.desc(); end
end

module Erubis::PI::Converter
  def add_pi_expr(codebuf, code, indicator); end

  def add_pi_stmt(codebuf, code, pi_arg); end

  def convert(input); end

  def convert_input(codebuf, input); end

  def init_converter(properties=T.unsafe(nil)); end

  def pi(); end

  def pi=(pi); end

  def prefix(); end

  def prefix=(prefix); end
end

module Erubis::PI::Converter
  def self.desc(); end

  def self.supported_properties(); end
end

class Erubis::PI::TinyEruby
  EMBEDDED_PATTERN = ::T.let(nil, ::T.untyped)
end

module Erubis::PercentLineEnhancer
  def add_text(src, text); end
end

module Erubis::PercentLineEnhancer
  def self.desc(); end
end

module Erubis::PrefixedLineEnhancer
  def add_text(src, text); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::PrefixedLineEnhancer
  def self.desc(); end
end

module Erubis::PrintEnabledEnhancer
  def add_preamble(src); end

  def evaluate(context=T.unsafe(nil)); end

  def print(*args); end
end

module Erubis::PrintEnabledEnhancer
  def self.desc(); end
end

module Erubis::PrintOutEnhancer
  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_text(src, text); end
end

module Erubis::PrintOutEnhancer
  def self.desc(); end
end

module Erubis::RubyEvaluator
  def def_method(object, method_name, filename=T.unsafe(nil)); end

  def evaluate(_context=T.unsafe(nil)); end

  def result(_binding_or_hash=T.unsafe(nil)); end
end

module Erubis::RubyEvaluator
  def self.supported_properties(); end
end

module Erubis::RubyGenerator
  def add_expr_debug(src, code); end

  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_stmt(src, code); end

  def add_text(src, text); end

  def escape_text(text); end

  def escaped_expr(code); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::RubyGenerator
  def self.supported_properties(); end
end

module Erubis::SimplifyEnhancer
  def convert(input); end
  SIMPLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubis::SimplifyEnhancer
  def self.desc(); end
end

module Erubis::StdoutEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StdoutEnhancer
  def self.desc(); end
end

module Erubis::StringBufferEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StringBufferEnhancer
  def self.desc(); end
end

module Erubis::StringIOEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StringIOEnhancer
  def self.desc(); end
end

class Erubis::TinyEruby
  EMBEDDED_PATTERN = ::T.let(nil, ::T.untyped)
end

module Erubis::XmlHelper
  ESCAPE_TABLE = ::T.let(nil, ::T.untyped)
end

module Erubis::XmlHelper
  def self.escape_xml(value); end

  def self.escape_xml2(value); end

  def self.url_encode(str); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Exception
  include ::BetterErrors::ExceptionExtension
  def __bb_context(); end

  def binding_locations(); end

  def bindings(); end
end

class ExceptionForMatrix::ErrDimensionMismatch
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrNotRegular
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrOperationNotDefined
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotImplemented
  def initialize(vals); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](arg); end

  def __copy_from__(arg, arg1); end

  def clear(); end

  def get(arg, arg1); end

  def get_array_of_char(arg, arg1); end

  def get_array_of_double(arg, arg1); end

  def get_array_of_float(arg, arg1); end

  def get_array_of_float32(arg, arg1); end

  def get_array_of_float64(arg, arg1); end

  def get_array_of_int(arg, arg1); end

  def get_array_of_int16(arg, arg1); end

  def get_array_of_int32(arg, arg1); end

  def get_array_of_int64(arg, arg1); end

  def get_array_of_int8(arg, arg1); end

  def get_array_of_long(arg, arg1); end

  def get_array_of_long_long(arg, arg1); end

  def get_array_of_pointer(arg, arg1); end

  def get_array_of_short(arg, arg1); end

  def get_array_of_string(*arg); end

  def get_array_of_uchar(arg, arg1); end

  def get_array_of_uint(arg, arg1); end

  def get_array_of_uint16(arg, arg1); end

  def get_array_of_uint32(arg, arg1); end

  def get_array_of_uint64(arg, arg1); end

  def get_array_of_uint8(arg, arg1); end

  def get_array_of_ulong(arg, arg1); end

  def get_array_of_ulong_long(arg, arg1); end

  def get_array_of_ushort(arg, arg1); end

  def get_bytes(arg, arg1); end

  def get_char(arg); end

  def get_double(arg); end

  def get_float(arg); end

  def get_float32(arg); end

  def get_float64(arg); end

  def get_int(arg); end

  def get_int16(arg); end

  def get_int32(arg); end

  def get_int64(arg); end

  def get_int8(arg); end

  def get_long(arg); end

  def get_long_long(arg); end

  def get_pointer(arg); end

  def get_short(arg); end

  def get_string(*arg); end

  def get_uchar(arg); end

  def get_uint(arg); end

  def get_uint16(arg); end

  def get_uint32(arg); end

  def get_uint64(arg); end

  def get_uint8(arg); end

  def get_ulong(arg); end

  def get_ulong_long(arg); end

  def get_ushort(arg); end

  def put(arg, arg1, arg2); end

  def put_array_of_char(arg, arg1); end

  def put_array_of_double(arg, arg1); end

  def put_array_of_float(arg, arg1); end

  def put_array_of_float32(arg, arg1); end

  def put_array_of_float64(arg, arg1); end

  def put_array_of_int(arg, arg1); end

  def put_array_of_int16(arg, arg1); end

  def put_array_of_int32(arg, arg1); end

  def put_array_of_int64(arg, arg1); end

  def put_array_of_int8(arg, arg1); end

  def put_array_of_long(arg, arg1); end

  def put_array_of_long_long(arg, arg1); end

  def put_array_of_pointer(arg, arg1); end

  def put_array_of_short(arg, arg1); end

  def put_array_of_uchar(arg, arg1); end

  def put_array_of_uint(arg, arg1); end

  def put_array_of_uint16(arg, arg1); end

  def put_array_of_uint32(arg, arg1); end

  def put_array_of_uint64(arg, arg1); end

  def put_array_of_uint8(arg, arg1); end

  def put_array_of_ulong(arg, arg1); end

  def put_array_of_ulong_long(arg, arg1); end

  def put_array_of_ushort(arg, arg1); end

  def put_bytes(*arg); end

  def put_char(arg, arg1); end

  def put_double(arg, arg1); end

  def put_float(arg, arg1); end

  def put_float32(arg, arg1); end

  def put_float64(arg, arg1); end

  def put_int(arg, arg1); end

  def put_int16(arg, arg1); end

  def put_int32(arg, arg1); end

  def put_int64(arg, arg1); end

  def put_int8(arg, arg1); end

  def put_long(arg, arg1); end

  def put_long_long(arg, arg1); end

  def put_pointer(arg, arg1); end

  def put_short(arg, arg1); end

  def put_string(arg, arg1); end

  def put_uchar(arg, arg1); end

  def put_uint(arg, arg1); end

  def put_uint16(arg, arg1); end

  def put_uint32(arg, arg1); end

  def put_uint64(arg, arg1); end

  def put_uint8(arg, arg1); end

  def put_ulong(arg, arg1); end

  def put_ulong_long(arg, arg1); end

  def put_ushort(arg, arg1); end

  def read_array_of_char(arg); end

  def read_array_of_double(arg); end

  def read_array_of_float(arg); end

  def read_array_of_int(arg); end

  def read_array_of_int16(arg); end

  def read_array_of_int32(arg); end

  def read_array_of_int64(arg); end

  def read_array_of_int8(arg); end

  def read_array_of_long(arg); end

  def read_array_of_long_long(arg); end

  def read_array_of_pointer(arg); end

  def read_array_of_short(arg); end

  def read_array_of_uchar(arg); end

  def read_array_of_uint(arg); end

  def read_array_of_uint16(arg); end

  def read_array_of_uint32(arg); end

  def read_array_of_uint64(arg); end

  def read_array_of_uint8(arg); end

  def read_array_of_ulong(arg); end

  def read_array_of_ulong_long(arg); end

  def read_array_of_ushort(arg); end

  def read_bytes(arg); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def size_limit?(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(arg); end

  def write_array_of_double(arg); end

  def write_array_of_float(arg); end

  def write_array_of_int(arg); end

  def write_array_of_int16(arg); end

  def write_array_of_int32(arg); end

  def write_array_of_int64(arg); end

  def write_array_of_int8(arg); end

  def write_array_of_long(arg); end

  def write_array_of_long_long(arg); end

  def write_array_of_pointer(arg); end

  def write_array_of_short(arg); end

  def write_array_of_uchar(arg); end

  def write_array_of_uint(arg); end

  def write_array_of_uint16(arg); end

  def write_array_of_uint32(arg); end

  def write_array_of_uint64(arg); end

  def write_array_of_uint8(arg); end

  def write_array_of_ulong(arg); end

  def write_array_of_ulong_long(arg); end

  def write_array_of_ushort(arg); end

  def write_bytes(*arg); end

  def write_char(arg); end

  def write_double(arg); end

  def write_float(arg); end

  def write_int(arg); end

  def write_int16(arg); end

  def write_int32(arg); end

  def write_int64(arg); end

  def write_int8(arg); end

  def write_long(arg); end

  def write_long_long(arg); end

  def write_pointer(arg); end

  def write_short(arg); end

  def write_uchar(arg); end

  def write_uint(arg); end

  def write_uint16(arg); end

  def write_uint32(arg); end

  def write_uint64(arg); end

  def write_uint8(arg); end

  def write_ulong(arg); end

  def write_ulong_long(arg); end

  def write_ushort(arg); end
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(arg, arg1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def initialize(ptr, proc=T.unsafe(nil), &block); end
end

class FFI::AutoPointer::CallableReleaser
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser
  def release(ptr); end
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end
end

class FFI::AutoPointer
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Buffer
  def +(arg); end

  def initialize(*arg); end

  def length(); end

  def order(*arg); end

  def slice(arg, arg1); end
end

class FFI::Buffer
  def self.alloc_in(*arg); end

  def self.alloc_inout(*arg); end

  def self.alloc_out(*arg); end

  def self.new_in(*arg); end

  def self.new_inout(*arg); end

  def self.new_out(*arg); end
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

class FFI::DynamicLibrary
  def find_function(arg); end

  def find_symbol(arg); end

  def find_variable(arg); end

  def initialize(arg, arg1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(arg, arg1); end
end

class FFI::Enum
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Function
  def attach(arg, arg1); end

  def autorelease(); end

  def call(*arg); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*arg); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::Library
  def attach_function(name, func, args, returns=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(arg); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::Pointer
  def +(arg); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*arg); end

  def null?(); end

  def order(*arg); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(arg, arg1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](arg); end

  def []=(arg, arg1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*arg); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*arg); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](arg); end

  def []=(arg, arg1); end

  def each(&blk); end

  def initialize(arg, arg1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*arg, **arg1); end

  def self.alloc_inout(*arg, **arg1); end

  def self.alloc_out(*arg, **arg1); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*arg, **arg1); end

  def self.new_inout(*arg, **arg1); end

  def self.new_out(*arg, **arg1); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  def initialize(struct_class); end

  def native_type(); end

  def struct_class(); end
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](arg); end

  def __union!(); end

  def fields(); end

  def initialize(arg, arg1, arg2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(arg); end

  def initialize(*arg); end

  def name(); end

  def offset(); end

  def put(arg, arg1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::Type
  def alignment(); end

  def initialize(arg); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*arg); end

  def native_type(); end

  def to_native(*arg); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def initialize(arg, arg1, arg2, arg3); end

  def invoke(arg, arg1); end
end

module FFI
  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.map_library_name(lib); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

module FactoryBot
  Deprecation = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Attribute
  def alias_for?(attr); end

  def association?(); end

  def ignored(); end

  def initialize(name, ignored); end

  def name(); end

  def to_proc(); end
end

class FactoryBot::Attribute::Association
  def factory(); end

  def initialize(name, factory, overrides); end
end

class FactoryBot::Attribute::Dynamic
  def initialize(name, ignored, block); end
end

class FactoryBot::Attribute::Sequence
  def initialize(name, sequence, ignored); end
end

class FactoryBot::AttributeAssigner
  def initialize(evaluator, build_class, &instance_builder); end

  def object(); end
end

class FactoryBot::AttributeList
  def apply_attributes(attributes_to_apply); end

  def associations(); end

  def define_attribute(attribute); end

  def each(&block); end

  def ignored(); end

  def initialize(name=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def names(); end

  def non_ignored(); end
end

class FactoryBot::AwesomeLinter
  def calculate_total(); end

  def cleaning(&block); end

  def factories_to_lint(); end

  def initialize(*args, strategy: T.unsafe(nil), traits: T.unsafe(nil)); end

  def invalid_factories(); end

  def invalid_factory!(error, factory, trait=T.unsafe(nil)); end

  def lint!(); end

  def lint_factory(factory); end

  def lint_trait(factory, trait); end

  def load_factories(*args); end

  def output_invalid_factories(); end

  def progress_bar(); end
end

class FactoryBot::AwesomeLinter
  def self.lint!(*args, **kwargs); end
end

class FactoryBot::Callback
  def ==(other); end

  def block(); end

  def initialize(name, block); end

  def name(); end

  def run(instance, evaluator); end
end

class FactoryBot::CallbacksObserver
  def initialize(callbacks, evaluator); end

  def update(name, result_instance); end
end

class FactoryBot::Configuration
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def callback_names(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def factories(); end

  def initialize_with(&block); end

  def inline_sequences(); end

  def sequences(); end

  def skip_create(*arg, **arg1, &arg2); end

  def strategies(); end

  def to_create(*arg, **arg1, &arg2); end

  def traits(); end
end

class FactoryBot::Declaration
  def ignored(); end

  def initialize(name, ignored=T.unsafe(nil)); end

  def name(); end

  def to_attributes(); end
end

class FactoryBot::Declaration::Association
  def ==(other); end

  def initialize(name, *options); end

  def options(); end
end

class FactoryBot::Declaration::Dynamic
  def ==(other); end

  def block(); end

  def initialize(name, ignored=T.unsafe(nil), block=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Implicit
  def ==(other); end

  def factory(); end

  def initialize(name, factory=T.unsafe(nil), ignored=T.unsafe(nil)); end
end

class FactoryBot::DeclarationList
  def attributes(); end

  def declare_attribute(declaration); end

  def each(&block); end

  def initialize(name=T.unsafe(nil)); end

  def overridable(); end
end

class FactoryBot::Decorator
  def initialize(component); end

  def method_missing(*arg, **arg1, &arg2); end

  def send(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator::AttributeHash
  def attributes(); end

  def initialize(component, attributes=T.unsafe(nil)); end
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
  def register(name, item); end
end

class FactoryBot::Decorator::InvocationTracker
  def __invoked_methods__(); end

  def method_missing(name, *args, **arg, &block); end
end

class FactoryBot::Decorator::NewConstructor
  def initialize(component, build_class); end

  def new(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator
  def self.const_missing(name); end
end

class FactoryBot::Definition
  def add_callback(callback); end

  def after(*names, &block); end

  def append_traits(new_traits); end

  def attributes(); end

  def before(*names, &block); end

  def callback(*names, &block); end

  def callbacks(); end

  def compile(klass=T.unsafe(nil)); end

  def constructor(); end

  def declarations(); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_constructor(&block); end

  def define_trait(trait); end

  def defined_traits(); end

  def inherit_traits(new_traits); end

  def initialize(name, base_traits=T.unsafe(nil)); end

  def name(); end

  def overridable(); end

  def register_enum(enum); end

  def registered_enums(); end

  def skip_create(); end

  def to_create(&block); end
end

class FactoryBot::DefinitionHierarchy
  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::DefinitionHierarchy
  def self.build_from_definition(definition); end
end

class FactoryBot::DefinitionProxy
  def add_attribute(name, &block); end

  def after(*arg, **arg1, &arg2); end

  def association(name, *options); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def child_factories(); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize(definition, ignore=T.unsafe(nil)); end

  def initialize_with(&block); end

  def method_missing(name, *args, &block); end

  def sequence(name, *args, &block); end

  def singleton_method_added(name); end

  def skip_create(); end

  def to_create(&block); end

  def trait(name, &block); end

  def traits_for_enum(attribute_name, values=T.unsafe(nil)); end

  def transient(&block); end
  UNPROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Enum
  def build_traits(klass); end

  def initialize(attribute_name, values=T.unsafe(nil)); end
end

class FactoryBot::Evaluation
  def create(result_instance); end

  def hash(*arg, **arg1, &arg2); end

  def initialize(evaluator, attribute_assigner, to_create); end

  def notify(name, result_instance); end

  def object(*arg, **arg1, &arg2); end
end

class FactoryBot::Evaluator
  def __override_names__(); end

  def association(factory_name, *traits_and_overrides); end

  def attribute_lists(); end

  def attribute_lists=(attribute_lists); end

  def attribute_lists?(); end

  def increment_sequence(sequence); end

  def initialize(build_strategy, overrides=T.unsafe(nil)); end

  def instance(); end

  def instance=(instance); end

  def method_missing(method_name, *args, **arg, &block); end
end

class FactoryBot::Evaluator
  def self.attribute_list(); end

  def self.attribute_lists(); end

  def self.attribute_lists=(value); end

  def self.attribute_lists?(); end

  def self.define_attribute(name, &block); end
end

class FactoryBot::EvaluatorClassDefiner
  def evaluator_class(); end

  def initialize(attributes, parent_class); end
end

class FactoryBot::Factory
  def add_callback(*arg, **arg1, &arg2); end

  def append_traits(*arg, **arg1, &arg2); end

  def associations(); end

  def attributes(); end

  def build_class(); end

  def build_hierarchy(); end

  def callbacks(); end

  def class_name(); end

  def compile(); end

  def compiled_constructor(); end

  def compiled_to_create(); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def hierarchy_instance(); end

  def human_names(); end

  def inherit_traits(*arg, **arg1, &arg2); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def names(); end

  def run(build_strategy, overrides, &block); end

  def to_create(*arg, **arg1, &arg2); end

  def with_traits(traits); end
end

class FactoryBot::FactoryRunner
  def initialize(name, strategy, traits_and_overrides); end

  def run(runner_strategy=T.unsafe(nil), &block); end
end

module FactoryBot::Internal
  def self.after(*arg, **arg1, &arg2); end

  def self.before(*arg, **arg1, &arg2); end

  def self.callbacks(*arg, **arg1, &arg2); end

  def self.configuration(); end

  def self.constructor(*arg, **arg1, &arg2); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.factory_by_name(name); end

  def self.initialize_with(*arg, **arg1, &arg2); end

  def self.inline_sequences(*arg, **arg1, &arg2); end

  def self.register_default_strategies(); end

  def self.register_factory(factory); end

  def self.register_inline_sequence(sequence); end

  def self.register_sequence(sequence); end

  def self.register_strategy(strategy_name, strategy_class); end

  def self.register_trait(trait); end

  def self.reset_configuration(); end

  def self.rewind_inline_sequences(); end

  def self.rewind_sequences(); end

  def self.sequence_by_name(name); end

  def self.sequences(*arg, **arg1, &arg2); end

  def self.skip_create(*arg, **arg1, &arg2); end

  def self.strategies(*arg, **arg1, &arg2); end

  def self.strategy_by_name(name); end

  def self.to_create(*arg, **arg1, &arg2); end

  def self.trait_by_name(name); end

  def self.traits(*arg, **arg1, &arg2); end
end

class FactoryBot::Linter
  def initialize(factories, strategy: T.unsafe(nil), traits: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def lint!(); end
end

class FactoryBot::Linter::FactoryError
  def initialize(wrapped_error, factory); end

  def location(); end

  def message(); end

  def verbose_message(); end
end

class FactoryBot::Linter::FactoryTraitError
  def initialize(wrapped_error, factory, trait_name); end
end

class FactoryBot::NullFactory
  def attributes(*arg, **arg1, &arg2); end

  def callbacks(*arg, **arg1, &arg2); end

  def class_name(); end

  def compile(); end

  def constructor(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::NullObject
  def initialize(methods_to_respond_to); end

  def method_missing(name, *args, &block); end

  def respond_to?(method); end
end

class FactoryBot::Registry
  def [](name); end

  def clear(); end

  def each(&block); end

  def find(name); end

  def initialize(name); end

  def name(); end

  def register(name, item); end

  def registered?(name); end
end

class FactoryBot::Sequence
  def initialize(name, *args, &proc); end

  def name(); end

  def names(); end

  def next(scope=T.unsafe(nil)); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
  def initialize(value); end

  def next(); end

  def peek(); end

  def rewind(); end
end

class FactoryBot::Strategy::AttributesFor
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Build
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Create
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Null
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Stub
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
  DISABLED_PERSISTENCE_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Strategy::Stub
  def self.next_id=(id); end
end

class FactoryBot::StrategyCalculator
  def initialize(name_or_object); end

  def strategy(); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def define_strategy_methods(); end

  def initialize(strategy_name); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def self.with_index(block, index); end
end

module FactoryBot::Syntax::Default
  def define(&block); end

  def modify(&block); end
end

class FactoryBot::Syntax::Default::DSL
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize_with(*arg, **arg1, &arg2); end

  def sequence(name, *args, &block); end

  def skip_create(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end

  def trait(name, &block); end
end

class FactoryBot::Syntax::Default::DSL
  def self.run(block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def factory(name, _options=T.unsafe(nil), &block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def self.run(block); end
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def generate(name); end

  def generate_list(name, count); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

class FactoryBot::Trait
  def ==(other); end

  def add_callback(*arg, **arg1, &arg2); end

  def attributes(*arg, **arg1, &arg2); end

  def block(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def definition(); end

  def initialize(name, &block); end

  def name(); end

  def names(); end

  def to_create(*arg, **arg1, &arg2); end
end

module FactoryBot
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.automatically_define_enum_traits(); end

  def self.automatically_define_enum_traits=(val); end

  def self.build_stubbed_starting_id=(starting_id); end

  def self.definition_file_paths(); end

  def self.definition_file_paths=(definition_file_paths); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.find_definitions(); end

  def self.lint(*args); end

  def self.register_strategy(*arg, **arg1, &arg2); end

  def self.reload(); end

  def self.rewind_sequences(*arg, **arg1, &arg2); end

  def self.strategy_by_name(*arg, **arg1, &arg2); end

  def self.use_parent_strategy(); end

  def self.use_parent_strategy=(val); end
end

class FactoryBotRails::DefinitionFilePaths
  def any?(); end

  def directories(); end

  def files(); end

  def initialize(definition_file_paths); end
end

class FactoryBotRails::Generator
  def factory_bot_disabled?(); end

  def generator(); end

  def initialize(config); end

  def rails_options(); end

  def run(); end

  def test_framework(); end
end

class FactoryBotRails::Generators::NonRSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::NullGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::RSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Reloader
  def initialize(app); end

  def run(); end
end

module Faker
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faker::Address
  def self.postcode(legacy_state_abbreviation=T.unsafe(nil), state_abbreviation: T.unsafe(nil)); end

  def self.zip(legacy_state_abbreviation=T.unsafe(nil), state_abbreviation: T.unsafe(nil)); end
end

class Faker::Alphanumeric
  ALPHANUMS = ::T.let(nil, ::T.untyped)
end

class Faker::Australia
  def self.animal(); end

  def self.location(); end

  def self.state(); end
end

class Faker::Bank
  def self.iban_country_code(); end
end

class Faker::Base
  LLetters = ::T.let(nil, ::T.untyped)
  Letters = ::T.let(nil, ::T.untyped)
  Numbers = ::T.let(nil, ::T.untyped)
  ULetters = ::T.let(nil, ::T.untyped)
end

class Faker::Books::TheKingkillerChronicle
  def self.book(); end

  def self.character(); end

  def self.creature(); end

  def self.location(); end
end

class Faker::Commerce
  def self.brand(); end

  def self.vendor(); end
end

class Faker::Creature::Bird
  def self.adjective(); end

  def self.anatomy(); end

  def self.anatomy_past_tense(); end

  def self.color(); end

  def self.common_family_name(); end

  def self.common_name(tax_order=T.unsafe(nil)); end

  def self.emotional_adjective(); end

  def self.geo(); end

  def self.implausible_common_name(); end

  def self.order(); end

  def self.order_with_common_name(tax_order=T.unsafe(nil)); end

  def self.plausible_common_name(); end

  def self.silly_adjective(); end
end

class Faker::Crypto
  def self.sha512(); end
end

class Faker::DrivingLicence
  GB_PADDING = ::T.let(nil, ::T.untyped)
  NI_CHANCE = ::T.let(nil, ::T.untyped)
end

class Faker::Educator
  def self.course(); end

  def self.primary_school(); end
end

class Faker::Emotion
  def self.adjective(); end

  def self.noun(); end
end

class Faker::Finance
  CREDIT_CARD_TYPES = ::T.let(nil, ::T.untyped)
  MARKET_LIST = ::T.let(nil, ::T.untyped)
end

class Faker::Finance
  def self.stock_market(); end
end

class Faker::Food
  def self.ethnic_category(); end
end

class Faker::Games::Dota
  def self.building(); end
end

class Faker::Games::Witcher
  def self.book(); end

  def self.potion(); end

  def self.sign(); end
end

class Faker::Hobby
  def self.activity(); end
end

class Faker::IDNumber
  BRAZILIAN_ID_FORMAT = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_FROM = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_TO = ::T.let(nil, ::T.untyped)
  CHECKS = ::T.let(nil, ::T.untyped)
  CHILEAN_MODULO = ::T.let(nil, ::T.untyped)
  INVALID_SSN = ::T.let(nil, ::T.untyped)
  ZA_CITIZENSHIP_DIGITS = ::T.let(nil, ::T.untyped)
  ZA_RACE_DIGIT = ::T.let(nil, ::T.untyped)
end

class Faker::IDNumber
  def self.brazilian_cpf(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.brazilian_rg(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.croatian_id(international: T.unsafe(nil)); end

  def self.south_african_id_number(); end
end

class Faker::Internet
  PRIVATE_IPV4_ADDRESS_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::Internet::HTTP
  STATUS_CODES = ::T.let(nil, ::T.untyped)
  STATUS_CODES_GROUPS = ::T.let(nil, ::T.untyped)
end

class Faker::Internet
  def self.user(*args); end

  def self.user_name(legacy_specifier=T.unsafe(nil), legacy_separators=T.unsafe(nil), specifier: T.unsafe(nil), separators: T.unsafe(nil)); end
end

class Faker::JapaneseMedia::FmaBrotherhood
  def self.character(); end

  def self.city(); end

  def self.country(); end
end

class Faker::JapaneseMedia::KamenRider
  def self.collectible_device(*eras); end

  def self.eras=(new_eras); end

  def self.kamen_rider(*eras); end

  def self.series(*eras); end

  def self.transformation_device(*eras); end

  def self.user(*eras); end
end

class Faker::Movies::StarWars
  def self.wookie_sentence(); end

  def self.wookie_words(); end
end

class Faker::Music
  def self.mambo_no_5(); end
end

class Faker::Name
  def self.feminine_name(); end

  def self.first_name_men(); end

  def self.first_name_neutral(); end

  def self.first_name_women(); end

  def self.gender_neutral_first_name(); end

  def self.masculine_name(); end

  def self.middle_name(); end
end

class Faker::Number
  def self.binary(digits: T.unsafe(nil)); end
end

class Faker::Omniauth
  def self.auth0(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end
end

class Faker::PhoneNumber
  def self.extension(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end
end

class Faker::Religion::Bible
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Science
  def self.element_state(); end

  def self.element_subcategory(); end

  def self.modifier(); end

  def self.science(*branches); end

  def self.tool(simple: T.unsafe(nil)); end
end

class Faker::String
  def self.random(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end
end

class Faker::Tea
  def self.type(); end

  def self.variety(type: T.unsafe(nil)); end
end

class Faker::Time
  TIME_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::TvShows::BrooklynNineNine
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::Buffy
  def self.celebrity(); end
end

class Faker::TvShows::DrWho
  def self.villian(); end
end

class Faker::TvShows::Supernatural
  def self.character(); end

  def self.creature(); end

  def self.weapon(); end
end

class Faker::TvShows::TheFreshPrinceOfBelAir
  def self.celebrity(); end
end

class Faker::TvShows::TheOffice
  def self.character(); end

  def self.quote(); end
end

class Faker::Types
  CHARACTERS = ::T.let(nil, ::T.untyped)
  COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  SIMPLE_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::Vehicle
  MILEAGE_MAX = ::T.let(nil, ::T.untyped)
  MILEAGE_MIN = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_CHARS = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_WEIGHTS = ::T.let(nil, ::T.untyped)
  VIN_LETTERS = ::T.let(nil, ::T.untyped)
  VIN_MAP = ::T.let(nil, ::T.untyped)
  VIN_REGEX = ::T.let(nil, ::T.untyped)
  VIN_WEIGHTS = ::T.let(nil, ::T.untyped)
end

class Faker::Vehicle
  def self.door_count(); end

  def self.engine_size(); end

  def self.kilometrage(legacy_min=T.unsafe(nil), legacy_max=T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil)); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::FriendlyId::UnfriendlyUtils
end

module Faraday
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Excon
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def matches?(env); end

  def params_match?(env); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def initialize(strict_mode: T.unsafe(nil)); end

  def match(env); end

  def matches?(stack, env); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def strict_mode=(value); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

Faraday::CompositeReadIO = Faraday::Multipart::CompositeReadIO

class Faraday::Connection
  METHODS = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

module Faraday::EmHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::EmSynchrony
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

module Faraday::Excon
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::FilePart = UploadIO

module Faraday::HTTPClient
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache
  CACHE_STATUSES = ::T.let(nil, ::T.untyped)
  ERROR_STATUSES = ::T.let(nil, ::T.untyped)
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  UNSAFE_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache::Response
  CACHEABLE_STATUS_CODES = ::T.let(nil, ::T.untyped)
end

module Faraday::Multipart
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::Multipart::FilePart = UploadIO

class Faraday::Multipart::Middleware
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

Faraday::Multipart::Parts = Parts

module Faraday::NetHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::NetHttpPersistent
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::ParamPart = Faraday::Multipart::ParamPart

Faraday::Parts = Parts

module Faraday::Patron
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::Rack
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def initialize(app, type, param); end

  def on_request(env); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

Faraday::Request::Multipart = Faraday::Multipart::Middleware

Faraday::Request::Retry = Faraday::Retry::Middleware

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

module Faraday::Retry
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Retry::Middleware
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Retry::Middleware::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

Faraday::Timer = Timeout

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

module Fiddle
  ALIGN_INT16_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT32_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT64_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT8_T = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SIZEOF_CONST_STRING = ::T.let(nil, ::T.untyped)
  SIZEOF_INT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT8_T = ::T.let(nil, ::T.untyped)
  TYPE_CONST_STRING = ::T.let(nil, ::T.untyped)
  TYPE_INT16_T = ::T.let(nil, ::T.untyped)
  TYPE_INT32_T = ::T.let(nil, ::T.untyped)
  TYPE_INT64_T = ::T.let(nil, ::T.untyped)
  TYPE_INT8_T = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::CStruct
  include ::Enumerable
  def each(&blk); end

  def each_pair(); end

  def replace(another); end

  def to_h(); end
end

class Fiddle::CStruct
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

module Fiddle::CStructBuilder
end

module Fiddle::CStructBuilder
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def [](*args); end

  def []=(*args); end

  def assign_names(members); end

  def initialize(addr, types, func=T.unsafe(nil)); end

  def set_ctypes(types); end

  def to_s(); end
end

class Fiddle::CStructEntity
  def self.alignment(types); end

  def self.malloc(types, func=T.unsafe(nil), size=T.unsafe(nil), &block); end

  def self.size(types); end
end

class Fiddle::CUnion
end

class Fiddle::CUnion
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

class Fiddle::CUnionEntity
end

class Fiddle::CUnionEntity
end

class Fiddle::ClearedReferenceError
end

class Fiddle::ClearedReferenceError
end

class Fiddle::CompositeHandler
  def [](symbol); end

  def handlers(); end

  def initialize(handlers); end

  def sym(symbol); end
end

class Fiddle::CompositeHandler
end

class Fiddle::Error
end

class Fiddle::Error
end

class Fiddle::Function
  def need_gvl?(); end

  def to_proc(); end
end

class Fiddle::Handle
  def file_name(); end

  def to_ptr(); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
end

module Fiddle::Importer
  extend ::Fiddle::Importer
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Fiddle::MemoryView
  def [](*arg); end

  def byte_size(); end

  def format(); end

  def initialize(arg); end

  def item_size(); end

  def ndim(); end

  def obj(); end

  def readonly?(); end

  def release(); end

  def shape(); end

  def strides(); end

  def sub_offsets(); end
end

class Fiddle::MemoryView
  def self.export(arg); end
end

module Fiddle::PackInfo
  ALIGN_MAP = ::T.let(nil, ::T.untyped)
  PACK_MAP = ::T.let(nil, ::T.untyped)
  SIZE_MAP = ::T.let(nil, ::T.untyped)
end

module Fiddle::PackInfo
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end

  def pack(ary); end

  def size(); end

  def unpack(ary); end
end

class Fiddle::Packer
  def self.[](*types); end
end

class Fiddle::Pinned
  def clear(); end

  def cleared?(); end

  def initialize(arg); end

  def ref(); end
end

class Fiddle::Pinned
end

class Fiddle::Pointer
  def call_free(); end

  def freed?(); end
end

class Fiddle::StructArray
  include ::Fiddle::ValueUtil
  def []=(index, value); end

  def initialize(ptr, type, initial_values); end

  def to_ptr(); end
end

class Fiddle::StructArray
end

module Fiddle::ValueUtil
  def signed_value(val, ty); end

  def unsigned_value(val, ty); end

  def wrap_arg(arg, ty, funcs=T.unsafe(nil), &block); end

  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::ValueUtil
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.exists?(arg); end

  def self.open!(file, *args, &block); end

  def self.probe_stat_in(dir); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class FindMaxNumViolations
  LIMIT = ::T.let(nil, ::T.untyped)
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module FriendlyId
  UNFRIENDLY_CLASSES = ::T.let(nil, ::T.untyped)
end

module FriendlyId::Base
  def friendly(); end

  def friendly_id(base=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def friendly_id_config(); end

  def primary_key_type(); end
end

module FriendlyId::Base
end

class FriendlyId::Candidates
  include ::Enumerable
  def each(*args, &block); end

  def initialize(object, *array); end
end

class FriendlyId::Candidates
end

class FriendlyId::Configuration
  def base(*value); end

  def base=(base); end

  def defaults(); end

  def dependent(); end

  def dependent=(dependent); end

  def finder_methods(); end

  def finder_methods=(finder_methods); end

  def initialize(model_class, values=T.unsafe(nil)); end

  def model_class(); end

  def model_class=(model_class); end

  def modules(); end

  def query_field(); end

  def routes(); end

  def routes=(routes); end

  def use(*modules); end

  def uses?(mod); end
end

class FriendlyId::Configuration
end

module FriendlyId::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def exists_by_friendly_id?(id); end

  def find(*args); end

  def find_by_friendly_id(id); end
end

module FriendlyId::FinderMethods
end

module FriendlyId::Finders
end

module FriendlyId::Finders::ClassMethods
end

module FriendlyId::Finders::ClassMethods
end

module FriendlyId::Finders
  def self.setup(model_class); end
end

module FriendlyId::History
end

module FriendlyId::History::Configuration
  def dependent_value(); end
end

module FriendlyId::History::Configuration
end

module FriendlyId::History::FinderMethods
  include ::FriendlyId::FinderMethods
  def exists_by_friendly_id?(id); end
end

module FriendlyId::History::FinderMethods
end

module FriendlyId::History
  def self.included(model_class); end

  def self.setup(model_class); end
end

module FriendlyId::Model
  def dup(); end

  def friendly_id(); end

  def friendly_id_config(); end

  def to_param(); end
end

module FriendlyId::Model
  def self.included(model_class); end
end

module FriendlyId::ObjectUtils
  def friendly_id?(); end

  def unfriendly_id?(); end
end

module FriendlyId::ObjectUtils
end

module FriendlyId::Reserved
end

module FriendlyId::Reserved::Configuration
  def reserved_words(); end

  def reserved_words=(reserved_words); end

  def treat_reserved_as_conflict(); end

  def treat_reserved_as_conflict=(treat_reserved_as_conflict); end
end

module FriendlyId::Reserved::Configuration
end

module FriendlyId::Reserved
  def self.included(model_class); end
end

module FriendlyId::Scoped
  def serialized_scope(); end

  def should_generate_new_friendly_id?(); end
end

module FriendlyId::Scoped::Configuration
  def scope(); end

  def scope=(scope); end

  def scope_columns(); end
end

module FriendlyId::Scoped::Configuration
end

module FriendlyId::Scoped
  def self.included(model_class); end

  def self.setup(model_class); end
end

module FriendlyId::SequentiallySlugged
  def resolve_friendly_id_conflict(candidate_slugs); end
end

class FriendlyId::SequentiallySlugged::SequentialSlugCalculator
  def initialize(scope, slug, slug_column, sequence_separator, base_class); end

  def next_slug(); end

  def scope(); end

  def scope=(scope); end

  def sequence_separator(); end

  def sequence_separator=(sequence_separator); end

  def slug(); end

  def slug=(slug); end

  def slug_column(); end

  def slug_column=(slug_column); end
end

class FriendlyId::SequentiallySlugged::SequentialSlugCalculator
end

module FriendlyId::SequentiallySlugged
  def self.setup(model_class); end
end

module FriendlyId::SimpleI18n
end

module FriendlyId::SimpleI18n::Configuration
  def slug_column(); end
end

module FriendlyId::SimpleI18n::Configuration
end

module FriendlyId::SimpleI18n::Model
  def set_friendly_id(text, locale=T.unsafe(nil)); end

  def slug=(value); end
end

module FriendlyId::SimpleI18n::Model
end

module FriendlyId::SimpleI18n
  def self.included(model_class); end

  def self.setup(model_class); end
end

class FriendlyId::Slug
  include ::FriendlyId::Slug::GeneratedAttributeMethods
  include ::FriendlyId::Slug::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def autosave_associated_records_for_sluggable(*args); end
  RelationType = ::T.let(nil, ::T.untyped)
end

class FriendlyId::Slug::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::FriendlyId::Slug::GeneratedRelationMethods
end

class FriendlyId::Slug::ActiveRecord_AssociationRelation
end

class FriendlyId::Slug::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::FriendlyId::Slug::GeneratedRelationMethods
end

class FriendlyId::Slug::ActiveRecord_Associations_CollectionProxy
end

class FriendlyId::Slug::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::FriendlyId::Slug::GeneratedRelationMethods
end

class FriendlyId::Slug::ActiveRecord_Relation
end

module FriendlyId::Slug::GeneratedAssociationMethods
  def reload_sluggable(); end

  def sluggable(); end

  def sluggable=(value); end

  def sluggable_changed?(); end

  def sluggable_previously_changed?(); end
end

module FriendlyId::Slug::GeneratedAssociationMethods
end

module FriendlyId::Slug::GeneratedAttributeMethods
end

module FriendlyId::Slug::GeneratedAttributeMethods
  extend ::Mutex_m
end

module FriendlyId::Slug::GeneratedRelationMethods
end

module FriendlyId::Slug::GeneratedRelationMethods
  extend ::Mutex_m
end

class FriendlyId::Slug
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

class FriendlyId::SlugGenerator
  def available?(slug); end

  def generate(candidates); end

  def initialize(scope, config); end
end

class FriendlyId::SlugGenerator
end

module FriendlyId::Slugged
  def normalize_friendly_id(value); end

  def resolve_friendly_id_conflict(candidates); end

  def should_generate_new_friendly_id?(); end
end

module FriendlyId::Slugged::Configuration
  def query_field(); end

  def sequence_separator(); end

  def sequence_separator=(sequence_separator); end

  def slug_column(); end

  def slug_column=(slug_column); end

  def slug_generator_class(); end

  def slug_generator_class=(slug_generator_class); end

  def slug_limit(); end

  def slug_limit=(slug_limit); end
end

module FriendlyId::Slugged::Configuration
end

module FriendlyId::Slugged
  def self.included(model_class); end
end

module FriendlyId::UnfriendlyUtils
  def friendly_id?(); end

  def unfriendly_id?(); end
end

module FriendlyId::UnfriendlyUtils
end

module FriendlyId
  def self.defaults(&block); end

  def self.extended(model_class); end

  def self.included(model_class); end

  def self.mark_as_unfriendly(klass); end

  def self.table_name_prefix(); end
end

class FrozenError
  def receiver(); end
end

class Fuubar
  def dump_failures(_notification); end

  def example_failed(notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def example_tick(_notification); end

  def example_tick_lock(); end

  def example_tick_lock=(example_tick_lock); end

  def example_tick_thread(); end

  def failed_count(); end

  def failed_count=(failed_count); end

  def initialize(*args); end

  def passed_count(); end

  def passed_count=(passed_count); end

  def pending_count(); end

  def pending_count=(pending_count); end

  def progress(); end

  def progress=(progress); end
  DEFAULT_PROGRESS_BAR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Fuubar::Output
  def initialize(output, force_tty=T.unsafe(nil)); end

  def tty?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end

  def self.measure_total_time(); end

  def self.measure_total_time=(flag); end

  def self.total_time(); end

  def self.using_rvargc?(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def plugins(); end
end

module Gem::BundlerVersionFinder
  def self.prioritize!(specs); end
end

Gem::Cache = Gem::SourceIndex

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def prioritizes_bundler?(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(); end
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), extension_dir=T.unsafe(nil)); end

  def self.get_relative_path(path, base); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  LICENSE_REF = ::T.let(nil, ::T.untyped)
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::SymlinkError
  def initialize(name, destination, destination_dir); end
end

class Gem::Package::SymlinkError
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def unused_unwind_options(); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Gem::TSort
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def possibility_set(); end

  def possibility_set=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::VersionConflict
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  DEFAULT_KEY_ALGORITHM = ::T.let(nil, ::T.untyped)
  EC_NAME = ::T.let(nil, ::T.untyped)
  RSA_DSA_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(algorithm); end

  def self.email_to_name(email_address); end

  def self.get_public_key(key); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SourceIndex
  def ==(other); end

  def add_spec(gem_spec, name=T.unsafe(nil)); end

  def add_specs(*gem_specs); end

  def all_gems(); end

  def dump(); end

  def each(&block); end

  def find_name(gem_name, requirement=T.unsafe(nil)); end

  def gem_signature(gem_full_name); end

  def gems(); end

  def index_signature(); end

  def initialize(specifications=T.unsafe(nil)); end

  def latest_specs(include_prerelease=T.unsafe(nil)); end

  def length(); end

  def load_gems_in(*spec_dirs); end

  def outdated(); end

  def prerelease_gems(); end

  def prerelease_specs(); end

  def refresh!(); end

  def released_gems(); end

  def released_specs(); end

  def remove_spec(full_name); end

  def search(gem_pattern, platform_only=T.unsafe(nil)); end

  def size(); end

  def spec_dirs(); end

  def spec_dirs=(spec_dirs); end

  def specification(full_name); end
end

class Gem::SourceIndex
  def self.from_gems_in(*spec_dirs); end

  def self.from_installed_gems(*deprecated); end

  def self.installed_spec_directories(); end

  def self.load_specification(file_name); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Gem::Specification::YamlBackfiller
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

module Gem::Specification::YamlBackfiller
  def to_yaml(opts=T.unsafe(nil)); end
end

module Gem::Specification::YamlBackfiller
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.latest_spec_for(name); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.find_config_file(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.source_index(); end
end

module GeneratedUrlHelpers
  def _routes(); end

  def preview_view_component_path(*args); end

  def preview_view_component_url(*args); end

  def preview_view_components_path(*args); end

  def preview_view_components_url(*args); end

  def rails_info_path(*args); end

  def rails_info_properties_path(*args); end

  def rails_info_properties_url(*args); end

  def rails_info_routes_path(*args); end

  def rails_info_routes_url(*args); end

  def rails_info_url(*args); end

  def rails_mailers_path(*args); end

  def rails_mailers_url(*args); end
end

module GeneratedUrlHelpers
  extend ::ActiveSupport::Concern
  def self._routes(); end

  def self.full_url_for(options); end

  def self.optimize_routes_generation?(); end

  def self.polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def self.polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end

  def self.route_for(name, *args); end

  def self.url_for(options); end

  def self.url_options(); end
end

class GetIgnoredViolation
  IGNORE_REGEXP = ::T.let(nil, ::T.untyped)
end

module GetText
end

class GetText::PoParser
  def _(x); end

  def _reduce_10(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def on_comment(comment); end

  def on_message(msgid, msgstr); end

  def parse(str, data, ignore_fuzzy=T.unsafe(nil)); end

  def unescape(orig); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class GetText::PoParser
end

module GetText
end

module Git
  VERSION = ::T.let(nil, ::T.untyped)
end

class Git::Diff::DiffFile
  NIL_BLOB_REGEXP = ::T.let(nil, ::T.untyped)
end

class Git::EscapedPath
  UNESCAPES = ::T.let(nil, ::T.untyped)
end

class Git::Lib
  ENV_VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
end

module GlobalID::FixtureSet
  def signed_global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end
end

module GlobalID::FixtureSet
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

module Gretel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gretel::Crumbs
  extend ::Gretel::Resettable
end

class Gretel::Renderer
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_STYLES = ::T.let(nil, ::T.untyped)
end

class Gretel::Renderer
  extend ::Gretel::Resettable
end

module Gretel
  extend ::Gretel::Resettable
end

class HTMLSelector
  def context(); end

  def css_selector(); end

  def initialize(values, previous_selection=T.unsafe(nil), &root_fallback); end

  def message(); end

  def select(); end

  def selecting_no_body?(); end

  def tests(); end
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  def self.context(); end
end

module Haml
  VERSION = ::T.let(nil, ::T.untyped)
end

module Haml::AttributeBuilder
  INVALID_ATTRIBUTE_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

module Haml::AttributeParser
  IGNORED_TYPES = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

class Haml::Error
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class Haml::ErubiTemplateHandler
  def initialize(*args, &blk); end
end

module Haml::Helpers
  def capture_haml_without_haml_xss(*args, &block); end

  def find_and_preserve_without_haml_xss(input=T.unsafe(nil), tags=T.unsafe(nil), &block); end

  def haml_concat_without_haml_xss(text=T.unsafe(nil)); end

  def haml_indent_without_haml_xss(); end

  def list_of_without_haml_xss(enum, opts=T.unsafe(nil), &block); end

  def precede_without_haml_xss(str, &block); end

  def preserve_without_haml_xss(input=T.unsafe(nil), &block); end

  def succeed_without_haml_xss(str, &block); end

  def surround_without_haml_xss(front, back=T.unsafe(nil), &block); end
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEX = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

module Haml::Helpers::ActionViewExtensions
  def generate_content_class_names(); end

  def page_class(); end

  def with_raw_haml_concat(); end
end

module Haml::Helpers::ActionViewMods
  def output_buffer(); end

  def output_buffer=(new_buffer); end

  def render(*args, &block); end
end

class Haml::Helpers::ErrorReturn
  def html_safe(); end

  def html_safe!(); end
end

module Haml::Helpers::XssMods
  def capture_haml_with_haml_xss(*args, &block); end

  def escape_once_with_haml_xss(*args); end

  def find_and_preserve_with_haml_xss(*args, &block); end

  def haml_concat_with_haml_xss(text=T.unsafe(nil)); end

  def haml_indent_with_haml_xss(); end

  def html_escape_with_haml_xss(text); end

  def list_of_with_haml_xss(*args, &block); end

  def precede_with_haml_xss(str, &block); end

  def preserve_with_haml_xss(*args, &block); end

  def succeed_with_haml_xss(str, &block); end

  def surround_with_haml_xss(front, back=T.unsafe(nil), &block); end
end

module Haml::Helpers::XssMods
  def self.included(base); end
end

class Haml::Parser
  BLOCK_KEYWORD_REGEX = ::T.let(nil, ::T.untyped)
  BLOCK_WITH_SPACES = ::T.let(nil, ::T.untyped)
  CLASS_KEY = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DIV_CLASS = ::T.let(nil, ::T.untyped)
  DIV_ID = ::T.let(nil, ::T.untyped)
  DOCTYPE = ::T.let(nil, ::T.untyped)
  DOCTYPE_REGEX = ::T.let(nil, ::T.untyped)
  ELEMENT = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  FILTER = ::T.let(nil, ::T.untyped)
  FLAT_SCRIPT = ::T.let(nil, ::T.untyped)
  ID_KEY = ::T.let(nil, ::T.untyped)
  LITERAL_VALUE_REGEX = ::T.let(nil, ::T.untyped)
  METHOD_CALL_PREFIX = ::T.let(nil, ::T.untyped)
  MID_BLOCK_KEYWORDS = ::T.let(nil, ::T.untyped)
  MULTILINE_CHAR_VALUE = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SANITIZE = ::T.let(nil, ::T.untyped)
  SCRIPT = ::T.let(nil, ::T.untyped)
  SILENT_COMMENT = ::T.let(nil, ::T.untyped)
  SILENT_SCRIPT = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  START_BLOCK_KEYWORDS = ::T.let(nil, ::T.untyped)
  START_BLOCK_KEYWORD_REGEX = ::T.let(nil, ::T.untyped)
end

class Haml::Plugin
  def cache_fragment(block, name=T.unsafe(nil), options=T.unsafe(nil)); end

  def compile(template, source); end

  def handles_encoding?(); end
end

class Haml::Plugin
  def self.annotate_rendered_view_with_filenames(); end

  def self.annotate_rendered_view_with_filenames=(annotate_rendered_view_with_filenames); end

  def self.call(template, source=T.unsafe(nil)); end
end

class Haml::TempleEngine
  def precompiled_method_return_value_with_haml_xss(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::FriendlyId::UnfriendlyUtils
  def deconstruct_keys(arg); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

class HighLine
  def agree(yes_or_no_question, character=T.unsafe(nil)); end

  def ask(template_or_question, answer_type=T.unsafe(nil), &details); end

  def choose(*items, &details); end

  def color(string, *colors); end

  def color_code(*colors); end

  def get_response_character_mode(question); end

  def get_response_getc_mode(question); end

  def get_response_line_mode(question); end

  def indent(increase=T.unsafe(nil), statement=T.unsafe(nil), multiline=T.unsafe(nil)); end

  def indent_level(); end

  def indent_level=(indent_level); end

  def indent_size(); end

  def indent_size=(indent_size); end

  def indentation(); end

  def initialize(input=T.unsafe(nil), output=T.unsafe(nil), wrap_at=T.unsafe(nil), page_at=T.unsafe(nil), indent_size=T.unsafe(nil), indent_level=T.unsafe(nil)); end

  def input(); end

  def key(); end

  def key=(key); end

  def list(items, mode=T.unsafe(nil), option=T.unsafe(nil)); end

  def multi_indent(); end

  def multi_indent=(multi_indent); end

  def new_scope(); end

  def newline(); end

  def output(); end

  def output_cols(); end

  def output_rows(); end

  def page_at(); end

  def page_at=(setting); end

  def puts(*args); end

  def render_statement(statement); end

  def reset_use_color(); end

  def say(statement); end

  def shell_style_lambda(menu); end

  def terminal(); end

  def track_eof(); end

  def track_eof=(track_eof); end

  def track_eof?(); end

  def uncolor(string); end

  def use_color(); end

  def use_color=(use_color); end

  def use_color?(); end

  def wrap_at(); end

  def wrap_at=(setting); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles
  BASIC_COLORS = ::T.let(nil, ::T.untyped)
  BLACK = ::T.let(nil, ::T.untyped)
  BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BLINK = ::T.let(nil, ::T.untyped)
  BLINK_STYLE = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  BOLD_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_RED = ::T.let(nil, ::T.untyped)
  BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CLEAR_STYLE = ::T.let(nil, ::T.untyped)
  COLORS = ::T.let(nil, ::T.untyped)
  COLOR_LIST = ::T.let(nil, ::T.untyped)
  CONCEALED = ::T.let(nil, ::T.untyped)
  CONCEALED_STYLE = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  CYAN_STYLE = ::T.let(nil, ::T.untyped)
  DARK = ::T.let(nil, ::T.untyped)
  DARK_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_CHAR = ::T.let(nil, ::T.untyped)
  ERASE_CHAR_STYLE = ::T.let(nil, ::T.untyped)
  ERASE_LINE = ::T.let(nil, ::T.untyped)
  ERASE_LINE_STYLE = ::T.let(nil, ::T.untyped)
  GRAY = ::T.let(nil, ::T.untyped)
  GRAY_STYLE = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  GREEN_STYLE = ::T.let(nil, ::T.untyped)
  GREY = ::T.let(nil, ::T.untyped)
  GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_GREY = ::T.let(nil, ::T.untyped)
  LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE = ::T.let(nil, ::T.untyped)
  LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_RED = ::T.let(nil, ::T.untyped)
  LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_BRIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GRAY = ::T.let(nil, ::T.untyped)
  ON_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_GREY = ::T.let(nil, ::T.untyped)
  ON_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLACK_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_BLUE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_CYAN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GRAY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREEN_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY = ::T.let(nil, ::T.untyped)
  ON_LIGHT_GREY_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_LIGHT_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED = ::T.let(nil, ::T.untyped)
  ON_LIGHT_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  ON_LIGHT_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_MAGENTA_STYLE = ::T.let(nil, ::T.untyped)
  ON_NONE = ::T.let(nil, ::T.untyped)
  ON_NONE_STYLE = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_RED_STYLE = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_WHITE_STYLE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  ON_YELLOW_STYLE = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RED_STYLE = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  RESET_STYLE = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  REVERSE_STYLE = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
  STYLE_LIST = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  UNDERLINE_STYLE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNDERSCORE_STYLE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  WHITE_STYLE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
  YELLOW_STYLE = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles::ClassMethods
  def const_missing(name); end
  RGB_COLOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module HighLine::BuiltinStyles
  def self.included(base); end
end

class HighLine::ColorScheme
  def [](color_tag); end

  def []=(color_tag, constants); end

  def definition(color_tag); end

  def include?(color_tag); end

  def initialize(h=T.unsafe(nil)); end

  def keys(); end

  def load_from_hash(h); end

  def to_hash(); end
end

class HighLine::CustomErrors::ExplainableError
  def explanation_key(); end
end

class HighLine::List
  def col_down(); end

  def col_down_mode(); end

  def cols(); end

  def cols=(cols); end

  def initialize(items, options=T.unsafe(nil)); end

  def items(); end

  def list(); end

  def row_join_str_size(); end

  def row_join_string(); end

  def row_join_string=(row_join_string); end

  def slice_by_cols(); end

  def slice_by_rows(); end

  def to_a(); end

  def transpose(); end

  def transpose_mode(); end
end

class HighLine::ListRenderer
  def highline(); end

  def initialize(items, mode=T.unsafe(nil), option=T.unsafe(nil), highline); end

  def items(); end

  def mode(); end

  def option(); end

  def render(); end
end

class HighLine::Menu
  def add_item(item); end

  def all_items(); end

  def build_item(*args); end

  def choice(name, help=T.unsafe(nil), text=T.unsafe(nil), &action); end

  def choices(*names, &action); end

  def decorate_index(index); end

  def decorate_item(text, ix); end

  def find_item_from_selection(items, selection); end

  def flow(); end

  def flow=(flow); end

  def gather_selected(highline_context, selections, details=T.unsafe(nil)); end

  def get_item_by_letter(items, selection); end

  def get_item_by_number(items, selection); end

  def header(); end

  def header=(header); end

  def help(topic, help); end

  def hidden(name, help=T.unsafe(nil), &action); end

  def index(); end

  def index=(style); end

  def index_color(); end

  def index_color=(index_color); end

  def index_suffix(); end

  def index_suffix=(index_suffix); end

  def init_help(); end

  def initialize(); end

  def layout(); end

  def layout=(new_layout); end

  def list_option(); end

  def list_option=(list_option); end

  def map_items_by_index(); end

  def map_items_by_name(); end

  def mark_for_decoration(text, ix); end

  def nil_on_handled(); end

  def nil_on_handled=(nil_on_handled); end

  def options(); end

  def parse_list(); end

  def prompt(); end

  def prompt=(prompt); end

  def select(highline_context, selection, details=T.unsafe(nil)); end

  def select_by(); end

  def select_by=(select_by); end

  def shell(); end

  def shell=(shell); end

  def show_default_if_any(); end

  def to_ary(); end

  def update_responses(); end

  def value_for_array_selections(items, selections, details); end

  def value_for_hash_selections(items, selections, details); end

  def value_for_selected_item(item, details); end
end

class HighLine::Menu::Item
  def action(); end

  def help(); end

  def initialize(name, attributes); end

  def item_help(); end

  def name(); end

  def text(); end
end

class HighLine::Menu
  def self.index_color(); end

  def self.index_color=(index_color); end
end

class HighLine::Paginator
  def continue_paging?(); end

  def highline(); end

  def initialize(highline); end

  def page_print(text); end
end

class HighLine::Question
  def above(); end

  def above=(above); end

  def answer(); end

  def answer=(answer); end

  def answer_or_default(answer_string); end

  def answer_type(); end

  def answer_type=(answer_type); end

  def ask_on_error_msg(); end

  def below(); end

  def below=(below); end

  def build_responses(message_source=T.unsafe(nil)); end

  def build_responses_new_hash(message_source); end

  def case(); end

  def case=(arg); end

  def change_case(answer_string); end

  def character(); end

  def character=(character); end

  def check_range(); end

  def choices_complete(answer_string); end

  def completion(); end

  def completion=(completion); end

  def confirm(); end

  def confirm=(confirm); end

  def confirm_question(highline); end

  def convert(); end

  def default(); end

  def default=(default); end

  def default_responses_hash(); end

  def directory(); end

  def directory=(directory); end

  def echo(); end

  def echo=(echo); end

  def expected_range(); end

  def final_response(error); end

  def final_responses(); end

  def first_answer(); end

  def first_answer=(first_answer); end

  def first_answer?(); end

  def format_answer(answer_string); end

  def gather(); end

  def gather=(gather); end

  def get_echo_for_response(response); end

  def get_response(highline); end

  def get_response_or_default(highline); end

  def glob(); end

  def glob=(glob); end

  def in(); end

  def in=(arg); end

  def in_range?(); end

  def initialize(template, answer_type); end

  def limit(); end

  def limit=(limit); end

  def overwrite(); end

  def overwrite=(overwrite); end

  def readline(); end

  def readline=(readline); end

  def remove_whitespace(answer_string); end

  def responses(); end

  def selection(); end

  def show_question(highline); end

  def template(); end

  def template=(template); end

  def valid_answer?(); end

  def validate(); end

  def validate=(validate); end

  def verify_match(); end

  def verify_match=(verify_match); end

  def whitespace(); end

  def whitespace=(whitespace); end
end

class HighLine::Question::AnswerConverter
  def answer(*args, **arg, &block); end

  def answer=(*args, **arg, &block); end

  def answer_type(*args, **arg, &block); end

  def check_range(*args, **arg, &block); end

  def choices_complete(*args, **arg, &block); end

  def convert(); end

  def directory(*args, **arg, &block); end

  def initialize(question); end

  def to_array(); end

  def to_file(); end

  def to_float(); end

  def to_integer(); end

  def to_pathname(); end

  def to_proc(); end

  def to_regexp(); end

  def to_string(); end

  def to_symbol(); end
end

class HighLine::Question
  def self.build(template_or_question, answer_type=T.unsafe(nil), &details); end
end

class HighLine::QuestionAsker
  def ask_once(); end

  def gather_answers(); end

  def gather_hash(); end

  def gather_integer(); end

  def gather_regexp(); end

  def initialize(question, highline); end

  def question(); end
end

class HighLine::SampleColorScheme
  def initialize(_h=T.unsafe(nil)); end
  SAMPLE_SCHEME = ::T.let(nil, ::T.untyped)
end

class HighLine::Statement
  def highline(); end

  def initialize(source, highline); end

  def source(); end

  def statement(); end

  def template_string(); end
end

class HighLine::Statement
  def self.const_missing(constant); end
end

class HighLine::String
  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright_black(); end

  def bright_blue(); end

  def bright_cyan(); end

  def bright_gray(); end

  def bright_green(); end

  def bright_grey(); end

  def bright_magenta(); end

  def bright_none(); end

  def bright_red(); end

  def bright_white(); end

  def bright_yellow(); end

  def color(*args); end

  def concealed(); end

  def cyan(); end

  def dark(); end

  def foreground(*args); end

  def gray(); end

  def green(); end

  def grey(); end

  def light_black(); end

  def light_blue(); end

  def light_cyan(); end

  def light_gray(); end

  def light_green(); end

  def light_grey(); end

  def light_magenta(); end

  def light_none(); end

  def light_red(); end

  def light_white(); end

  def light_yellow(); end

  def magenta(); end

  def method_missing(method, *_args); end

  def none(); end

  def on(arg); end

  def on_black(); end

  def on_blue(); end

  def on_bright_black(); end

  def on_bright_blue(); end

  def on_bright_cyan(); end

  def on_bright_gray(); end

  def on_bright_green(); end

  def on_bright_grey(); end

  def on_bright_magenta(); end

  def on_bright_none(); end

  def on_bright_red(); end

  def on_bright_white(); end

  def on_bright_yellow(); end

  def on_cyan(); end

  def on_gray(); end

  def on_green(); end

  def on_grey(); end

  def on_light_black(); end

  def on_light_blue(); end

  def on_light_cyan(); end

  def on_light_gray(); end

  def on_light_green(); end

  def on_light_grey(); end

  def on_light_magenta(); end

  def on_light_none(); end

  def on_light_red(); end

  def on_light_white(); end

  def on_light_yellow(); end

  def on_magenta(); end

  def on_none(); end

  def on_red(); end

  def on_rgb(*colors); end

  def on_white(); end

  def on_yellow(); end

  def red(); end

  def reset(); end

  def rgb(*colors); end

  def uncolor(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

module HighLine::StringExtensions
  STYLE_METHOD_NAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module HighLine::StringExtensions
  def self.define_builtin_style_methods(base); end

  def self.define_style_support_methods(base); end

  def self.included(base); end
end

class HighLine::Style
  def blue(); end

  def bright(); end

  def builtin(); end

  def builtin=(builtin); end

  def code(); end

  def color(string); end

  def green(); end

  def initialize(defn=T.unsafe(nil)); end

  def light(); end

  def list(); end

  def name(); end

  def on(); end

  def red(); end

  def rgb(); end

  def rgb=(rgb); end

  def to_hash(); end

  def variant(new_name, options=T.unsafe(nil)); end
end

class HighLine::Style
  def self.ansi_rgb_to_hex(ansi_number); end

  def self.clear_index(); end

  def self.code_index(); end

  def self.index(style); end

  def self.list(); end

  def self.rgb(*colors); end

  def self.rgb_hex(*colors); end

  def self.rgb_number(*parts); end

  def self.rgb_parts(hex); end

  def self.uncolor(string); end
end

class HighLine::TemplateRenderer
  def answer(*args, **arg, &block); end

  def answer_type(*args, **arg, &block); end

  def color(*args, **arg, &block); end

  def header(*args, **arg, &block); end

  def highline(); end

  def initialize(template, source, highline); end

  def key(*args, **arg, &block); end

  def list(*args, **arg, &block); end

  def menu(); end

  def method_missing(method, *args); end

  def prompt(*args, **arg, &block); end

  def render(); end

  def source(); end

  def template(); end
end

class HighLine::TemplateRenderer
  def self.const_missing(name); end
end

class HighLine::Terminal
  def character_mode(); end

  def get_character(); end

  def get_line(question, highline); end

  def get_line_default(highline); end

  def get_line_with_readline(question, highline); end

  def initialize(input, output); end

  def initialize_system_extensions(); end

  def input(); end

  def jruby?(); end

  def output(); end

  def raw_no_echo_mode(); end

  def raw_no_echo_mode_exec(); end

  def readline_read(question); end

  def restore_mode(); end

  def rubinius?(); end

  def terminal_size(); end

  def windows?(); end
end

class HighLine::Terminal
  def self.get_terminal(input, output); end
end

module HighLine::Wrapper
  def self.actual_length(string_with_escapes); end

  def self.wrap(text, wrap_at); end
end

class HighLine
  def self.String(s); end

  def self.Style(*args); end

  def self.agree(*args, **arg, &block); end

  def self.ask(*args, **arg, &block); end

  def self.choose(*args, **arg, &block); end

  def self.color(*args, **arg, &block); end

  def self.color_code(*args, **arg, &block); end

  def self.color_scheme(); end

  def self.color_scheme=(color_scheme); end

  def self.colorize_strings(); end

  def self.default_instance(); end

  def self.default_instance=(default_instance); end

  def self.find_or_create_style(arg); end

  def self.find_or_create_style_list(*args); end

  def self.reset(); end

  def self.reset_color_scheme(); end

  def self.reset_use_color(*args, **arg, &block); end

  def self.say(*args, **arg, &block); end

  def self.supports_rgb_color?(); end

  def self.track_eof=(*args, **arg, &block); end

  def self.track_eof?(*args, **arg, &block); end

  def self.uncolor(*args, **arg, &block); end

  def self.use_color=(*args, **arg, &block); end

  def self.use_color?(*args, **arg, &block); end

  def self.using_color_scheme?(); end
end

module Hotwire::Livereload
  DISABLE_FILE = ::T.let(nil, ::T.untyped)
end

module Hotwire::Livereload::LivereloadTagsHelper
  def hotwire_livereload_tags(); end
end

module Html2haml
  VERSION = ::T.let(nil, ::T.untyped)
end

class Html2haml::HTML
  def detect_proper_parser(template); end

  def initialize(template, options=T.unsafe(nil)); end

  def render(); end

  def to_haml(); end
  TEXT_REGEXP = ::T.let(nil, ::T.untyped)
end

class Html2haml::HTML::ERB
  def self.compile(template); end
end

class HtmlTokenizer::Parser
  def append_placeholder(arg); end

  def attribute_name(); end

  def attribute_quoted?(); end

  def attribute_value(); end

  def cdata_text(); end

  def closing_tag?(); end

  def column_number(); end

  def comment_text(); end

  def context(); end

  def document(); end

  def document_length(); end

  def errors(); end

  def errors_count(); end

  def line_number(); end

  def parse(arg); end

  def quote_character(); end

  def rawtext_text(); end

  def self_closing_tag?(); end

  def tag_name(); end
end

class HtmlTokenizer::Parser
end

class HtmlTokenizer::ParserError
  def column(); end

  def initialize(message, position, line, column); end

  def line(); end

  def position(); end
end

class HtmlTokenizer::Tokenizer
  def tokenize(arg); end
end

class HtmlTokenizer::Tokenizer
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, **options); end

  def translate(key=T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, **options); end

  def transliterate(key, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidFilenames
  def initialize(file_errors); end
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

class I18n::InvalidFilenames
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

I18n::JSON = ActiveSupport::JSON

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(*args, &block); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tasks
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::BaseTask
  def initialize(config_file: T.unsafe(nil), **config); end
end

class I18n::Tasks::CommandError
  def initialize(error=T.unsafe(nil), message); end
end

class I18n::Tasks::Concurrent::Cache
  def fetch(key, &block); end
end

class I18n::Tasks::Concurrent::CachedValue
  def get(); end

  def initialize(&computation); end
  NULL = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Configuration
  def base_locale(); end

  def config(); end

  def config=(conf); end

  def config_for_inspect(); end

  def config_sections(); end

  def data_config(); end

  def file_config(); end

  def ignore_config(type=T.unsafe(nil)); end

  def internal_locale(); end

  def locales(); end

  def translation_config(); end
  CONFIG_FILES = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IGNORE_TYPES = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Data
  def build_tree(hash); end

  def data(); end

  def data_forest(locales=T.unsafe(nil)); end

  def empty_forest(); end

  def external_key?(key, locale=T.unsafe(nil)); end

  def key_value?(key, locale=T.unsafe(nil)); end

  def node(key, locale=T.unsafe(nil)); end

  def non_normalized_paths(locales: T.unsafe(nil)); end

  def normalize_store!(locales: T.unsafe(nil), force_pattern_router: T.unsafe(nil)); end

  def t(key, locale=T.unsafe(nil)); end

  def t_proc(locale=T.unsafe(nil)); end

  def tree(sel); end
  DATA_DEFAULTS = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Data::Adapter::JsonAdapter
  def self.dump(tree, opts); end

  def self.parse(str, opts); end
end

module I18n::Tasks::Data::Adapter::YamlAdapter
  EMOJI_REGEX = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Data::Adapter::YamlAdapter
  def self.dump(tree, options); end

  def self.parse(str, options); end

  def self.restore_emojis(yaml); end
end

module I18n::Tasks::Data::FileFormats
  def adapter_dump(tree, format); end

  def adapter_op(op, format, tree, config); end

  def adapter_parse(tree, format); end

  def load_file(path); end

  def normalized?(path, tree); end

  def read_config(format); end

  def read_file(path); end

  def write_config(format); end

  def write_tree(path, tree, sort=T.unsafe(nil)); end
end

module I18n::Tasks::Data::FileFormats::ClassMethods
  def adapter_by_name(name); end

  def adapter_name_for_path(path); end

  def adapter_names(); end

  def register_adapter(name, pattern, adapter); end
end

module I18n::Tasks::Data::FileFormats
  def self.included(base); end
end

class I18n::Tasks::Data::FileSystemBase
  def [](locale); end

  def []=(locale, tree); end

  def available_locales(); end

  def base_locale(); end

  def config(); end

  def config=(config); end

  def external(locale); end

  def filter_nil_keys!(path, data, suffix=T.unsafe(nil)); end

  def get(locale); end

  def initialize(config=T.unsafe(nil)); end

  def locales(); end

  def locales=(locales); end

  def merge!(forest); end

  def non_normalized_paths(locale); end

  def read_locale(locale, paths: T.unsafe(nil)); end

  def reload(); end

  def remove_by_key!(forest); end

  def router(); end

  def router=(router); end

  def set(locale, tree); end

  def t(key, locale); end

  def with_router(router); end

  def write(forest); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ROUTER_NAME_ALIASES = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Data::Router::ConservativeRouter
  def adapter(); end

  def base_locale(); end

  def base_tree(); end

  def initialize(adapter, config); end

  def key_path(locale, key); end

  def locales(); end
end

class I18n::Tasks::Data::Router::PatternRouter
  def initialize(_adapter, data_config); end

  def route(locale, forest, &block); end

  def routes(); end
end

class I18n::Tasks::Data::Tree::Node
  def [](key); end

  def []=(full_key, node); end

  def append(nodes); end

  def append!(nodes); end

  def attributes(); end

  def children(); end

  def children=(children); end

  def children?(); end

  def data(); end

  def data?(); end

  def derive(new_attr=T.unsafe(nil)); end

  def dirty!(); end

  def each(&block); end

  def format_value_for_inspect(value); end

  def full_key(root: T.unsafe(nil)); end

  def get(key); end

  def initialize(key:, value: T.unsafe(nil), data: T.unsafe(nil), parent: T.unsafe(nil), children: T.unsafe(nil), warn_about_add_children_to_leaf: T.unsafe(nil)); end

  def inspect(level=T.unsafe(nil)); end

  def key(); end

  def leaf?(); end

  def parent(); end

  def parent?(); end

  def reference?(); end

  def root(); end

  def root?(); end

  def set(full_key, node); end

  def to_hash(sort=T.unsafe(nil)); end

  def to_json(*arg, **arg1, &arg2); end

  def to_nodes(); end

  def to_siblings(); end

  def to_yaml(*arg, **arg1, &arg2); end

  def value(); end

  def value=(value); end

  def value_or_children_hash(); end

  def walk_from_root(&visitor); end

  def walk_to_root(&visitor); end
end

class I18n::Tasks::Data::Tree::Node
  def self.from_key_value(key, value); end
end

class I18n::Tasks::Data::Tree::Nodes
  def +(nodes); end

  def <<(other); end

  def append(other); end

  def append!(other); end

  def attributes(); end

  def blank?(*arg, **arg1, &arg2); end

  def children(&block); end

  def children?(*arg); end

  def derive(new_attr=T.unsafe(nil)); end

  def dirty!(); end

  def each(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def initialize(opts=T.unsafe(nil)); end

  def list(); end

  def merge!(nodes); end

  def present?(*arg, **arg1, &arg2); end

  def remove!(node); end

  def size(*arg, **arg1, &arg2); end

  def to_a(*arg, **arg1, &arg2); end

  def to_hash(sort=T.unsafe(nil)); end

  def to_json(*arg, **arg1, &arg2); end

  def to_nodes(); end

  def to_yaml(*arg, **arg1, &arg2); end
end

class I18n::Tasks::Data::Tree::Siblings
  def [](full_key); end

  def []=(full_key, node); end

  def append(nodes); end

  def append!(nodes); end

  def get(full_key); end

  def key_to_node(); end

  def merge(nodes); end

  def merge!(nodes, on_leaves_merge: T.unsafe(nil)); end

  def merge_node!(node, on_leaves_merge: T.unsafe(nil)); end

  def mv_key!(from_pattern, to_pattern, root: T.unsafe(nil)); end

  def parent(); end

  def remove_nodes_and_emptied_ancestors(nodes); end

  def remove_nodes_and_emptied_ancestors!(nodes); end

  def rename_key(key, new_key); end

  def replace_node!(node, new_node); end

  def set(full_key, node); end

  def set_root_key!(new_key, data=T.unsafe(nil)); end

  def subtract_by_key(other); end

  def subtract_by_key!(other); end

  def subtract_keys(keys); end

  def subtract_keys!(keys); end
end

class I18n::Tasks::Data::Tree::Siblings
  extend ::I18n::Tasks::SplitKey
  def self.[](hash, opts=T.unsafe(nil)); end

  def self.build_forest(opts=T.unsafe(nil), &block); end

  def self.from_flat_pairs(pairs); end

  def self.from_key_attr(key_attrs, opts=T.unsafe(nil), &block); end

  def self.from_key_names(keys, opts=T.unsafe(nil), &block); end

  def self.from_key_occurrences(key_occurrences); end

  def self.from_nested_hash(hash, opts=T.unsafe(nil)); end

  def self.null(); end
end

module I18n::Tasks::Data::Tree::Traversal
  def breadth_first(&visitor); end

  def depth_first(&visitor); end

  def get_nodes_by_key_filter(root: T.unsafe(nil), &block); end

  def grep_keys(match, opts=T.unsafe(nil)); end

  def intersect_keys(other_tree, key_opts=T.unsafe(nil), &block); end

  def key_names(root: T.unsafe(nil)); end

  def key_values(root: T.unsafe(nil)); end

  def keys(root: T.unsafe(nil), &visitor); end

  def leaves(&visitor); end

  def levels(&block); end

  def nodes(&block); end

  def root_key_value_data(sort=T.unsafe(nil)); end

  def root_key_values(sort=T.unsafe(nil)); end

  def select_keys(root: T.unsafe(nil), &block); end

  def select_keys!(root: T.unsafe(nil), &block); end

  def select_nodes(&block); end

  def select_nodes!(&block); end

  def set_each_value!(val_pattern, key_pattern=T.unsafe(nil), &value_proc); end
end

module I18n::Tasks::HtmlKeys
  def html_key?(full_key, locale); end
  HTML_KEY_PATTERN = ::T.let(nil, ::T.untyped)
  MAYBE_PLURAL_HTML_KEY_PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::IgnoreKeys
  def ignore_key?(key, ignore_type, locale=T.unsafe(nil)); end

  def ignore_pattern(type, locale=T.unsafe(nil)); end
end

module I18n::Tasks::Interpolations
  def inconsistent_interpolations(locales: T.unsafe(nil), base_locale: T.unsafe(nil)); end
end

module I18n::Tasks::Interpolations
  def self.variable_regex(); end

  def self.variable_regex=(variable_regex); end
end

module I18n::Tasks::KeyPatternMatching
  def compile_key_pattern(key_pattern); end

  def compile_patterns_re(key_patterns); end

  def key_pattern_re_body(key_pattern); end
  MATCH_NOTHING = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::LocaleList
  def self.normalize_locale_list(locales, base_locale, include_base=T.unsafe(nil)); end
end

module I18n::Tasks::LocalePathname
  def self.replace_locale(path, from, to); end
end

module I18n::Tasks::Logging
  MUTEX = ::T.let(nil, ::T.untyped)
  PROGRAM_NAME = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Logging
  def self.log_error(message); end

  def self.log_stderr(*args); end

  def self.log_verbose(message=T.unsafe(nil)); end

  def self.log_warn(message); end

  def self.program_name(); end

  def self.warn_deprecated(message); end
end

module I18n::Tasks::MissingKeys
  def collapse_same_key_in_locales!(forest); end

  def eq_base_keys(opts=T.unsafe(nil)); end

  def equal_values_tree(locale, compare_to=T.unsafe(nil)); end

  def load_rails_i18n_pluralization!(locale); end

  def locale_key_missing?(locale, key); end

  def missing_diff_forest(locales, base=T.unsafe(nil)); end

  def missing_diff_tree(locale, compared_to=T.unsafe(nil)); end

  def missing_keys(locales: T.unsafe(nil), types: T.unsafe(nil), base_locale: T.unsafe(nil)); end

  def missing_keys_types(); end

  def missing_plural_forest(locales, _base=T.unsafe(nil)); end

  def missing_used_forest(locales, _base=T.unsafe(nil)); end

  def missing_used_tree(locale); end

  def required_plural_keys_for_locale(locale); end
  MISSING_TYPES = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::MissingKeys
  def self.missing_keys_types(); end
end

module I18n::Tasks::PluralKeys
  def collapse_plural_nodes!(tree); end

  def depluralize_key(key, locale=T.unsafe(nil)); end

  def non_plural_other?(s); end

  def plural_forms?(s); end

  def plural_nodes(tree); end

  def plural_suffix?(key); end
  CLDR_CATEGORY_KEYS = ::T.let(nil, ::T.untyped)
  PLURAL_KEY_RE = ::T.let(nil, ::T.untyped)
  PLURAL_KEY_SUFFIXES = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::References
  def process_references(usages, data_refs=T.unsafe(nil)); end
end

class I18n::Tasks::Scanners::ErbAstProcessor
  def on_code(node); end

  def process_and_extract_comments(ast); end
end

class I18n::Tasks::Scanners::FileScanner
  def config(); end

  def find_files(); end

  def initialize(config: T.unsafe(nil), file_finder_provider: T.unsafe(nil), file_reader: T.unsafe(nil)); end

  def read_file(path); end

  def scan_file(_path); end

  def traverse_files(&block); end
end

class I18n::Tasks::Scanners::Files::CachingFileFinder
  def initialize(**args); end
end

class I18n::Tasks::Scanners::Files::CachingFileFinderProvider
  def get(**file_finder_args); end

  def initialize(exclude: T.unsafe(nil)); end
end

class I18n::Tasks::Scanners::Files::FileFinder
  def find_files(); end

  def initialize(paths: T.unsafe(nil), only: T.unsafe(nil), exclude: T.unsafe(nil)); end

  def traverse_files(&block); end
end

class I18n::Tasks::Scanners::Files::FileReader
  def read_file(path); end
end

class I18n::Tasks::Scanners::LocalRubyParser
  def initialize(ignore_blocks: T.unsafe(nil)); end

  def normalize_comment_location(comment, location); end

  def normalize_location(node, location); end

  def parse(source, location: T.unsafe(nil)); end

  def updated_location(global_location, local_location); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Scanners::OccurrenceFromPosition
  def occurrence_from_position(path, contents, position, raw_key: T.unsafe(nil)); end
end

class I18n::Tasks::Scanners::PatternMapper
  def initialize(config:, **args); end

  def scan_file(path); end
  KEY_GROUP = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Scanners::PatternScanner
  def closest_method(occurrence); end

  def default_pattern(); end

  def exclude_line?(line, path); end

  def first_argument_re(); end

  def initialize(**args); end

  def key_relative_to_method?(path); end

  def match_to_key(match, path, location); end

  def scan_file(path); end

  def translate_call_re(); end
  IGNORE_LINES = ::T.let(nil, ::T.untyped)
  TRANSLATE_CALL_RE = ::T.let(nil, ::T.untyped)
  VALID_KEY_RE_DYNAMIC = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Scanners::PatternWithScopeScanner
  def expr_re(); end

  def extract_literal_or_array_of_literals(s); end

  def scope_arg_re(); end

  def strip_literal(val); end
end

module I18n::Tasks::Scanners::RelativeKeys
  def absolute_key(key, path, roots: T.unsafe(nil), exclude_method_name_paths: T.unsafe(nil), calling_method: T.unsafe(nil)); end
  DOT = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Scanners::Results::KeyOccurrences
  def ==(other); end

  def eql?(other); end

  def initialize(key:, occurrences:); end

  def key(); end

  def occurrences(); end
end

class I18n::Tasks::Scanners::Results::KeyOccurrences
  def self.merge_keys(keys_occurrences); end
end

class I18n::Tasks::Scanners::Results::Occurrence
  def ==(other); end

  def default_arg(); end

  def eql?(other); end

  def initialize(path:, pos:, line_num:, line_pos:, line:, raw_key: T.unsafe(nil), default_arg: T.unsafe(nil)); end

  def line(); end

  def line_num(); end

  def line_pos(); end

  def path(); end

  def pos(); end

  def raw_key(); end

  def raw_key=(raw_key); end
end

class I18n::Tasks::Scanners::RubyAstCallFinder
  def collect_calls(root_node); end

  def find_calls(root_node, &block); end

  def initialize(receiver_messages:); end

  def on_def(node); end

  def on_send(send_node); end
end

class I18n::Tasks::Scanners::RubyAstScanner
  def ast_to_occurences(ast); end

  def comments_to_occurences(path, ast, comments); end

  def extract_array_as_string(node, array_join_with:, array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end

  def extract_hash_pair(node, key); end

  def extract_string(node, array_join_with: T.unsafe(nil), array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end

  def initialize(**args); end

  def keys_relative_to_calling_method?(path); end

  def make_buffer(path, contents=T.unsafe(nil)); end

  def path_to_ast_and_comments(path); end

  def range_to_occurrence(raw_key, range, default_arg: T.unsafe(nil)); end

  def scan_file(path); end

  def send_node_to_key_occurrence(send_node, method_name, location: T.unsafe(nil)); end
  MAGIC_COMMENT_PREFIX = ::T.let(nil, ::T.untyped)
  RECEIVER_MESSAGES = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks::Scanners::RubyKeyLiterals
  def literal_re(); end

  def strip_literal(literal); end

  def valid_key?(key); end
  LITERAL_RE = ::T.let(nil, ::T.untyped)
  VALID_KEY_CHARS = ::T.let(nil, ::T.untyped)
  VALID_KEY_RE = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Scanners::Scanner
  def keys(); end
end

class I18n::Tasks::Scanners::ScannerMultiplexer
  def initialize(scanners:); end
end

module I18n::Tasks::SplitKey
  def self.key_parts(key, &block); end

  def self.last_key_part(key); end

  def self.split_key(key, max=T.unsafe(nil)); end
end

module I18n::Tasks::Stats
  def forest_stats(forest); end
end

module I18n::Tasks::StringInterpolation
  def self.interpolate_soft(s, t=T.unsafe(nil)); end
end

module I18n::Tasks::Translation
  def translate_forest(forest, from:, backend: T.unsafe(nil)); end
end

class I18n::Tasks::Translators::BaseTranslator
  def dump_value(value); end

  def fetch_translations(list, opts); end

  def from_values(list, translated_values); end

  def initialize(i18n_tasks); end

  def no_results_error_message(); end

  def options_for_html(); end

  def options_for_plain(); end

  def options_for_translate_values(options); end

  def parse_value(untranslated, each_translated); end

  def raise_interpolation_error(untranslated, translated, e); end

  def replace_interpolations(value); end

  def restore_interpolations(untranslated, translated); end

  def to_values(list); end

  def translate_forest(forest, from); end

  def translate_pairs(list, opts); end

  def translate_values(list, **options); end
  INTERPOLATION_KEY_RE = ::T.let(nil, ::T.untyped)
  UNTRANSLATABLE_STRING = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Translators::DeeplTranslator
  def initialize(*arg); end

  def options_for_translate_values(**options); end

  def translate_values(list, from:, to:, **options); end
end

class I18n::Tasks::Translators::GoogleTranslator
  def initialize(*arg); end

  def options_for_translate_values(from:, to:, **options); end
  SUPPORTED_LOCALES_WITH_REGION = ::T.let(nil, ::T.untyped)
end

class I18n::Tasks::Translators::YandexTranslator
  def initialize(*arg); end

  def options_for_translate_values(from:, to:, **options); end
end

module I18n::Tasks::UnusedKeys
  def unused_keys(locales: T.unsafe(nil), strict: T.unsafe(nil)); end

  def unused_tree(locale: T.unsafe(nil), strict: T.unsafe(nil)); end
end

module I18n::Tasks::UsedKeys
  def caching_file_finder_provider(); end

  def caching_file_reader(); end

  def merge_scanner_configs(a, b); end

  def scanner(strict: T.unsafe(nil)); end

  def search_config(); end

  def used_in_expr?(key); end

  def used_in_source_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil)); end

  def used_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil), include_raw_references: T.unsafe(nil)); end
  ALWAYS_EXCLUDE = ::T.let(nil, ::T.untyped)
  SEARCH_DEFAULTS = ::T.let(nil, ::T.untyped)
end

module I18n::Tasks
  def self.add_commands(commands_module); end

  def self.add_scanner(scanner_class_name, scanner_opts=T.unsafe(nil)); end

  def self.gem_path(); end

  def self.verbose=(verbose); end

  def self.verbose?(); end
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

class I18n::UnsupportedMethod
  def backend_klass(); end

  def initialize(method, backend_klass, msg); end

  def method(); end

  def msg(); end
end

class I18n::UnsupportedMethod
end

module I18n::Utils
end

module I18n::Utils
  def self.deep_merge(hash, other_hash, &block); end

  def self.deep_merge!(hash, other_hash, &block); end

  def self.deep_symbolize_keys(hash); end

  def self.except(hash, *keys); end
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end

  def self.reserve_key(key); end

  def self.reserved_keys_pattern(); end
end

module I18nSpec::FailureMessage
  def failure_for_should(&block); end

  def failure_for_should_not(&block); end
end

class I18nSpec::LocaleFile
  def content(); end

  def errors(); end

  def filepath(); end

  def filepath=(filepath); end

  def flatten_tree(data, prefix=T.unsafe(nil), result=T.unsafe(nil)); end

  def flattened_translations(); end

  def has_one_top_level_namespace?(); end

  def initialize(filepath); end

  def invalid_pluralization_keys(); end

  def is_named_like_top_level_namespace?(); end

  def is_parseable?(); end

  def locale(); end

  def locale_code(); end

  def missing_pluralization_keys(); end

  def pluralization_data?(data); end

  def pluralizations(); end

  def translations(); end

  def yaml_load_content(); end
  PLURALIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def set_encoding_by_bom(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def clear(*arg); end

  def copy(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def hexdump(); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def null?(); end

  def pread(arg, arg1, arg2); end

  def pwrite(arg, arg1, arg2); end

  def read(arg, arg1); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def size(); end

  def slice(arg, arg1); end

  def transfer(); end

  def valid?(); end

  def write(arg, arg1); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*arg); end

  def raw!(*arg); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*arg); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  DIM = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(colorable: T.unsafe(nil)); end

  def self.colorable?(); end

  def self.colorize(text, seq, colorable: T.unsafe(nil)); end

  def self.colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::ColorPrinter
  def text(str, width=T.unsafe(nil)); end
end

class IRB::ColorPrinter
end

class IRB::Context
  def __exit__(*arg); end

  def __inspect__(); end

  def __to_s__(); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def extra_doc_dirs(); end

  def extra_doc_dirs=(extra_doc_dirs); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def use_autocomplete(); end

  def use_autocomplete?(); end

  def use_colorize(); end

  def use_colorize?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reidline(); end

  def use_reidline?(); end

  def use_singleline(); end

  def use_singleline?(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, **kwargs, &b); end

  def irb_change_workspace(*opts, **kwargs, &b); end

  def irb_current_working_workspace(*opts, **kwargs, &b); end

  def irb_fg(*opts, **kwargs, &b); end

  def irb_help(*opts, **kwargs, &b); end

  def irb_info(*opts, **kwargs, &b); end

  def irb_jobs(*opts, **kwargs, &b); end

  def irb_kill(*opts, **kwargs, &b); end

  def irb_ls(*opts, **kwargs, &b); end

  def irb_measure(*opts, **kwargs, &b); end

  def irb_pop_workspace(*opts, **kwargs, &b); end

  def irb_push_workspace(*opts, **kwargs, &b); end

  def irb_show_source(*opts, **kwargs, &b); end

  def irb_source(*opts, **kwargs, &b); end

  def irb_whereami(*opts, **kwargs, &b); end

  def irb_workspaces(*opts, **kwargs, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def close(); end

  def initialize(file); end
end

class IRB::FileInputMethod
  def self.open(file, &block); end
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  CompletionRequireProc = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.absolute_path?(p); end

  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.retrieve_files_to_require_from_load_path(); end

  def self.retrieve_files_to_require_relative_from_current_dir(); end

  def self.retrieve_gem_and_system_load_path(); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end

  def winsize(); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def convert_invalid_byte_sequence(str, enc); end

  def encode_with_invalid_byte_sequence(str, enc); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def prompt(prompt, ltype, indent, line_no); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::ReidlineInputMethod
  include ::Reline
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
  SHOW_DOC_DIALOG = ::T.let(nil, ::T.untyped)
end

class IRB::ReidlineInputMethod
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.set_measure_callback(type=T.unsafe(nil), arg=T.unsafe(nil), &block); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.unset_measure_callback(type=T.unsafe(nil)); end
end

class ISO::Language
  def direction(); end

  def plural_rule_names(); end
  DEFAULT_CODE = ::T.let(nil, ::T.untyped)
  DEFAULT_DIRECTION = ::T.let(nil, ::T.untyped)
  DEFAULT_PLURAL_RULE_NAMES = ::T.let(nil, ::T.untyped)
  DEFINITIONS_FILE = ::T.let(nil, ::T.untyped)
  PLURAL_RULE_NAMES = ::T.let(nil, ::T.untyped)
end

class ISO::Language
  def self.identify(full_code); end
end

class ISO::Region
  DEFINITIONS_FILE = ::T.let(nil, ::T.untyped)
end

class ISO::Region
  def self.identify(full_code); end
end

class ISO::Subtag
  def ==(object); end

  def code(); end

  def full_name(); end

  def initialize(code, options=T.unsafe(nil)); end

  def name(); end
end

class ISO::Subtag
  def self.all(); end

  def self.codes(); end

  def self.default(); end

  def self.find(code); end
end

class ISO::Tag
  def codes(); end

  def initialize(code); end

  def language(); end

  def language=(language); end

  def region(); end

  def region=(region); end

  def subtags(); end

  def valid?(); end
end

class ISO::UN::Region
  def iso_code(); end
  DEFINITIONS_FILE = ::T.let(nil, ::T.untyped)
end

module Imagen
  AVAILABLE_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
  EXCLUDE_RE = ::T.let(nil, ::T.untyped)
end

class Imagen::AST::Parser
  def initialize(parser_version=T.unsafe(nil)); end

  def parse(input, file=T.unsafe(nil)); end

  def parse_file(filename); end

  def parser(); end
end

class Imagen::AST::Parser
  def self.parse(input, file=T.unsafe(nil)); end

  def self.parse_file(filename); end
end

class Imagen::Clone
  def dir(); end

  def initialize(repo_url, dirname); end

  def perform(); end

  def repo_url(); end
end

class Imagen::Clone
  def self.perform(repo_url, dir); end
end

class Imagen::Node::Base
  def ast_node(); end

  def build_from_ast(ast_node); end

  def children(); end

  def file_path(); end

  def find_all(matcher, ret=T.unsafe(nil)); end

  def first_line(); end

  def human_name(); end

  def last_line(); end

  def line_numbers(); end

  def name(); end

  def source(); end

  def source_lines(); end

  def source_lines_with_numbers(); end
end

class Imagen::Node::Block
  def build_from_ast(_ast_node); end
end

class Imagen::Node::Root
  def build_from_dir(dir); end

  def build_from_file(path); end

  def dir(); end
end

class Imagen::RemoteBuilder
  def build(); end

  def dir(); end

  def initialize(repo_url); end

  def repo_url(); end
end

class Imagen::Visitor
  def current_root(); end

  def file_path(); end

  def root(); end

  def traverse(ast_node, parent); end

  def visit(ast_node, parent); end
  TYPES = ::T.let(nil, ::T.untyped)
end

class Imagen::Visitor
  def self.traverse(ast, root); end
end

module Imagen
  def self.from_local(dir); end

  def self.from_remote(repo_url); end

  def self.parser_version(); end

  def self.parser_version=(parser_version); end
end

module IniParse
  VERSION = ::T.let(nil, ::T.untyped)
end

class IniParse::Document
  def [](key); end

  def delete(*args); end

  def each(*args, &blk); end

  def has_section?(key); end

  def initialize(path=T.unsafe(nil)); end

  def lines(); end

  def path(); end

  def path=(path); end

  def save(path=T.unsafe(nil)); end

  def section(key); end

  def to_h(); end

  def to_hash(); end

  def to_ini(); end
end

class IniParse::Generator
  def blank(); end

  def comment(comment, opts=T.unsafe(nil)); end

  def context(); end

  def document(); end

  def gen(); end

  def initialize(opts=T.unsafe(nil)); end

  def method_missing(name, *args, &blk); end

  def option(key, value, opts=T.unsafe(nil)); end

  def section(name, opts=T.unsafe(nil)); end

  def with_options(opts=T.unsafe(nil)); end
end

class IniParse::Generator
  def self.gen(opts=T.unsafe(nil), &blk); end
end

module IniParse::LineCollection
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(line); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(include_blank=T.unsafe(nil), &blk); end

  def has_key?(*args); end

  def initialize(); end

  def keys(); end

  def push(line); end

  def to_a(); end

  def to_h(); end

  def to_hash(); end
end

class IniParse::Lines::AnonymousSection
  def initialize(); end
end

class IniParse::Lines::Blank
  def self.parse(line, opts); end
end

module IniParse::Lines::Line
  def blank?(); end

  def comment(); end

  def has_comment?(); end

  def initialize(opts=T.unsafe(nil)); end

  def line_contents(); end

  def options(); end

  def to_ini(); end
end

class IniParse::Lines::Option
  def initialize(key, value, opts=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def value(); end

  def value=(value); end
end

class IniParse::Lines::Option
  def self.parse(line, opts); end

  def self.typecast(value); end
end

class IniParse::Lines::Section
  def [](key); end

  def []=(key, value); end

  def delete(*args); end

  def each(*args, &blk); end

  def has_option?(key); end

  def initialize(key, opts=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def lines(); end

  def merge!(other); end

  def option(key); end
end

class IniParse::Lines::Section
  def self.parse(line, opts); end
end

class IniParse::OptionCollection
  def each(*args, &blk); end
end

class IniParse::Parser
  def initialize(source); end

  def parse(); end
end

class IniParse::Parser
  def self.parse_line(line); end

  def self.parse_types(); end

  def self.parse_types=(types); end
end

module IniParse
  def self.gen(&blk); end

  def self.open(path); end

  def self.parse(source); end
end

class Insertion
  def after(val, recursive=T.unsafe(nil)); end

  def after_any(val); end

  def before(val, recursive=T.unsafe(nil)); end

  def before_any(val); end

  def initialize(list, value); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def multiple_of?(number); end

  def ordinal(); end

  def ordinalize(); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.try_convert(arg); end
end

module Interception
  def self.listen(for_block=T.unsafe(nil), &listen_block); end

  def self.listeners(); end

  def self.listeners=(listeners); end

  def self.mutex(); end

  def self.mutex=(mutex); end

  def self.rescue(exception, binding); end

  def self.rescueing(); end

  def self.rescueing=(rescueing); end

  def self.unlisten(listen_block); end
end

class InterruptHandler
  def isolate_signals(); end

  def isolate_signals=(isolate_signals); end

  def reenable_on_interrupt(); end

  def reenable_on_interrupt=(reenable_on_interrupt); end

  def signal_received(); end

  def signal_received=(signal_received); end
end

class InterruptHandler
  def self.disable!(); end

  def self.disable_until_finished_or_interrupted(); end

  def self.enable!(); end

  def self.isolate_from_interrupts(); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::Bootsnap::CompileCache::JSON::Patch
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.load_file(filespec, opts=T.unsafe(nil)); end

  def self.load_file!(filespec, opts=T.unsafe(nil)); end
end

class Jbuilder
  def array!(collection=T.unsafe(nil), *attributes, &block); end

  def attributes!(); end

  def call(object, *attributes, &block); end

  def child!(); end

  def deep_format_keys!(value=T.unsafe(nil)); end

  def extract!(object, *attributes); end

  def ignore_nil!(value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key_format!(*args); end

  def merge!(object); end

  def method_missing(*args, &block); end

  def nil!(); end

  def null!(); end

  def set!(key, value=T.unsafe(nil), *args, &block); end

  def target!(); end
  BLANK = ::T.let(nil, ::T.untyped)
  NON_ENUMERABLES = ::T.let(nil, ::T.untyped)
end

class Jbuilder::ArrayError
end

class Jbuilder::ArrayError
  def self.build(key); end
end

class Jbuilder::Blank
  def ==(other); end

  def empty?(); end
end

class Jbuilder::Blank
end

module Jbuilder::CollectionRenderable
end

module Jbuilder::CollectionRenderable::ClassMethods
  def supported?(); end
end

module Jbuilder::CollectionRenderable::ClassMethods
end

module Jbuilder::CollectionRenderable
  extend ::ActiveSupport::Concern
end

class Jbuilder::CollectionRenderer
  include ::Jbuilder::CollectionRenderable
  def initialize(lookup_context, options, &scope); end
end

class Jbuilder::CollectionRenderer
  extend ::Jbuilder::CollectionRenderable::ClassMethods
end

class Jbuilder::DependencyTracker
  include ::Jbuilder::DependencyTrackerMethods
end

class Jbuilder::DependencyTracker
end

module Jbuilder::DependencyTrackerMethods
  def dependencies(); end
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
end

class Jbuilder::KeyFormatter
  def format(key); end

  def initialize(*args); end
end

class Jbuilder::KeyFormatter
end

class Jbuilder::MergeError
end

class Jbuilder::MergeError
  def self.build(current_value, updates); end
end

class Jbuilder::NullError
end

class Jbuilder::NullError
  def self.build(key); end
end

class Jbuilder::Railtie
end

class Jbuilder::Railtie
end

class Jbuilder
  def self.deep_format_keys(value=T.unsafe(nil)); end

  def self.encode(*args, &block); end

  def self.ignore_nil(value=T.unsafe(nil)); end

  def self.key_format(*args); end
end

class JbuilderHandler
  def default_format(); end

  def default_format=(val); end
end

class JbuilderHandler
  def self.call(template, source=T.unsafe(nil)); end

  def self.default_format(); end

  def self.default_format=(val); end
end

class JbuilderTemplate
  def array!(collection=T.unsafe(nil), *args); end

  def cache!(key=T.unsafe(nil), options=T.unsafe(nil)); end

  def cache_if!(condition, *args, &block); end

  def cache_root!(key=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(context, *args); end

  def partial!(*args); end

  def set!(name, object=T.unsafe(nil), *args); end
end

class JbuilderTemplate
  def self.template_lookup_options(); end

  def self.template_lookup_options=(template_lookup_options); end
end

module Jsbundling
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_partial(*arg); end
end

module Kaminari::Actionview
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::ActiveRecordRelationMethods
  def entry_name(options=T.unsafe(nil)); end

  def reset(); end

  def total_count(column_name=T.unsafe(nil), _options=T.unsafe(nil)); end

  def without_count(); end
end

module Kaminari::Activerecord
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::Helpers
  PARAM_KEY_EXCEPT_LIST = ::T.let(nil, ::T.untyped)
end

module Kaminari::Helpers::HelperMethods
  def link_to_next_page(scope, name, **options); end

  def link_to_prev_page(scope, name, **options); end

  def link_to_previous_page(scope, name, **options); end

  def page_entries_info(collection, entry_name: T.unsafe(nil)); end

  def paginate(scope, paginator_class: T.unsafe(nil), template: T.unsafe(nil), **options); end

  def rel_next_prev_link_tags(scope, options=T.unsafe(nil)); end
end

class Kaminari::Helpers::Paginator
  include ::ActionView::Context
end

module Kaminari::Helpers::UrlHelper
  def next_page_path(scope, options=T.unsafe(nil)); end

  def next_page_url(scope, options=T.unsafe(nil)); end

  def path_to_next_page(scope, options=T.unsafe(nil)); end

  def path_to_next_url(scope, options=T.unsafe(nil)); end

  def path_to_prev_page(scope, options=T.unsafe(nil)); end

  def path_to_previous_page(scope, options=T.unsafe(nil)); end

  def prev_page_path(scope, options=T.unsafe(nil)); end

  def prev_page_url(scope, options=T.unsafe(nil)); end

  def previous_page_path(scope, options=T.unsafe(nil)); end

  def previous_page_url(scope, options=T.unsafe(nil)); end

  def url_to_next_page(scope, options=T.unsafe(nil)); end

  def url_to_prev_page(scope, options=T.unsafe(nil)); end

  def url_to_previous_page(scope, options=T.unsafe(nil)); end
end

class Kaminari::PaginatableArray
  ENTRY = ::T.let(nil, ::T.untyped)
end

module Kaminari::PaginatableWithoutCount
  def last_page?(); end

  def load(); end

  def out_of_range?(); end

  def total_count(); end
end

module Kernel
  include ::DEBUGGER__::TrapInterceptor
  def class_eval(*args, &block); end

  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.autoload(arg, arg1); end

  def self.trap(*arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Kramdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def apply_template_after?(); end

  def apply_template_before?(); end

  def basic_generate_id(str); end

  def convert(_el); end

  def data(); end

  def extract_code_language(attr); end

  def extract_code_language!(attr); end

  def format_math(el, opts=T.unsafe(nil)); end

  def generate_id(str); end

  def highlight_code(text, lang, type, opts=T.unsafe(nil)); end

  def in_toc?(el); end

  def initialize(root, options); end

  def options(); end

  def output_header_level(level); end

  def root(); end

  def smart_quote_entity(el); end

  def warning(text); end

  def warnings(); end
  SMART_QUOTE_INDICES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def self.apply_template(converter, body); end

  def self.convert(tree, options=T.unsafe(nil)); end

  def self.get_template(template); end
end

class Kramdown::Converter::HashAST
  def convert(el); end
end

class Kramdown::Converter::HashAST
end

Kramdown::Converter::HashAst = Kramdown::Converter::HashAST

class Kramdown::Converter::Html
  def add_syntax_highlighter_to_class_attr(attr, lang=T.unsafe(nil)); end

  def convert(el, indent=T.unsafe(nil)); end

  def convert_a(el, indent); end

  def convert_abbreviation(el, _indent); end

  def convert_blank(_el, _indent); end

  def convert_blockquote(el, indent); end

  def convert_br(_el, _indent); end

  def convert_codeblock(el, indent); end

  def convert_codespan(el, _indent); end

  def convert_comment(el, indent); end

  def convert_dd(el, indent); end

  def convert_dl(el, indent); end

  def convert_dt(el, indent); end

  def convert_em(el, indent); end

  def convert_entity(el, _indent); end

  def convert_footnote(el, _indent); end

  def convert_header(el, indent); end

  def convert_hr(el, indent); end

  def convert_html_element(el, indent); end

  def convert_img(el, _indent); end

  def convert_li(el, indent); end

  def convert_math(el, indent); end

  def convert_ol(el, indent); end

  def convert_p(el, indent); end

  def convert_raw(el, _indent); end

  def convert_root(el, indent); end

  def convert_smart_quote(el, _indent); end

  def convert_standalone_image(el, indent); end

  def convert_strong(el, indent); end

  def convert_table(el, indent); end

  def convert_tbody(el, indent); end

  def convert_td(el, indent); end

  def convert_text(el, _indent); end

  def convert_tfoot(el, indent); end

  def convert_thead(el, indent); end

  def convert_tr(el, indent); end

  def convert_typographic_sym(el, _indent); end

  def convert_ul(el, indent); end

  def convert_xml_comment(el, indent); end

  def convert_xml_pi(el, indent); end

  def fix_for_toc_entry(elements); end

  def footnote_content(); end

  def format_as_block_html(name, attr, body, indent); end

  def format_as_indented_block_html(name, attr, body, indent); end

  def format_as_span_html(name, attr, body); end

  def generate_toc_tree(toc, type, attr); end

  def indent(); end

  def indent=(indent); end

  def inner(el, indent); end

  def obfuscate(text); end

  def remove_footnotes(elements); end

  def unwrap_links(elements); end
  ENTITY_NBSP = ::T.let(nil, ::T.untyped)
  FOOTNOTE_BACKLINK_FMT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
  include ::Kramdown::Utils::Html
  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, _opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, _opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, _opts); end

  def convert_header(el, opts); end

  def convert_hr(_el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, _opts); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(el, _opts); end

  def create_abbrev_defs(); end

  def create_footnote_defs(); end

  def create_link_defs(); end

  def ial_for_element(el); end

  def inner(el, opts=T.unsafe(nil)); end

  def parse_title(attr); end
  ESCAPED_CHAR_RE = ::T.let(nil, ::T.untyped)
  HTML_TAGS_WITH_BODY = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
  def attribute_list(el); end

  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_standalone_image(el, _opts, img); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, _opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(_el, _opts); end

  def entity_to_latex(entity); end

  def escape(str); end

  def inner(el, opts); end

  def latex_environment(type, el, text); end

  def latex_link_target(el, add_label=T.unsafe(nil)); end

  def normalize_abbreviation_key(key); end
  ENTITY_CONV_TABLE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  TABLE_ALIGNMENT_CHAR = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
end

class Kramdown::Converter::Man
  def convert(el, opts=T.unsafe(nil)); end
  TABLE_CELL_ALIGNMENT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_MAP = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Man
end

class Kramdown::Converter::RemoveHtmlTags
  def convert(el); end
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::Toc
  def convert(el); end
end

class Kramdown::Converter::Toc
end

module Kramdown::Converter
  extend ::Kramdown::Utils::Configurable
end

class Kramdown::Element
  CATEGORY = ::T.let(nil, ::T.untyped)
end

module Kramdown::Options
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Base
  def adapt_source(source); end

  def add_text(text, tree=T.unsafe(nil), type=T.unsafe(nil)); end

  def extract_string(range, strscan); end

  def initialize(source, options); end

  def options(); end

  def parse(); end

  def root(); end

  def source(); end

  def warning(text); end

  def warnings(); end
end

class Kramdown::Parser::Base
  def self.parse(source, options=T.unsafe(nil)); end
end

class Kramdown::Parser::GFM
  def generate_gfm_header_id(text); end

  def parse_atx_header_gfm_quirk(); end

  def parse_strikethrough_gfm(); end

  def update_elements(element); end
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS_GFM = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  LIST_TYPES = ::T.let(nil, ::T.untyped)
  NON_WORD_RE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END_GFM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_DELIM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_MATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Constants
  HTML_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_COMMENT_RE = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_BLOCK = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_RAW = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_SPAN = ::T.let(nil, ::T.untyped)
  HTML_DOCTYPE_RE = ::T.let(nil, ::T.untyped)
  HTML_ELEMENT = ::T.let(nil, ::T.untyped)
  HTML_ELEMENTS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  HTML_ENTITY_RE = ::T.let(nil, ::T.untyped)
  HTML_INSTRUCTION_RE = ::T.let(nil, ::T.untyped)
  HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_TAG_CLOSE_RE = ::T.let(nil, ::T.untyped)
  HTML_TAG_RE = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def convert_a(el); end

  def convert_b(el); end

  def convert_code(el); end

  def convert_em(el); end

  def convert_h1(el); end

  def convert_h2(el); end

  def convert_h3(el); end

  def convert_h4(el); end

  def convert_h5(el); end

  def convert_h6(el); end

  def convert_i(el); end

  def convert_pre(el); end

  def convert_script(el); end

  def convert_strong(el); end

  def convert_table(el); end

  def convert_textarea(el); end

  def extract_text(el, raw); end

  def handle_math_tag(el); end

  def initialize(root); end

  def is_math_tag?(el); end

  def is_simple_table?(el); end

  def process(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil), parent=T.unsafe(nil)); end

  def process_children(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_html_element(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_text(raw, preserve=T.unsafe(nil)); end

  def remove_text_children(el); end

  def remove_whitespace_children(el); end

  def set_basics(el, type, opts=T.unsafe(nil)); end

  def strip_whitespace(el); end

  def wrap_text_children(el); end
  EMPHASIS_TYPE_MAP = ::T.let(nil, ::T.untyped)
  REMOVE_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
  REMOVE_WHITESPACE_CHILDREN = ::T.let(nil, ::T.untyped)
  SIMPLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  STRIP_WHITESPACE = ::T.let(nil, ::T.untyped)
  WRAP_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def self.convert(root, el=T.unsafe(nil)); end
end

module Kramdown::Parser::Html::Parser
  def handle_html_start_tag(line=T.unsafe(nil)); end

  def handle_raw_html_tag(name); end

  def parse_html_attributes(str, line=T.unsafe(nil), in_html_tag=T.unsafe(nil)); end

  def parse_raw_html(el, &block); end
  HTML_RAW_START = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown
  def add_header(level, text, id); end

  def add_link(el, href, title, alt_text=T.unsafe(nil), ial=T.unsafe(nil)); end

  def after_block_boundary?(); end

  def before_block_boundary?(); end

  def configure_parser(); end

  def correct_abbreviations_attributes(); end

  def handle_extension(name, opts, body, type, line_no=T.unsafe(nil)); end

  def handle_kramdown_html_tag(el, closed, handle_body); end

  def new_block_el(*args); end

  def normalize_link_id(id); end

  def paragraph_end(); end

  def parse_abbrev_definition(); end

  def parse_attribute_list(str, opts); end

  def parse_atx_header(); end

  def parse_autolink(); end

  def parse_blank_line(); end

  def parse_block_extensions(); end

  def parse_block_html(); end

  def parse_block_math(); end

  def parse_blockquote(); end

  def parse_blocks(el, text=T.unsafe(nil)); end

  def parse_codeblock(); end

  def parse_codeblock_fenced(); end

  def parse_codespan(); end

  def parse_definition_list(); end

  def parse_emphasis(); end

  def parse_eob_marker(); end

  def parse_escaped_chars(); end

  def parse_extension_start_tag(type); end

  def parse_first_list_line(indentation, content); end

  def parse_footnote_definition(); end

  def parse_footnote_marker(); end

  def parse_header_contents(); end

  def parse_horizontal_rule(); end

  def parse_html_entity(); end

  def parse_inline_math(); end

  def parse_line_break(); end

  def parse_link(); end

  def parse_link_definition(); end

  def parse_list(); end

  def parse_paragraph(); end

  def parse_setext_header(); end

  def parse_smart_quotes(); end

  def parse_span_extensions(); end

  def parse_span_html(); end

  def parse_spans(el, stop_re=T.unsafe(nil), parsers=T.unsafe(nil), text_type=T.unsafe(nil)); end

  def parse_table(); end

  def parse_typographic_syms(); end

  def replace_abbreviations(el, regexps=T.unsafe(nil)); end

  def reset_env(opts=T.unsafe(nil)); end

  def restore_env(env); end

  def save_env(); end

  def span_parser_regexps(parsers=T.unsafe(nil)); end

  def update_attr_with_ial(attr, ial); end

  def update_ial_with_ial(ial, opts); end

  def update_link_definitions(link_defs); end

  def update_raw_text(item); end

  def update_tree(element); end
  ABBREV_DEFINITION_START = ::T.let(nil, ::T.untyped)
  ACHARS = ::T.let(nil, ::T.untyped)
  ALD_ANY_CHARS = ::T.let(nil, ::T.untyped)
  ALD_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_ID_CHARS = ::T.let(nil, ::T.untyped)
  ALD_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_START = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ANY = ::T.let(nil, ::T.untyped)
  ALD_TYPE_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS_MULTI = ::T.let(nil, ::T.untyped)
  ALD_TYPE_KEY_VALUE_PAIR = ::T.let(nil, ::T.untyped)
  ALD_TYPE_REF = ::T.let(nil, ::T.untyped)
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START_STR = ::T.let(nil, ::T.untyped)
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  BLOCKQUOTE_START = ::T.let(nil, ::T.untyped)
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  BLOCK_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  BLOCK_MATH_START = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  CODESPAN_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFINITION_LIST_START = ::T.let(nil, ::T.untyped)
  EMPHASIS_START = ::T.let(nil, ::T.untyped)
  EOB_MARKER = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_START = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_STOP_STR = ::T.let(nil, ::T.untyped)
  EXT_SPAN_START = ::T.let(nil, ::T.untyped)
  EXT_START_STR = ::T.let(nil, ::T.untyped)
  EXT_STOP_STR = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_DEFINITION_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_MARKER_START = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  HR_START = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_START = ::T.let(nil, ::T.untyped)
  HTML_MARKDOWN_ATTR_MAP = ::T.let(nil, ::T.untyped)
  HTML_SPAN_START = ::T.let(nil, ::T.untyped)
  IAL_BLOCK = ::T.let(nil, ::T.untyped)
  IAL_BLOCK_START = ::T.let(nil, ::T.untyped)
  IAL_CLASS_ATTR = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  INLINE_MATH_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_START = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_STOP = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINK_BRACKET_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_DEFINITION_START = ::T.let(nil, ::T.untyped)
  LINK_INLINE_ID_RE = ::T.let(nil, ::T.untyped)
  LINK_INLINE_TITLE_RE = ::T.let(nil, ::T.untyped)
  LINK_PAREN_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_START = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL_CHECK = ::T.let(nil, ::T.untyped)
  LIST_START = ::T.let(nil, ::T.untyped)
  LIST_START_OL = ::T.let(nil, ::T.untyped)
  LIST_START_UL = ::T.let(nil, ::T.untyped)
  OPT_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
  PARAGRAPH_MATCH = ::T.let(nil, ::T.untyped)
  PARAGRAPH_START = ::T.let(nil, ::T.untyped)
  PARSE_FIRST_LIST_LINE_REGEXP_CACHE = ::T.let(nil, ::T.untyped)
  PATTERN_TAIL = ::T.let(nil, ::T.untyped)
  SETEXT_HEADER_START = ::T.let(nil, ::T.untyped)
  SMART_QUOTES_RE = ::T.let(nil, ::T.untyped)
  SPAN_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  SQ_CLOSE = ::T.let(nil, ::T.untyped)
  SQ_PUNCT = ::T.let(nil, ::T.untyped)
  SQ_RULES = ::T.let(nil, ::T.untyped)
  SQ_SUBSTS = ::T.let(nil, ::T.untyped)
  TABLE_FSEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_HSEP_ALIGN = ::T.let(nil, ::T.untyped)
  TABLE_LINE = ::T.let(nil, ::T.untyped)
  TABLE_PIPE_CHECK = ::T.let(nil, ::T.untyped)
  TABLE_ROW_LINE = ::T.let(nil, ::T.untyped)
  TABLE_SEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_START = ::T.let(nil, ::T.untyped)
  TRAILING_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_RE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_SUBST = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown::Data
  def method(); end

  def method=(_); end

  def name(); end

  def name=(_); end

  def span_start(); end

  def span_start=(_); end

  def start_re(); end

  def start_re=(_); end
end

class Kramdown::Parser::Kramdown::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Kramdown::Parser::Kramdown
  def self.define_parser(name, start_re, span_start=T.unsafe(nil), meth_name=T.unsafe(nil)); end

  def self.has_parser?(name); end

  def self.parser(name=T.unsafe(nil)); end
end

class Kramdown::Parser::Markdown
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  IAL_RAND_CHARS = ::T.let(nil, ::T.untyped)
  IAL_RAND_STRING = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
end

module Kramdown::Utils::Entities
  ENTITY_MAP = ::T.let(nil, ::T.untyped)
  ENTITY_TABLE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Entities
  def self.entity(point_or_name); end
end

module Kramdown::Utils::Html
  def entity_to_str(e, original=T.unsafe(nil)); end

  def escape_html(str, type=T.unsafe(nil)); end

  def fix_cjk_line_break(str); end

  def html_attributes(attr); end
  ESCAPE_ALL_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE_FROM_TYPE = ::T.let(nil, ::T.untyped)
  ESCAPE_TEXT_RE = ::T.let(nil, ::T.untyped)
  REDUNDANT_LINE_BREAK_REGEX = ::T.let(nil, ::T.untyped)
end

class Kramdown::Utils::LRUCache
  def [](key); end

  def []=(key, value); end

  def initialize(size); end
end

class Kramdown::Utils::LRUCache
end

class Kramdown::Utils::StringScanner
  def current_line_number(); end

  def initialize(string, start_line_number=T.unsafe(nil)); end

  def pos=(pos); end

  def revert_pos(data); end

  def save_pos(); end

  def start_line_number(); end
end

class Kramdown::Utils::StringScanner
end

module Kwalify
  META_VALIDATOR = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
end

class Kwalify::AssertionError
  def initialize(msg); end
end

class Kwalify::BaseError
  def _to_s(); end

  def column(); end

  def column=(column); end

  def error_symbol(); end

  def error_symbol=(error_symbol); end

  def filename(); end

  def filename=(filename); end

  def initialize(message=T.unsafe(nil), path=T.unsafe(nil), value=T.unsafe(nil), rule=T.unsafe(nil), error_symbol=T.unsafe(nil)); end

  def linenum(); end

  def linenum=(linenum); end

  def path(); end

  def path=(path); end

  def rule(); end

  def rule=(rule); end

  def value(); end

  def value=(value); end
end

class Kwalify::BaseParser
  def _getch(); end

  def _set_column_and_linenum(s); end

  def _syntax_error(message, path=T.unsafe(nil), linenum=T.unsafe(nil), column=T.unsafe(nil)); end

  def column(); end

  def eos?(); end

  def filename(); end

  def group(n); end

  def linenum(); end

  def match?(regexp); end

  def peep(n=T.unsafe(nil)); end

  def reset(input, filename=T.unsafe(nil), untabify=T.unsafe(nil)); end

  def scan(regexp); end

  def scan_string(); end
  CHAR_TABLE = ::T.let(nil, ::T.untyped)
end

module Kwalify::ErrorHelper
  def assert_error(message=T.unsafe(nil)); end

  def schema_error(error_symbol, rule, path, val, args=T.unsafe(nil)); end
end

module Kwalify::ErrorHelper
  def self._build_message(message_key, val, args); end

  def self.validate_error(error_symbol, rule, path, val, args=T.unsafe(nil)); end
end

class Kwalify::MetaValidator
  def initialize(schema, &block); end
  META_SCHEMA = ::T.let(nil, ::T.untyped)
end

class Kwalify::MetaValidator
  def self.instance(); end
end

class Kwalify::Parser
  def initialize(yaml_str); end
end

class Kwalify::PlainYamlParser
  def add_to_map(map, key, value, linenum); end

  def add_to_seq(seq, value, linenum); end

  def create_mapping(linenum=T.unsafe(nil)); end

  def create_scalar(value, linenum=T.unsafe(nil)); end

  def create_sequence(linenum=T.unsafe(nil)); end

  def current_line(); end

  def current_linenum(); end

  def has_next?(); end

  def initialize(yaml_str); end

  def merge_map(map, map2, linenum); end

  def parse(); end

  def parse_all(); end

  def set_default(map, value, linenum); end

  def set_map_with(map, key, value, linenum); end

  def set_seq_at(seq, i, value, linenum); end
end

class Kwalify::PlainYamlParser::Alias
  def initialize(label, linenum); end

  def label(); end

  def linenum(); end
end

class Kwalify::Rule
  def _init(hash, path=T.unsafe(nil), rule_table=T.unsafe(nil)); end

  def _inspect(str=T.unsafe(nil), level=T.unsafe(nil), done=T.unsafe(nil)); end

  def _uniqueness_check_table(); end

  def assert(); end

  def assert_proc(); end

  def classname(); end

  def classobj(); end

  def default(); end

  def desc(); end

  def enum(); end

  def get_init_method(sym); end

  def ident(); end

  def initialize(hash=T.unsafe(nil), parent=T.unsafe(nil)); end

  def length(); end

  def mapping(); end

  def name(); end

  def parent(); end

  def parent=(parent); end

  def pattern(); end

  def range(); end

  def regexp(); end

  def required(); end

  def sequence(); end

  def type(); end

  def type_class(); end

  def unique(); end
end

class Kwalify::SchemaError
  def initialize(message=T.unsafe(nil), path=T.unsafe(nil), rule=T.unsafe(nil), value=T.unsafe(nil), error_symbol=T.unsafe(nil)); end
end

class Kwalify::SyntaxError
  def initialize(msg, linenum=T.unsafe(nil), error_symbol=T.unsafe(nil)); end
end

module Kwalify::Types
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

module Kwalify::Types
  def self.collection?(val); end

  def self.collection_type?(type); end

  def self.get_type_class(type); end

  def self.scalar?(val); end

  def self.scalar_type?(type); end

  def self.type_class(type); end

  def self.type_table(); end
end

module Kwalify::Util::HashLike
  def [](key); end

  def []=(key, val); end

  def each(&blk); end

  def key?(key); end
end

module Kwalify::Util::HashLike
end

module Kwalify::Util
  def self._traverse_rule(rule, _done=T.unsafe(nil), &block); end

  def self._traverse_schema(hash, _done=T.unsafe(nil), &block); end

  def self.create_hashtable(hashlist, primarykey, flag_duplicate_check=T.unsafe(nil)); end

  def self.get_class(classname); end

  def self.get_value(obj, path); end

  def self.traverse_rule(validator, &block); end

  def self.traverse_schema(schema, &block); end

  def self.untabify(str, width=T.unsafe(nil)); end
end

class Kwalify::ValidationError
  def initialize(message=T.unsafe(nil), path=T.unsafe(nil), rule=T.unsafe(nil), value=T.unsafe(nil), error_symbol=T.unsafe(nil)); end
end

class Kwalify::Validator
  def _inspect(); end

  def _validate(value, rule, path, errors, done, uniq_table, recursive=T.unsafe(nil)); end

  def _validate_mapping_required_keys(hash, map_rule, path, errors); end

  def _validate_unique(value, rule, path, errors, uniq_table); end

  def initialize(hash_or_rule, &block); end

  def rule(); end

  def validate(value); end

  def validate_hook(value, rule, path, errors); end
end

class Kwalify::Yaml::Parser
  def _getclass(classname); end

  def _parse_map_value(map, map_rule, path, level, key, is_merged, uniq_table, _linenum, _column, _linenum2, _column2); end

  def _set_error_info(linenum=T.unsafe(nil), column=T.unsafe(nil), &block); end

  def _validate_map_value(map, map_rule, rule, path, uniq_table, key, val, _linenum, _column); end

  def add_to_seq(rule, seq, val, linenum, column); end

  def create_mapping(rule, linenum, column); end

  def create_scalar(rule, value, linenum, column); end

  def create_sequence(rule, linenum, column); end

  def data_binding(); end

  def data_binding=(data_binding); end

  def document_start?(); end

  def errors(); end

  def has_next?(); end

  def initialize(validator=T.unsafe(nil), properties=T.unsafe(nil)); end

  def location(path); end

  def mapping_class(); end

  def mapping_class=(mapping_class); end

  def parse(input=T.unsafe(nil), opts=T.unsafe(nil)); end

  def parse_alias(rule, path, uniq_table, container); end

  def parse_anchor(rule, path, uniq_table, container); end

  def parse_block_map(map, map_rule, path, uniq_table); end

  def parse_block_scalar(rule, path, uniq_table); end

  def parse_block_seq(seq, seq_rule, path, uniq_table); end

  def parse_block_text(column, rule, path, uniq_table); end

  def parse_block_value(level, rule, path, uniq_table, container); end

  def parse_documents(input, opts=T.unsafe(nil), &block); end

  def parse_file(filename, opts=T.unsafe(nil)); end

  def parse_flow_map(map, map_rule, path, uniq_table); end

  def parse_flow_scalar(rule, path, uniq_table); end

  def parse_flow_seq(seq, seq_rule, path, uniq_table); end

  def parse_flow_value(rule, path, uniq_table, container); end

  def parse_next(); end

  def parse_stream(input, opts=T.unsafe(nil), &block); end

  def preceding_alias(); end

  def preceding_alias=(preceding_alias); end

  def put_to_map(rule, map, key, val, linenum, column); end

  def reset_parser(); end

  def reset_scanner(input, filename=T.unsafe(nil), untabify=T.unsafe(nil)); end

  def resolve_preceding_aliases(val); end

  def sequence_class(); end

  def sequence_class=(sequence_class); end

  def set_errors_linenum(errors); end

  def skip_spaces_and_comments(); end

  def stream_end?(); end

  def to_scalar(str); end

  def validator(); end

  def validator=(validator); end
  MAPKEY_PATTERN = ::T.let(nil, ::T.untyped)
  PRECEDING_ALIAS_PLACEHOLDER = ::T.let(nil, ::T.untyped)
end

module Kwalify::Yaml
  def self.load(yaml_str, opts=T.unsafe(nil)); end

  def self.load_file(filename, opts=T.unsafe(nil)); end
end

class Kwalify::YamlParser
  def initialize(*args); end

  def merge_map(map, collection, linenum); end

  def path_linenum(path); end

  def set_error_linenums(errors); end

  def set_errors_linenum(errors); end
end

module Kwalify
  def self.meta_validator(); end

  def self.msg(key); end

  def self.word(key); end
end

module Launchy
  VERSION = ::T.let(nil, ::T.untyped)
end

class Launchy::Application
  def find_executable(bin, *paths); end

  def host_os_family(); end

  def ruby_engine(); end

  def run(cmd, *args); end

  def runner(); end
end

class Launchy::Application::Browser
  def app_list(); end

  def browser_cmdline(); end

  def browser_env(); end

  def cmd_and_args(uri, options=T.unsafe(nil)); end

  def cygwin_app_list(); end

  def darwin_app_list(); end

  def nix_app_list(); end

  def open(uri, options=T.unsafe(nil)); end

  def windows_app_list(); end
end

class Launchy::Application::Browser
  def self.handles?(uri); end

  def self.schemes(); end
end

class Launchy::Application
  def self.find_executable(bin, *paths); end

  def self.handling(uri); end
end

class Launchy::Argv
  def ==(other); end

  def [](idx); end

  def argv(); end

  def executable?(); end

  def initialize(*args); end

  def to_str(); end

  def valid?(); end
end

class Launchy::Browser
  def visit(url); end
end

class Launchy::Browser
  def self.run(*args); end
end

class Launchy::Cli
  def error_output(error); end

  def good_run(argv, env); end

  def options(); end

  def parse(argv, env); end

  def parser(); end

  def run(argv=T.unsafe(nil), env=T.unsafe(nil)); end
end

module Launchy::DescendantTracker
  def children(); end

  def find_child(method, *args); end

  def inherited(klass); end
end

class Launchy::Detect::HostOs
  def default_host_os(); end

  def host_os(); end

  def initialize(host_os=T.unsafe(nil)); end

  def override_host_os(); end

  def to_str(); end
end

class Launchy::Detect::HostOsFamily
  def cygwin?(); end

  def darwin?(); end

  def host_os(); end

  def initialize(host_os=T.unsafe(nil)); end

  def nix?(); end

  def windows?(); end
end

class Launchy::Detect::HostOsFamily::Cygwin
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Cygwin
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Darwin
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Darwin
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Nix
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Nix
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Windows
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Windows
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily
  def self.cygwin?(); end

  def self.darwin?(); end

  def self.detect(host_os=T.unsafe(nil)); end

  def self.matches?(host_os); end

  def self.nix?(); end

  def self.windows?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Gnome
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Kde
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::NotFound
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Xdg
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Xfce
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment
  def self.browsers(); end

  def self.detect(); end

  def self.fallback_browsers(); end
end

class Launchy::Detect::RubyEngine
  def initialize(ruby_engine=T.unsafe(nil)); end

  def ruby_engine(); end
end

class Launchy::Detect::RubyEngine::Jruby
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::MacRuby
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::Mri
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::Rbx
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine
  def self.detect(ruby_engine=T.unsafe(nil)); end

  def self.is_current_engine?(ruby_engine); end

  def self.jruby?(); end

  def self.macruby?(); end

  def self.mri?(); end

  def self.rbx?(); end

  def self.ruby_engine_error_message(ruby_engine); end
end

class Launchy::Detect::Runner
  def commandline_normalize(cmdline); end

  def dry_run(cmd, *args); end

  def run(cmd, *args); end

  def shell_commands(cmd, args); end
end

class Launchy::Detect::Runner::Forkable
  def child_pid(); end

  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner::Jruby
  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner::Windows
  def all_args(cmd, *args); end

  def shell_commands(cmd, *args); end

  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner
  def self.detect(); end
end

module Launchy::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
end

module Launchy::Version
  def self.to_a(); end
end

module Launchy
  def self.app_for_uri(uri); end

  def self.app_for_uri_string(s); end

  def self.application(); end

  def self.application=(app); end

  def self.bug_report_message(); end

  def self.debug=(d); end

  def self.debug?(); end

  def self.dry_run=(dry_run); end

  def self.dry_run?(); end

  def self.extract_global_options(options); end

  def self.host_os(); end

  def self.host_os=(host_os); end

  def self.log(msg); end

  def self.open(uri_s, options=T.unsafe(nil), &error_block); end

  def self.path(); end

  def self.path=(path); end

  def self.reset_global_options(); end

  def self.ruby_engine(); end

  def self.ruby_engine=(ruby_engine); end

  def self.string_to_uri(s); end
end

class LetterOpener::Configuration
  def file_uri_scheme(); end

  def file_uri_scheme=(file_uri_scheme); end

  def location(); end

  def location=(location); end

  def message_template(); end

  def message_template=(message_template); end
end

class LetterOpener::Configuration
end

class LetterOpener::DeliveryMethod
  def deliver!(mail); end

  def initialize(options=T.unsafe(nil)); end

  def settings(); end

  def settings=(settings); end
end

class LetterOpener::Message
  def attachment_filename(attachment); end

  def auto_link(text); end

  def bcc(); end

  def body(); end

  def cc(); end

  def content_type(); end

  def encoding(); end

  def filepath(); end

  def from(); end

  def h(content); end

  def initialize(mail, options=T.unsafe(nil)); end

  def mail(); end

  def render(); end

  def reply_to(); end

  def sender(); end

  def subject(); end

  def template(); end

  def to(); end

  def type(); end
  ERROR_MSG = ::T.let(nil, ::T.untyped)
end

class LetterOpener::Message
  def self.rendered_messages(mail, options=T.unsafe(nil)); end
end

module LetterOpener
  def self.configuration(); end

  def self.configure(); end
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Event::Loop
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Listener::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Silencer
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_FILES = ::T.let(nil, ::T.untyped)
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  INLINE_LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINEBREAKERS = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_IMPORTANT = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
  CSS_PROPERTY_STRING_WITHOUT_EMBEDDED_QUOTES = ::T.let(nil, ::T.untyped)
  DATA_ATTRIBUTE_NAME = ::T.let(nil, ::T.untyped)
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other_address); end

  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(&blk); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(*arg); end

  def regular_writer(arg, arg1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addresses(); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addresses(); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_address(); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def recipients(); end

  def recipients_addresses(); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addresses(); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end

  def x_original_to_addresses(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::ParserTools
  def chars(data, from_bytes, to_bytes); end
end

module Mail::ParserTools
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  def self.version(); end
end

module Mail
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.from_source(source); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

module Marcel
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  MAGIC = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class MatchData
  def match(arg); end

  def match_length(arg); end
end

class Matrix
  def *(m); end

  def **(exp); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def abs(); end

  def adjoint(); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def power_int(exp); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def rotate_entries(rotation=T.unsafe(nil)); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

class Matrix::EigenvalueDecomposition
  def initialize(a); end
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

module MessagePack
  DEFAULT_EMPTY_PARAMS = ::T.let(nil, ::T.untyped)
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

class Method
  def private?(); end

  def protected?(); end

  def public?(); end
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&block); end

  def symbols(); end
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def match?(mime_type); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type::InvalidMimeType
end

class Mime::Type::InvalidMimeType
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type, &block); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Result
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::Test
  def capture_exceptions(); end

  def sanitize_exception(e); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

class Minitest::Test
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

class Module
  def class_name(); end

  def singleton_method_added(mid); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
  def <<(arg); end

  def [](arg); end

  def capacity(); end

  def clear(); end

  def each(&blk); end

  def flip(); end

  def full?(); end

  def get(*arg); end

  def initialize(arg); end

  def limit(); end

  def limit=(limit); end

  def mark(); end

  def position(); end

  def position=(position); end

  def read_from(arg); end

  def remaining(); end

  def reset(); end

  def rewind(); end

  def size(); end

  def write_to(arg); end
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer
end

class NIO::Monitor
  def add_interest(arg); end

  def close(*arg); end

  def closed?(); end

  def initialize(arg, arg1, arg2); end

  def interests(); end

  def interests=(interests); end

  def io(); end

  def readable?(); end

  def readiness(); end

  def remove_interest(arg); end

  def selector(); end

  def value(); end

  def value=(value); end

  def writable?(); end

  def writeable?(); end
end

class NIO::Monitor
end

class NIO::Selector
  def backend(); end

  def close(); end

  def closed?(); end

  def deregister(arg); end

  def empty?(); end

  def initialize(*arg); end

  def register(arg, arg1); end

  def registered?(arg); end

  def wakeup(); end
end

class NIO::Selector
  def self.backends(); end
end

module NIO
  def self.engine(); end

  def self.pure?(env=T.unsafe(nil)); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

module NestedForm::BuilderMixin
  def fields_for_nested_model(name, object, options, block); end

  def fields_for_with_nested_attributes(association_name, *args); end

  def link_to_add(*args, &block); end

  def link_to_remove(*args, &block); end
end

class NestedForm::SimpleBuilder
end

module NestedForm::ViewHelper
  def after_nested_form(association, &block); end

  def nested_form_for(*args, &block); end

  def simple_nested_form_for(*args, &block); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::HTTP
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPResponseReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def id(client_id=T.unsafe(nil)); end

  def idle_response_timeout(); end

  def namespace(); end

  def open_timeout(); end
  ALL = ::T.let(nil, ::T.untyped)
  ARCHIVE = ::T.let(nil, ::T.untyped)
  DRAFTS = ::T.let(nil, ::T.untyped)
  HAS_CHILDREN = ::T.let(nil, ::T.untyped)
  HAS_NO_CHILDREN = ::T.let(nil, ::T.untyped)
  JUNK = ::T.let(nil, ::T.untyped)
  NONEXISTENT = ::T.let(nil, ::T.untyped)
  REMOTE = ::T.let(nil, ::T.untyped)
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
  SENT = ::T.let(nil, ::T.untyped)
  SUBSCRIBED = ::T.let(nil, ::T.untyped)
  TRASH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::Authenticators
  def add_authenticator(auth_type, authenticator); end

  def authenticator(auth_type, *args); end
end

module Net::IMAP::Authenticators
end

class Net::IMAP::ClientID
  def initialize(data); end

  def send_data(imap, tag); end

  def validate(); end
end

class Net::IMAP::ClientID
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespaces
end

class Net::IMAP::Namespaces
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

class Net::IMAP::PlainAuthenticator
  NULL = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::ResponseParser
  ASTRING_CHARS_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::ResponseParser::Token
  def self.keyword_init?(); end
end

module Net::IMAP::StringFormatter
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringFormatter
  def self.nstring(str); end

  def self.string(str); end

  def self.valid_nstring?(str); end

  def self.valid_string?(str); end
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP
  extend ::Net::IMAP::Authenticators
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::SMTP
  VERSION = ::T.let(nil, ::T.untyped)
end

Net::SMTPSession = Net::SMTP

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::FriendlyId::UnfriendlyUtils
  def to_d(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

module NoProxyFix
  VERSION = ::T.let(nil, ::T.untyped)
end

module Nokogiri
  LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  LIBXML_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_MEMORY_MANAGEMENT = ::T.let(nil, ::T.untyped)
  LIBXSLT_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_DATETIME_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXSLT_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  OTHER_LIBRARY_VERSIONS = ::T.let(nil, ::T.untyped)
  PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  PRECOMPILED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  CACHE_SWITCH_NAME = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::XPathVisitor
  WILDCARD_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::BuiltinsConfig
  ALWAYS = ::T.let(nil, ::T.untyped)
  NEVER = ::T.let(nil, ::T.untyped)
  OPTIMAL = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::DoctypeConfig
  HTML4 = ::T.let(nil, ::T.untyped)
  HTML5 = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
end

module Nokogiri::ClassResolver
  VALID_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Gumbo
  DEFAULT_MAX_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_TREE_DEPTH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML4
end

class Nokogiri::HTML4::ElementDescription
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML4::ElementDescription
end

module Nokogiri::HTML4
end

module Nokogiri::HTML4
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML4::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML5
  HTML_NAMESPACE = ::T.let(nil, ::T.untyped)
  MATHML_NAMESPACE = ::T.let(nil, ::T.untyped)
  SVG_NAMESPACE = ::T.let(nil, ::T.untyped)
  XLINK_NAMESPACE = ::T.let(nil, ::T.untyped)
  XMLNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  XML_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Builder
  DEFAULT_DOCUMENT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::CDATA
  def content_without_cdata_tokens(); end
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  include ::Nokogiri::HTML5::Node
  def converted_to_haml(); end

  def converted_to_haml=(converted_to_haml); end

  def to_haml(tabs, options); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  def to_haml(tabs, options); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  BIG_LINES = ::T.let(nil, ::T.untyped)
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DEFAULT_XSLT = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::XPath
  CURRENT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  ROOT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  SUBTREE_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
end

class Numeric
  include ::FriendlyId::UnfriendlyUtils
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::FriendlyId::ObjectUtils
  include ::PP::ObjectMixin
  include ::RequireAll
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  include ::DEBUGGER__::TrapInterceptor
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_WAIT_TIME = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  HAML_TAGS = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  UI = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

module ObjectSpace
  def self.allocation_class_path(arg); end

  def self.allocation_generation(arg); end

  def self.allocation_method_id(arg); end

  def self.allocation_sourcefile(arg); end

  def self.allocation_sourceline(arg); end

  def self.count_imemo_objects(*arg); end

  def self.count_nodes(*arg); end

  def self.count_objects_size(*arg); end

  def self.count_symbols(*arg); end

  def self.count_tdata_objects(*arg); end

  def self.dump(obj, output: T.unsafe(nil)); end

  def self.dump_all(output: T.unsafe(nil), full: T.unsafe(nil), since: T.unsafe(nil)); end

  def self.internal_class_of(arg); end

  def self.internal_super_of(arg); end

  def self.memsize_of(arg); end

  def self.memsize_of_all(*arg); end

  def self.reachable_objects_from(arg); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

module Observable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Octokit
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  RATE_LIMITED_ERRORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Octokit::Client
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::ServiceStatus
  STATUS_ROOT = ::T.let(nil, ::T.untyped)
end

module Octokit::Connection
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Default
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  WEB_ENDPOINT = ::T.let(nil, ::T.untyped)
end

Octokit::Default::RACK_BUILDER_CLASS = Faraday::RackBuilder

class Octokit::Middleware::FollowRedirects
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class Octokit::OneTimePasswordRequired
  OTP_DELIVERY_PATTERN = ::T.let(nil, ::T.untyped)
end

module Octokit::Preview
  PREVIEW_TYPES = ::T.let(nil, ::T.untyped)
end

class Octokit::Repository
  NAME_WITH_OWNER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Octokit
  extend ::Octokit::Configurable
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def getbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::HMAC
  def ==(other); end

  def base64digest(); end
end

class OpenSSL::HMAC
  def self.base64digest(digest, key, data); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*arg); end

  def self.pbkdf2_hmac(*arg); end

  def self.scrypt(*arg); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def finished_message(); end

  def peer_finished_message(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  def self.open(remote_host, remote_port, local_host=T.unsafe(nil), local_port=T.unsafe(nil), context: T.unsafe(nil)); end
end

module OpenSSL::SSL::SocketForwarder
  def fileno(); end
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end

  def self.fixed_length_secure_compare(arg, arg1); end

  def self.secure_compare(a, b); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def taint!(); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_s!(); end

  def trust!(); end

  def untaint!(); end

  def untrust!(); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

module OrmAdapter
  VERSION = ::T.let(nil, ::T.untyped)
end

module Overcommit
  BUG_REPORT_URL = ::T.let(nil, ::T.untyped)
  CONFIG_FILE_NAME = ::T.let(nil, ::T.untyped)
  GIT_VERSION = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
  HOOK_DIRECTORY = ::T.let(nil, ::T.untyped)
  REPO_URL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Overcommit::CommandSplitter::Result
  def status(); end

  def statuses(); end

  def statuses=(_); end

  def stderr(); end

  def stderrs(); end

  def stderrs=(_); end

  def stdout(); end

  def stdouts(); end

  def stdouts=(_); end

  def success?(); end
end

class Overcommit::CommandSplitter::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Overcommit::CommandSplitter
  def self.execute(initial_args, options); end
end

class Overcommit::Configuration
  def ==(other); end

  def [](key); end

  def all_builtin_hook_configs(); end

  def all_hook_configs(); end

  def all_plugin_hook_configs(); end

  def apply_environment!(hook_context, env); end

  def concurrency(); end

  def enabled_ad_hoc_hooks(hook_context); end

  def enabled_builtin_hooks(hook_context); end

  def for_hook(hook, hook_type=T.unsafe(nil)); end

  def initialize(hash, options=T.unsafe(nil)); end

  def merge(config); end

  def plugin_directory(); end

  def plugin_hook?(hook_context_or_type, hook_name); end

  def previous_signature?(); end

  def signature_changed?(); end

  def update_signature!(); end

  def verify_signatures?(); end
end

class Overcommit::ConfigurationLoader
  def initialize(logger, options=T.unsafe(nil)); end

  def load_file(file); end

  def load_repo_config(); end
  DEFAULT_CONFIG_PATH = ::T.let(nil, ::T.untyped)
end

class Overcommit::ConfigurationLoader
  def self.default_configuration(); end

  def self.load_from_file(file, options=T.unsafe(nil)); end
end

class Overcommit::ConfigurationValidator
  def validate(config, hash, options); end
end

module Overcommit::GitConfig
  def self.comment_character(); end

  def self.hooks_path(); end
end

module Overcommit::GitRepo
  DIFF_HUNK_REGEX = ::T.let(nil, ::T.untyped)
  SUBMODULE_STATUS_REGEX = ::T.let(nil, ::T.untyped)
end

class Overcommit::GitRepo::Submodule
  def path(); end

  def path=(_); end

  def url(); end

  def url=(_); end
end

class Overcommit::GitRepo::Submodule
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Overcommit::GitRepo::SubmoduleStatus
  def describe(); end

  def describe=(_); end

  def merge_conflict?(); end

  def outdated?(); end

  def path(); end

  def path=(_); end

  def prefix(); end

  def prefix=(_); end

  def sha1(); end

  def sha1=(_); end

  def uninitialized?(); end
end

class Overcommit::GitRepo::SubmoduleStatus
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Overcommit::GitRepo
  def self.all_files(); end

  def self.branches_containing_commit(commit_ref); end

  def self.current_branch(); end

  def self.extract_modified_lines(file_path, options); end

  def self.initial_commit?(); end

  def self.list_files(paths=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.modified_files(options); end

  def self.restore_cherry_pick_state(); end

  def self.restore_merge_state(); end

  def self.staged_submodule_removals(); end

  def self.store_cherry_pick_state(); end

  def self.store_merge_state(); end

  def self.submodule_statuses(options=T.unsafe(nil)); end

  def self.submodules(options=T.unsafe(nil)); end

  def self.tracked?(path); end
end

module Overcommit::Hook
  MESSAGE_TYPES = ::T.let(nil, ::T.untyped)
end

class Overcommit::Hook::Base
  def all_files(*args, **arg, &block); end

  def applicable_files(); end

  def command(); end

  def config(); end

  def description(); end

  def enabled?(); end

  def excluded?(); end

  def execute(cmd, options=T.unsafe(nil)); end

  def execute_in_background(cmd); end

  def flags(); end

  def in_path?(cmd); end

  def included_files(); end

  def initialize(config, context); end

  def modified_files(*args, **arg, &block); end

  def name(); end

  def parallelize?(); end

  def processors(); end

  def quiet?(); end

  def required?(); end

  def required_executable(); end

  def required_libraries(); end

  def run(); end

  def run?(); end

  def run_and_transform(); end

  def skip?(); end
end

class Overcommit::Hook::Message
  def content(); end

  def content=(_); end

  def file(); end

  def file=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end
end

class Overcommit::Hook::Message
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Overcommit::HookContext::Base
  def all_files(); end

  def cleanup_environment(); end

  def execute_hook(command); end

  def hook_class_name(); end

  def hook_script_name(); end

  def hook_type_name(); end

  def initialize(config, args, input); end

  def input_lines(); end

  def input_string(); end

  def modified_files(); end

  def post_fail_message(); end

  def setup_environment(); end
end

module Overcommit::HookContext
  def self.create(hook_type, config, args, input); end
end

class Overcommit::HookLoader::Base
  def initialize(config, context, logger); end

  def load_hooks(); end
end

class Overcommit::HookLoader::PluginHookLoader
  def update_signatures(); end
end

class Overcommit::HookRunner
  def initialize(config, logger, context, printer); end

  def run(); end
end

class Overcommit::HookSigner
  def hook_name(); end

  def hook_path(); end

  def initialize(hook_name, config, context); end

  def signable_file?(file); end

  def signature_changed?(); end

  def update_signature!(); end
  IGNORED_CONFIG_KEYS = ::T.let(nil, ::T.untyped)
end

class Overcommit::Installer
  def initialize(logger); end

  def run(target, options); end
  MASTER_HOOK = ::T.let(nil, ::T.untyped)
  TEMPLATE_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Overcommit::Logger
  def bold(*args); end

  def bold_error(*args); end

  def bold_warning(*args); end

  def debug(*args); end

  def error(*args); end

  def initialize(out); end

  def log(*args); end

  def newline(); end

  def partial(*args); end

  def success(*args); end

  def warning(*args); end
end

class Overcommit::Logger
  def self.silent(); end
end

class Overcommit::MessageProcessor
  def hook_result(messages); end

  def initialize(hook, unmodified_lines_setting); end
  ERRORS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
end

module Overcommit::OS
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Overcommit::OS
  def self.cygwin?(); end

  def self.linux?(); end

  def self.mac?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class Overcommit::Printer
  def end_hook(hook, status, output); end

  def hook_run_failed(message); end

  def hook_skipped(hook); end

  def initialize(config, logger, context); end

  def interrupt_triggered(); end

  def nothing_to_run(); end

  def required_hook_not_skipped(hook); end

  def run_failed(); end

  def run_interrupted(); end

  def run_succeeded(); end

  def run_warned(); end

  def start_run(); end
end

class Overcommit::Subprocess::Result
  def status(); end

  def status=(_); end

  def stderr(); end

  def stderr=(_); end

  def stdout(); end

  def stdout=(_); end

  def success?(); end
end

class Overcommit::Subprocess::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Overcommit::Subprocess
  def self.spawn(args, options=T.unsafe(nil)); end

  def self.spawn_detached(args); end
end

module Overcommit::Utils::FileUtils
  def self.readlink(link_name); end

  def self.symlink(old_name, new_name); end

  def self.symlink?(file_name); end
end

class Overcommit::Utils::Version
  def !=(version); end

  def <(version); end

  def <=(version); end

  def ==(version); end

  def >(version); end

  def >=(version); end
end

module Overcommit::Utils
  def self.broken_symlink?(file); end

  def self.camel_case(str); end

  def self.convert_glob_to_absolute(glob); end

  def self.execute(initial_args, options=T.unsafe(nil)); end

  def self.execute_in_background(args); end

  def self.git_dir(); end

  def self.in_path?(cmd); end

  def self.log=(log); end

  def self.matches_path?(pattern, path); end

  def self.parent_command(); end

  def self.processor_count(); end

  def self.repo_root(); end

  def self.script_path(script); end

  def self.snake_case(str); end

  def self.strip_color_codes(text); end

  def self.supported_hook_type_classes(); end

  def self.supported_hook_types(); end

  def self.with_environment(env); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  POSTGRESQL_LIB_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
  include ::PG::BasicTypeRegistry::Checker
  def encode_array_as(); end

  def encode_array_as=(pg_type); end

  def initialize(connection_or_coder_maps, registry: T.unsafe(nil), if_undefined: T.unsafe(nil)); end
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
  def initialize(typenames); end

  def typecast_result_value(result, _tuple, field); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BasicTypeMapForResults
end

class PG::BasicTypeRegistry
  include ::PG::BasicTypeRegistry::Checker
  def alias_type(format, new, old); end

  def coders_for(format, direction); end

  def define_default_types(); end

  def register_coder(coder); end

  def register_default_types(); end

  def register_type(format, name, encoder_class, decoder_class); end
  DEFAULT_TYPE_REGISTRY = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry::Checker
  def build_coder_maps(conn_or_maps, registry: T.unsafe(nil)); end

  def check_format_and_direction(format, direction); end
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry::Checker
end

class PG::BasicTypeRegistry::CoderMap
  def coder_by_name(name); end

  def coder_by_oid(oid); end

  def coders(); end

  def coders_by_name(); end

  def coders_by_oid(); end

  def initialize(result, coders_by_name, format, arraycoder); end
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
end

class PG::BasicTypeRegistry::CoderMapsBundle
  def each_format(direction); end

  def initialize(connection, registry: T.unsafe(nil)); end

  def map_for(format, direction); end

  def typenames_by_oid(); end
end

class PG::BasicTypeRegistry::CoderMapsBundle
end

class PG::BasicTypeRegistry
  def self.alias_type(*args); end

  def self.register_coder(*args); end

  def self.register_type(*args); end
end

module PG::BinaryDecoder
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
end

module PG::BinaryDecoder
end

module PG::BinaryEncoder
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
end

module PG::BinaryEncoder
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  def ==(v); end

  def flags(); end

  def flags=(flags); end

  def format(); end

  def format=(format); end

  def initialize(params=T.unsafe(nil)); end

  def inspect_short(); end

  def marshal_dump(); end

  def marshal_load(str); end

  def name(); end

  def name=(name); end

  def oid(); end

  def oid=(oid); end

  def to_h(); end
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  def initialize(params=T.unsafe(nil)); end
  Params = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
end

class PG::Coder
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def elements_type(); end

  def elements_type=(elements_type); end

  def needs_quotation=(needs_quotation); end

  def needs_quotation?(); end
end

class PG::CompositeCoder
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  def async_cancel(); end

  def async_describe_portal(arg); end

  def async_describe_prepared(arg); end

  def async_encrypt_password(password, username, algorithm=T.unsafe(nil)); end

  def async_exec(*args, &blk); end

  def async_exec_params(*arg); end

  def async_exec_prepared(*arg); end

  def async_flush(); end

  def async_get_copy_data(async=T.unsafe(nil), decoder=T.unsafe(nil)); end

  def async_get_last_result(); end

  def async_get_result(); end

  def async_isnonblocking(); end

  def async_prepare(*arg); end

  def async_put_copy_data(buffer, encoder=T.unsafe(nil)); end

  def async_put_copy_end(*args); end

  def async_query(*arg); end

  def async_reset(); end

  def async_set_client_encoding(arg); end

  def async_setnonblocking(enabled); end

  def backend_key(); end

  def backend_pid(); end

  def block(*arg); end

  def cancel(); end

  def client_encoding=(client_encoding); end

  def close(); end

  def conndefaults(); end

  def conndefaults_hash(); end

  def connect_poll(); end

  def connection_needs_password(); end

  def connection_used_password(); end

  def conninfo(); end

  def conninfo_hash(); end

  def consume_input(); end

  def copy_data(sql, coder=T.unsafe(nil)); end

  def db(); end

  def decoder_for_get_copy_data(); end

  def decoder_for_get_copy_data=(decoder_for_get_copy_data); end

  def describe_portal(arg); end

  def describe_prepared(arg); end

  def discard_results(); end

  def encoder_for_put_copy_data(); end

  def encoder_for_put_copy_data=(encoder_for_put_copy_data); end

  def encrypt_password(password, username, algorithm=T.unsafe(nil)); end

  def enter_pipeline_mode(); end

  def error_message(); end

  def escape(arg); end

  def escape_bytea(arg); end

  def escape_identifier(arg); end

  def escape_literal(arg); end

  def escape_string(arg); end

  def exec(*args, &blk); end

  def exec_params(*args, &blk); end

  def exec_prepared(*args, &blk); end

  def exit_pipeline_mode(); end

  def external_encoding(); end

  def field_name_type(); end

  def field_name_type=(field_name_type); end

  def finish(); end

  def finished?(); end

  def flush(); end

  def get_client_encoding(); end

  def get_copy_data(async=T.unsafe(nil), decoder=T.unsafe(nil)); end

  def get_last_result(); end

  def get_result(); end

  def host(); end

  def internal_encoding(); end

  def internal_encoding=(internal_encoding); end

  def is_busy(); end

  def isnonblocking(); end

  def lo_close(arg); end

  def lo_creat(*arg); end

  def lo_create(arg); end

  def lo_export(arg, arg1); end

  def lo_import(arg); end

  def lo_lseek(arg, arg1, arg2); end

  def lo_open(*arg); end

  def lo_read(arg, arg1); end

  def lo_seek(arg, arg1, arg2); end

  def lo_tell(arg); end

  def lo_truncate(arg, arg1); end

  def lo_unlink(arg); end

  def lo_write(arg, arg1); end

  def loclose(arg); end

  def locreat(*arg); end

  def locreate(arg); end

  def loexport(arg, arg1); end

  def loimport(arg); end

  def lolseek(arg, arg1, arg2); end

  def loopen(*arg); end

  def loread(arg, arg1); end

  def loseek(arg, arg1, arg2); end

  def lotell(arg); end

  def lotruncate(arg, arg1); end

  def lounlink(arg); end

  def lowrite(arg, arg1); end

  def make_empty_pgresult(arg); end

  def nonblocking?(); end

  def notifies(); end

  def notifies_wait(*arg); end

  def options(); end

  def parameter_status(arg); end

  def pass(); end

  def pipeline_status(); end

  def pipeline_sync(); end

  def port(); end

  def prepare(*args, &blk); end

  def protocol_version(); end

  def put_copy_data(buffer, encoder=T.unsafe(nil)); end

  def put_copy_end(*args); end

  def query(*args, &blk); end

  def quote_ident(arg); end

  def reset(); end

  def reset_poll(); end

  def reset_start(); end

  def send_describe_portal(arg); end

  def send_describe_prepared(arg); end

  def send_flush_request(); end

  def send_prepare(*arg); end

  def send_query(*arg); end

  def send_query_params(*arg); end

  def send_query_prepared(*args, &blk); end

  def server_version(); end

  def set_client_encoding(arg); end

  def set_default_encoding(); end

  def set_error_context_visibility(arg); end

  def set_error_verbosity(arg); end

  def set_notice_processor(); end

  def set_notice_receiver(); end

  def set_single_row_mode(); end

  def setnonblocking(enabled); end

  def socket(); end

  def socket_io(); end

  def ssl_attribute(arg); end

  def ssl_attribute_names(); end

  def ssl_attributes(); end

  def ssl_in_use?(); end

  def status(); end

  def sync_cancel(); end

  def sync_describe_portal(arg); end

  def sync_describe_prepared(arg); end

  def sync_encrypt_password(*arg); end

  def sync_exec(*arg); end

  def sync_exec_params(*arg); end

  def sync_exec_prepared(*arg); end

  def sync_flush(); end

  def sync_get_copy_data(*arg); end

  def sync_get_last_result(); end

  def sync_get_result(); end

  def sync_isnonblocking(); end

  def sync_prepare(*arg); end

  def sync_put_copy_data(*arg); end

  def sync_put_copy_end(*arg); end

  def sync_reset(); end

  def sync_set_client_encoding(arg); end

  def sync_setnonblocking(arg); end

  def trace(arg); end

  def transaction(); end

  def transaction_status(); end

  def tty(); end

  def type_map_for_queries(); end

  def type_map_for_queries=(type_map_for_queries); end

  def type_map_for_results(); end

  def type_map_for_results=(type_map_for_results); end

  def unescape_bytea(arg); end

  def untrace(); end

  def user(); end

  def wait_for_notify(*arg); end
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  HOST_AND_PORT = ::T.let(nil, ::T.untyped)
  POSTGRESQL_URI = ::T.let(nil, ::T.untyped)
end

class PG::Connection
  def self.async_api=(enable); end

  def self.async_connect(*args, **kwargs); end

  def self.async_ping(*args); end

  def self.async_send_api=(enable); end

  def self.conndefaults(); end

  def self.conndefaults_hash(); end

  def self.connect(*args, **kwargs); end

  def self.connect_hash_to_string(hash); end

  def self.connect_start(*arg); end

  def self.connect_string_to_hash(str); end

  def self.encrypt_password(arg, arg1); end

  def self.escape(arg); end

  def self.escape_bytea(arg); end

  def self.escape_string(arg); end

  def self.isthreadsafe(); end

  def self.new(*args, **kwargs); end

  def self.open(*args, **kwargs); end

  def self.parse_connect_args(*args); end

  def self.ping(*args); end

  def self.quote_connstr(value); end

  def self.quote_ident(arg); end

  def self.setdb(*args, **kwargs); end

  def self.setdblogin(*args, **kwargs); end

  def self.sync_connect(*arg); end

  def self.sync_ping(*arg); end

  def self.unescape_bytea(arg); end
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_STANDBY = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_TARGET = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_WRITABLE = ::T.let(nil, ::T.untyped)
  CONNECTION_CONSUME = ::T.let(nil, ::T.untyped)
  CONNECTION_GSS_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_SYNC = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_SQLSTATE = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_OFF = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ON = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
end

class PG::CopyCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def null_string(); end

  def null_string=(null_string); end

  def type_map(); end

  def type_map=(type_map); end
end

class PG::CopyCoder
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::Error
  def connection(); end

  def error(); end

  def result(); end
end

class PG::Error
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotInBlockingMode
end

class PG::NotInBlockingMode
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordCoder
  def type_map(); end

  def type_map=(type_map); end
end

class PG::RecordCoder
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
  def [](arg); end

  def autoclear?(); end

  def check(); end

  def check_result(); end

  def clear(); end

  def cleared?(); end

  def cmd_status(); end

  def cmd_tuples(); end

  def cmdtuples(); end

  def column_values(arg); end

  def each(*args, &blk); end

  def each_row(); end

  def error_field(arg); end

  def error_message(); end

  def fformat(arg); end

  def field_name_type(); end

  def field_name_type=(field_name_type); end

  def field_names_as(type); end

  def field_values(arg); end

  def fields(); end

  def fmod(arg); end

  def fname(arg); end

  def fnumber(arg); end

  def fsize(arg); end

  def ftable(arg); end

  def ftablecol(arg); end

  def ftype(arg); end

  def getisnull(arg, arg1); end

  def getlength(arg, arg1); end

  def getvalue(arg, arg1); end

  def map_types!(type_map); end

  def nfields(); end

  def nparams(); end

  def ntuples(); end

  def num_fields(); end

  def num_tuples(); end

  def oid_value(); end

  def paramtype(arg); end

  def res_status(arg); end

  def result_error_field(arg); end

  def result_error_message(); end

  def result_status(); end

  def result_verbose_error_message(arg, arg1); end

  def stream_each(); end

  def stream_each_row(); end

  def stream_each_tuple(); end

  def tuple(arg); end

  def tuple_values(arg); end

  def type_map(); end

  def type_map=(type_map); end

  def values(*args, &blk); end

  def verbose_error_message(arg, arg1); end
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Array
end

class PG::TextDecoder::Boolean
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
end

class PG::TextDecoder::Bytea
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
end

class PG::TextDecoder::CopyRow
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
end

class PG::TextDecoder::Date
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
end

class PG::TextDecoder::FromBase64
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
end

class PG::TextDecoder::Identifier
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
end

class PG::TextDecoder::Inet
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
end

class PG::TextDecoder::JSON
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::Record
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Record
end

class PG::TextDecoder::String
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
end

class PG::TextDecoder::Timestamp
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtcToLocal
end

class PG::TextDecoder::TimestampUtcToLocal
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

module PG::TextEncoder
end

class PG::TextEncoder::Array
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Array
end

class PG::TextEncoder::Boolean
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
end

class PG::TextEncoder::Bytea
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
end

class PG::TextEncoder::CopyRow
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
end

class PG::TextEncoder::Date
  def encode(value); end
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
end

class PG::TextEncoder::Identifier
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
end

class PG::TextEncoder::Inet
  def encode(value); end
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Integer
end

class PG::TextEncoder::JSON
  def encode(value); end
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
end

class PG::TextEncoder::Record
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
end

class PG::TextEncoder::String
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
end

class PG::TextEncoder::TimestampUtc
  def encode(value); end
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
end

module PG::TextEncoder
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
  def [](arg); end

  def each(&blk); end

  def each_key(&block); end

  def each_value(); end

  def fetch(*arg); end

  def has_key?(key); end

  def index(arg); end

  def key?(key); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class PG::Tuple
end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map(); end

  def default_type_map=(default_type_map); end

  def with_default_type_map(arg); end
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
  def [](arg); end

  def []=(arg, arg1); end

  def coders(); end
end

class PG::TypeMapByClass
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
  def coders(); end

  def initialize(arg); end

  def oids(); end
end

class PG::TypeMapByColumn
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
  def [](arg); end

  def []=(arg, arg1); end

  def coders(); end
end

class PG::TypeMapByMriType
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
  def add_coder(arg); end

  def build_column_map(arg); end

  def coders(); end

  def max_rows_for_online_lookup(); end

  def max_rows_for_online_lookup=(max_rows_for_online_lookup); end

  def rm_coder(arg, arg1); end
end

class PG::TypeMapByOid
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
  def typecast_copy_get(arg, arg1, arg2, arg3); end

  def typecast_query_param(arg, arg1); end

  def typecast_result_value(arg, arg1, arg2); end
end

class PG::TypeMapInRuby
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module PG
  def self.connect(*args, **kwargs); end

  def self.init_openssl(arg, arg1); end

  def self.init_ssl(arg); end

  def self.is_threadsafe?(); end

  def self.isthreadsafe(); end

  def self.library_version(); end

  def self.threadsafe?(); end

  def self.version_string(include_buildnum=T.unsafe(nil)); end
end

class PP
  def self.width_for(out); end
end

class PStore
  def initialize(file, thread_safe=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pagy
  include ::Pagy::FrontendHelpers::Pagy
  DEFAULT = ::T.let(nil, ::T.untyped)
  LABEL_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  PAGE_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Pagy::Backend
  include ::Pagy::CountlessExtra
end

module Pagy::BulmaExtra
  def pagy_bulma_combo_nav_js(pagy, pagy_id: T.unsafe(nil), link_extra: T.unsafe(nil)); end

  def pagy_bulma_nav(pagy, pagy_id: T.unsafe(nil), link_extra: T.unsafe(nil), **vars); end

  def pagy_bulma_nav_js(pagy, pagy_id: T.unsafe(nil), link_extra: T.unsafe(nil), **vars); end
end

class Pagy::Countless
  def finalize(fetched_size); end

  def initialize(vars=T.unsafe(nil)); end

  def series(*arg); end
end

module Pagy::Frontend
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
end

module Pagy::FrontendHelpers::Calendar
  def label_sequels(sequels=T.unsafe(nil)); end
end

module Pagy::FrontendHelpers::Frontend
  def pagy_data(pagy, *args); end

  def pagy_marked_link(link); end
end

module Pagy::FrontendHelpers::Pagy
  def label_sequels(*arg); end

  def sequels(steps: T.unsafe(nil), **_); end
end

module Pagy::I18n
  DATA = ::T.let(nil, ::T.untyped)
end

module Pagy::I18n::P11n
  LOCALE = ::T.let(nil, ::T.untyped)
  RULE = ::T.let(nil, ::T.untyped)
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
  def initialize(value=T.unsafe(nil)); end

  def value(); end
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

module Parallel
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

module Parlour::Mixin::Searchable
  Child = type_member
end

class Parlour::RbiGenerator::ClassNamespace
  Child = type_member
end

class Parlour::RbiGenerator::EnumClassNamespace
  Child = type_member
end

class Parlour::RbiGenerator::ModuleNamespace
  Child = type_member
end

class Parlour::RbiGenerator::Namespace
  Child = type_member
end

Parlour::RbiGenerator::Options = Parlour::Options

class Parlour::RbiGenerator::Parameter
  PREFIXES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbiGenerator::StructClassNamespace
  Child = type_member
end

class Parlour::RbiGenerator::StructProp
  EXTRA_PROPERTIES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbsGenerator::ClassNamespace
  Child = type_member
end

class Parlour::RbsGenerator::InterfaceNamespace
  Child = type_member
end

class Parlour::RbsGenerator::ModuleNamespace
  Child = type_member
end

class Parlour::RbsGenerator::Namespace
  Child = type_member
end

class Parlour::RbsGenerator::Parameter
  PREFIXES = ::T.let(nil, ::T.untyped)
  RBS_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Parlour::Types
  TypeLike = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::Context
  FLAGS = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby31

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby31
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  ANONYMOUS_BLOCKARG = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Pathname
  def existence(); end
end

module Polyfill
  VERSION = ::T.let(nil, ::T.untyped)
end

module PreviewHelper
  def find_template_data(lookup_context:, template_identifier:); end

  def preview_source(); end
  AVAILABLE_PRISM_LANGUAGES = ::T.let(nil, ::T.untyped)
  FALLBACK_LANGUAGE = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::DEBUGGER__::ForkInterceptor
  extend ::ActiveSupport::ForkTracker::ModernCoreExt
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, **arg, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, **arg, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, **arg, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, **arg, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, **arg, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*arg); end

  def resolve_format(*arg); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar
  def self.create(*args); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::DEBUGGER__::TrapInterceptor
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry
  def self.enable_rescuing!(block=T.unsafe(nil)); end

  def self.rescue(&block); end

  def self.rescued(e=T.unsafe(nil)); end
end

class PryRescue::Rack
  def call(env); end

  def initialize(app); end
end

module PryRescue::SourceLocation
  DEPRECATION_TIME = ::T.let(nil, ::T.untyped)
  WithRuby2_5 = ::T.let(nil, ::T.untyped)
  WithRuby2_6 = ::T.let(nil, ::T.untyped)
end

module PryRescue::SourceLocation
  def self.call(b); end
end

class PryRescue
  def self.any_exception_captured(); end

  def self.any_exception_captured=(any_exception_captured); end

  def self.enter_exception_context(exception); end

  def self.in_exception_context?(); end

  def self.load(script, ensure_repl=T.unsafe(nil)); end

  def self.load_rake(task); end

  def self.peek!(*arg); end

  def self.peek_on_signal(signal); end
end

module PryStackExplorer
  Commands = ::T.let(nil, ::T.untyped)
  LOCATION_LAMBDA = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PryStackExplorer::FrameManager
  def binding_index(); end

  def binding_index=(binding_index); end

  def bindings(); end

  def bindings=(bindings); end

  def change_frame_to(index, run_whereami=T.unsafe(nil)); end

  def current_frame(); end

  def each(&block); end

  def initialize(bindings, _pry_); end

  def prior_backtrace(); end

  def prior_binding(); end

  def refresh_frame(run_whereami=T.unsafe(nil)); end

  def set_binding_index_safely(index); end

  def user(); end
end

class PryStackExplorer::WhenStartedHook
  def call(target, options, _pry_); end

  def caller_bindings(target); end
end

module PryStackExplorer
  def self.bindings_equal?(b1, b2); end

  def self.clear_frame_managers(_pry_); end

  def self.create_and_push_frame_manager(bindings, _pry_, options=T.unsafe(nil)); end

  def self.delete_frame_managers(_pry_); end

  def self.frame_hash(); end

  def self.frame_manager(_pry_); end

  def self.frame_managers(_pry_); end

  def self.pop_frame_manager(_pry_); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  extend ::Bootsnap::CompileCache::YAML::Psych4::Patch
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(*args, **arg, &block); end

  def self.domain_types=(*args, **arg, &block); end

  def self.dump_tags(*args, **arg, &block); end

  def self.dump_tags=(*args, **arg, &block); end

  def self.libyaml_version(); end

  def self.load_tags(*args, **arg, &block); end

  def self.load_tags=(*args, **arg, &block); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.safe_load_file(filename, **kwargs); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

module Puma
  HAS_FORK = ::T.let(nil, ::T.untyped)
  HAS_SSL = ::T.let(nil, ::T.untyped)
  HAS_UNIX_SOCKET = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_MRI = ::T.let(nil, ::T.untyped)
  IS_OSX = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  def activated_sockets(); end

  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def close_listeners(); end

  def connected_ports(); end

  def create_activated_fds(env_hash); end

  def create_inherited_fds(env_hash); end

  def env(sock); end

  def envs(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def inherited_fds(); end

  def initialize(events, conf=T.unsafe(nil)); end

  def ios(); end

  def ios=(ios); end

  def listeners(); end

  def listeners=(listeners); end

  def localhost_authority(); end

  def localhost_authority_context(); end

  def parse(binds, logger, log_msg=T.unsafe(nil)); end

  def proto_env(); end

  def redirects_for_restart(); end

  def redirects_for_restart_env(); end

  def synthesize_binds_from_activated_fs(binds, only_matching); end

  def unix_paths(); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  def body(); end

  def call(); end

  def can_close?(); end

  def close(); end

  def closed?(*args, **arg, &block); end

  def eagerly_finish(); end

  def env(); end

  def expect_proxy_proto=(val); end

  def finish(timeout); end

  def hijacked(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def io_ok?(); end

  def listener(); end

  def listener=(listener); end

  def peerip(); end

  def peerip=(peerip); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def tempfile(); end

  def timeout(); end

  def timeout!(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def try_to_parse_proxy_protocol(); end

  def write_error(status_code); end
  ALLOWED_TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE_INVALID = ::T.let(nil, ::T.untyped)
  CHUNK_VALID_ENDING = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_VALUE_INVALID = ::T.let(nil, ::T.untyped)
  EmptyBody = ::T.let(nil, ::T.untyped)
  TE_ERR_MSG = ::T.let(nil, ::T.untyped)
end

class Puma::Cluster
  def all_workers_booted?(); end

  def check_workers(); end

  def cull_start_index(diff); end

  def cull_workers(); end

  def fork_worker!(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_worker(idx, master); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def worker(index, master); end

  def workers_to_cull(diff); end
end

class Puma::Cluster::Worker
  def index(); end

  def initialize(index:, master:, launcher:, pipes:, server: T.unsafe(nil)); end

  def master(); end

  def run(); end
end

class Puma::Cluster::WorkerHandle
  def boot!(); end

  def booted?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def phase=(phase); end

  def pid(); end

  def pid=(pid); end

  def ping!(status); end

  def ping_timeout(); end

  def signal(); end

  def started_at(); end

  def term(); end

  def term!(); end

  def term?(); end

  def uptime(); end
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerCheckInterval = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

class Puma::Configuration
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def default_max_threads(); end

  def environment(); end

  def environment_str(); end

  def final_options(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg, events); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

module Puma::Const
  BANNED_HEADER_KEY = ::T.let(nil, ::T.untyped)
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_DELIMITER = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_KEY_REGEX = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PROXY_PROTOCOL_V1_REGEX = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::DSL
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def bind_to_activated_sockets(bind=T.unsafe(nil)); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def extra_runtime_dependencies(answer=T.unsafe(nil)); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def fork_worker(after_requests=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def io_selector_backend(backend); end

  def load(file); end

  def log_formatter(&block); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def max_fast_inline(num_of_requests); end

  def mutate_stdout_and_stderr_to_sync_on_write(enabled=T.unsafe(nil)); end

  def nakayoshi_fork(enabled=T.unsafe(nil)); end

  def on_refork(&block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def out_of_band(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rack_url_scheme(scheme=T.unsafe(nil)); end

  def rackup(path); end

  def raise_exception_on_sigterm(answer=T.unsafe(nil)); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def silence_single_worker_warning(); end

  def ssl_bind(host, port, opts=T.unsafe(nil)); end

  def state_path(path); end

  def state_permission(permission); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def threads(min, max); end

  def wait_for_less_busy_worker(val=T.unsafe(nil)); end

  def worker_boot_timeout(timeout); end

  def worker_check_interval(interval); end

  def worker_culling_strategy(strategy); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
  def self.ssl_bind_str(host, port, opts); end
end

class Puma::ErrorLogger
  def debug(options=T.unsafe(nil)); end

  def info(options=T.unsafe(nil)); end

  def initialize(ioerr); end

  def ioerr(); end

  def request_dump(req); end

  def request_headers(req); end

  def request_parsed?(req); end

  def request_title(req); end

  def title(options=T.unsafe(nil)); end
  REQUEST_FORMAT = ::T.let(nil, ::T.untyped)
end

class Puma::ErrorLogger
  def self.stdio(); end
end

class Puma::Events
  def connection_error(error, req, text=T.unsafe(nil)); end

  def debug(str); end

  def debug_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def error(str); end

  def fire(hook, *args); end

  def fire_on_booted!(); end

  def fire_on_restart!(); end

  def fire_on_stopped!(); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def on_booted(&block); end

  def on_restart(&block); end

  def on_stopped(&block); end

  def parse_error(error, req); end

  def register(hook, obj=T.unsafe(nil), &blk); end

  def ssl_error(error, ssl_socket); end

  def stderr(); end

  def stdout(); end

  def unknown_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
  def call(str); end
end

class Puma::Events
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def append(*args); end

  def reset(); end
end

module Puma::JSONSerialization
  BACKSLASH = ::T.let(nil, ::T.untyped)
  CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
  def binder(); end

  def close_binder_listeners(); end

  def config(); end

  def connected_ports(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def options(); end

  def phased_restart(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def thread_status(); end

  def write_state(); end
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

module Puma::MiniSSL
  HAS_TLS1_3 = ::T.let(nil, ::T.untyped)
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFICATION_FLAGS = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::ContextBuilder
  def context(); end

  def initialize(params, events); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::NullIO
  def close(); end

  def each(&blk); end

  def eof?(); end

  def flush(); end

  def gets(); end

  def puts(*ary); end

  def read(count=T.unsafe(nil), _buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def string(); end

  def sync(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::Plugin
  def in_background(&blk); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Reactor
  def add(client); end

  def initialize(backend, &block); end

  def run(background=T.unsafe(nil)); end

  def shutdown(); end
end

module Puma::Request
  def default_server_port(env); end

  def handle_request(client, lines, requests); end

  def normalize_env(env, client); end
end

class Puma::Runner
  def app(); end

  def close_control_listeners(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(cli, events); end

  def load_and_bind(); end

  def log(str); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def stop_control(); end

  def test?(); end

  def wakeup!(); end
end

class Puma::Server
  def add_ssl_listener(*args, **arg, &block); end

  def add_tcp_listener(*args, **arg, &block); end

  def add_unix_listener(*args, **arg, &block); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def auto_trim_time=(auto_trim_time); end

  def backlog(); end

  def begin_restart(sync=T.unsafe(nil)); end

  def binder(); end

  def binder=(binder); end

  def client_error(e, client); end

  def closed_socket?(socket); end

  def connected_ports(*args, **arg, &block); end

  def cork_socket(socket); end

  def early_hints(); end

  def early_hints=(early_hints); end

  def events(); end

  def first_data_timeout(); end

  def first_data_timeout=(first_data_timeout); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_servers(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def leak_stack_on_error=(leak_stack_on_error); end

  def lowlevel_error(e, env, status=T.unsafe(nil)); end

  def max_threads(); end

  def max_threads=(max_threads); end

  def min_threads(); end

  def min_threads=(min_threads); end

  def persistent_timeout(); end

  def persistent_timeout=(persistent_timeout); end

  def pool_capacity(); end

  def process_client(client, buffer); end

  def reactor_wakeup(client); end

  def reaping_time(); end

  def reaping_time=(reaping_time); end

  def requests_count(); end

  def run(background=T.unsafe(nil), thread_name: T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stats(); end

  def stop(sync=T.unsafe(nil)); end

  def thread(); end

  def uncork_socket(socket); end

  def with_force_shutdown(client, &block); end
  STAT_METHODS = ::T.let(nil, ::T.untyped)
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def restart(); end

  def run(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def busy_threads(); end

  def clean_thread_locals(); end

  def clean_thread_locals=(clean_thread_locals); end

  def initialize(name, min, max, *extra, &block); end

  def out_of_band_hook(); end

  def out_of_band_hook=(out_of_band_hook); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_for_less_busy_worker(delay_s); end

  def wait_until_not_full(); end

  def waiting(); end

  def with_force_shutdown(); end

  def with_mutex(&block); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def final_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  def self.nakayoshi_gc(events); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.purge_interrupt_queue(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module RBI
  VERSION = ::T.let(nil, ::T.untyped)
end

class RBI::ASTVisitor
  def initialize(*args, **arg, &blk); end

  def visit(*args, **arg, &blk); end

  def visit_all(*args, **arg, &blk); end
end

class RBI::Arg
  def ==(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::Attr
  def fully_qualified_names(*args, **arg, &blk); end

  def names(*args, **arg, &blk); end

  def names=(names); end

  def sigs(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end

  def visibility=(visibility); end
end

class RBI::AttrAccessor
  def to_s(*args, **arg, &blk); end
end

class RBI::AttrReader
  def to_s(*args, **arg, &blk); end
end

class RBI::AttrWriter
  def to_s(*args, **arg, &blk); end
end

class RBI::BlockParam
  def ==(*args, **arg, &blk); end
end

class RBI::Class
  def name(*args, **arg, &blk); end

  def name=(name); end

  def superclass_name(*args, **arg, &blk); end

  def superclass_name=(superclass_name); end
end

class RBI::Comment
  def ==(*args, **arg, &blk); end

  def text(*args, **arg, &blk); end

  def text=(text); end
end

class RBI::ConflictTree
  def left(*args, **arg, &blk); end

  def right(); end
end

class RBI::Const
  def fully_qualified_name(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(); end
end

class RBI::ConstBuilder
  def names(*args, **arg, &blk); end

  def names=(names); end
end

class RBI::ConstBuilder
  def self.visit(*args, **arg, &blk); end
end

class RBI::Extend
  def to_s(*args, **arg, &blk); end
end

class RBI::File
  def <<(*args, **arg, &blk); end

  def accept_printer(*args, **arg, &blk); end

  def comments(*args, **arg, &blk); end

  def comments=(comments); end

  def empty?(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def print(*args, **arg, &blk); end

  def root(*args, **arg, &blk); end

  def root=(root); end

  def strictness(*args, **arg, &blk); end

  def strictness=(strictness); end

  def string(*args, **arg, &blk); end
end

class RBI::Formatter
  def add_sig_templates(*args, **arg, &blk); end

  def add_sig_templates=(add_sig_templates); end

  def format_file(*args, **arg, &blk); end

  def format_tree(*args, **arg, &blk); end

  def group_nodes(); end

  def group_nodes=(group_nodes); end

  def initialize(*args, **arg, &blk); end

  def max_line_length(*args, **arg, &blk); end

  def max_line_length=(max_line_length); end

  def nest_non_public_methods(); end

  def nest_non_public_methods=(nest_non_public_methods); end

  def nest_singleton_methods(); end

  def nest_singleton_methods=(nest_singleton_methods); end

  def print_file(*args, **arg, &blk); end

  def print_tree(*args, **arg, &blk); end

  def sort_nodes(); end

  def sort_nodes=(sort_nodes); end
end

class RBI::Group
  def kind(*args, **arg, &blk); end
end

class RBI::Group::Kind
  Attrs = ::T.let(nil, ::T.untyped)
  Consts = ::T.let(nil, ::T.untyped)
  Helpers = ::T.let(nil, ::T.untyped)
  Inits = ::T.let(nil, ::T.untyped)
  Methods = ::T.let(nil, ::T.untyped)
  MixesInClassMethods = ::T.let(nil, ::T.untyped)
  Mixins = ::T.let(nil, ::T.untyped)
  RequiredAncestors = ::T.let(nil, ::T.untyped)
  Sends = ::T.let(nil, ::T.untyped)
  SingletonClasses = ::T.let(nil, ::T.untyped)
  TEnums = ::T.let(nil, ::T.untyped)
  TStructFields = ::T.let(nil, ::T.untyped)
  TypeMembers = ::T.let(nil, ::T.untyped)
end

class RBI::Helper
  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Include
  def to_s(*args, **arg, &blk); end
end

class RBI::Index
  def [](*args, **arg, &blk); end

  def index(*args, **arg, &blk); end

  def keys(*args, **arg, &blk); end
end

class RBI::Index
  def self.index(*args, **arg, &blk); end
end

module RBI::Indexable
  def index_ids(*args, **arg, &blk); end
end

class RBI::KwArg
  def keyword(*args, **arg, &blk); end
end

class RBI::KwOptParam
  def ==(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::KwParam
  def ==(*args, **arg, &blk); end
end

class RBI::KwRestParam
  def ==(*args, **arg, &blk); end
end

class RBI::Loc
  def begin_column(); end

  def begin_line(*args, **arg, &blk); end

  def end_column(); end

  def end_line(); end

  def file(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def source(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Loc
  def self.from_ast_loc(*args, **arg, &blk); end
end

class RBI::MergeTree
  def conflicts(*args, **arg, &blk); end
end

class RBI::Method
  def <<(*args, **arg, &blk); end

  def fully_qualified_name(*args, **arg, &blk); end

  def inline_params?(*args, **arg, &blk); end

  def is_singleton(*args, **arg, &blk); end

  def is_singleton=(is_singleton); end

  def name(*args, **arg, &blk); end

  def name=(name); end

  def params(*args, **arg, &blk); end

  def sigs(*args, **arg, &blk); end

  def sigs=(sigs); end

  def to_s(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end

  def visibility=(visibility); end
end

class RBI::MixesInClassMethods
  def to_s(*args, **arg, &blk); end
end

class RBI::Mixin
  def names(*args, **arg, &blk); end

  def names=(names); end
end

class RBI::Module
  def name(*args, **arg, &blk); end

  def name=(name); end
end

class RBI::Node
  def accept_printer(*args, **arg, &blk); end

  def compatible_with?(*args, **arg, &blk); end

  def detach(*args, **arg, &blk); end

  def group_kind(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def loc(*args, **arg, &blk); end

  def loc=(loc); end

  def merge_with(*args, **arg, &blk); end

  def oneline?(*args, **arg, &blk); end

  def parent_conflict_tree(*args, **arg, &blk); end

  def parent_scope(*args, **arg, &blk); end

  def parent_tree(*args, **arg, &blk); end

  def parent_tree=(parent_tree); end

  def print(*args, **arg, &blk); end

  def print_blank_line_before(*args, **arg, &blk); end

  def replace(*args, **arg, &blk); end

  def string(*args, **arg, &blk); end
end

class RBI::NodeWithComments
  def annotations(*args, **arg, &blk); end

  def comments(*args, **arg, &blk); end

  def comments=(comments); end
end

class RBI::OptParam
  def ==(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::Param
  def comments_lines(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def print_comment_leading_space(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::ParseError
  def initialize(*args, **arg, &blk); end

  def location(*args, **arg, &blk); end
end

class RBI::Parser
  def initialize(*args, **arg, &blk); end

  def parse_file(*args, **arg, &blk); end

  def parse_string(*args, **arg, &blk); end
end

class RBI::Parser
  def self.parse_file(*args, **arg, &blk); end

  def self.parse_files(*args, **arg, &blk); end

  def self.parse_string(*args, **arg, &blk); end

  def self.parse_strings(*args, **arg, &blk); end
end

class RBI::Printer
  def current_indent(*args, **arg, &blk); end

  def dedent(*args, **arg, &blk); end

  def in_visibility_group(); end

  def in_visibility_group=(in_visibility_group); end

  def indent(*args, **arg, &blk); end

  def max_line_length(*args, **arg, &blk); end

  def previous_node(*args, **arg, &blk); end

  def print(*args, **arg, &blk); end

  def print_locs(*args, **arg, &blk); end

  def print_locs=(print_locs); end

  def printl(*args, **arg, &blk); end

  def printn(*args, **arg, &blk); end

  def printt(*args, **arg, &blk); end

  def visit_file(*args, **arg, &blk); end
end

class RBI::ReqParam
  def ==(*args, **arg, &blk); end
end

class RBI::RequiresAncestor
  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::RestParam
  def ==(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge
  def initialize(*args, **arg, &blk); end

  def merge(*args, **arg, &blk); end

  def tree(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge::Conflict
  def left(); end

  def left_name(); end

  def right(); end

  def right_name(); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge::Conflict
  def self.inherited(s); end
end

class RBI::Rewriters::Merge::Keep
  LEFT = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  RIGHT = ::T.let(nil, ::T.untyped)
end

class RBI::Rewriters::Merge::TreeMerger
  def conflicts(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge
  def self.merge_trees(*args, **arg, &blk); end
end

class RBI::Rewriters::RemoveKnownDefinitions
  def operations(*args, **arg, &blk); end
end

class RBI::Rewriters::RemoveKnownDefinitions::Operation
  def deleted_node(); end

  def duplicate_of(); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Rewriters::RemoveKnownDefinitions::Operation
  def self.inherited(s); end
end

class RBI::Rewriters::RemoveKnownDefinitions
  def self.remove(*args, **arg, &blk); end
end

class RBI::Scope
  def dup_empty(*args, **arg, &blk); end

  def fully_qualified_name(*args, **arg, &blk); end

  def print_body(*args, **arg, &blk); end

  def print_header(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::ScopeConflict
  def left(*args, **arg, &blk); end

  def right(); end
end

class RBI::Send
  def <<(*args, **arg, &blk); end

  def ==(*args, **arg, &blk); end

  def args(*args, **arg, &blk); end

  def method(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Sig
  def <<(*args, **arg, &blk); end

  def ==(*args, **arg, &blk); end

  def checked(*args, **arg, &blk); end

  def checked=(checked); end

  def inline_params?(*args, **arg, &blk); end

  def is_abstract(*args, **arg, &blk); end

  def is_abstract=(is_abstract); end

  def is_final(); end

  def is_final=(is_final); end

  def is_overridable(); end

  def is_overridable=(is_overridable); end

  def is_override(); end

  def is_override=(is_override); end

  def params(*args, **arg, &blk); end

  def return_type(*args, **arg, &blk); end

  def return_type=(return_type); end

  def type_params(*args, **arg, &blk); end
end

class RBI::SigBuilder
  def current(*args, **arg, &blk); end

  def current=(current); end

  def visit_send(*args, **arg, &blk); end
end

class RBI::SigBuilder
  def self.build(*args, **arg, &blk); end
end

class RBI::SigParam
  def ==(*args, **arg, &blk); end

  def comments_lines(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def print_comment_leading_space(*args, **arg, &blk); end

  def type(); end
end

class RBI::Struct
  def keyword_init(*args, **arg, &blk); end

  def keyword_init=(keyword_init); end

  def members(*args, **arg, &blk); end

  def members=(members); end

  def name(*args, **arg, &blk); end

  def name=(name); end
end

class RBI::TEnumBlock
  def <<(*args, **arg, &blk); end

  def empty?(*args, **arg, &blk); end

  def names(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::TStructConst
  def to_s(*args, **arg, &blk); end
end

class RBI::TStructField
  def default(*args, **arg, &blk); end

  def default=(default); end

  def fully_qualified_names(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class RBI::TStructProp
  def to_s(*args, **arg, &blk); end
end

class RBI::Tree
  def <<(*args, **arg, &blk); end

  def add_sig_templates!(*args, **arg, &blk); end

  def annotate!(*args, **arg, &blk); end

  def deannotate!(*args, **arg, &blk); end

  def empty?(*args, **arg, &blk); end

  def group_nodes!(*args, **arg, &blk); end

  def index(*args, **arg, &blk); end

  def merge(*args, **arg, &blk); end

  def nest_non_public_methods!(*args, **arg, &blk); end

  def nest_singleton_methods!(*args, **arg, &blk); end

  def nodes(*args, **arg, &blk); end

  def sort_nodes!(*args, **arg, &blk); end
end

class RBI::TreeBuilder
  def last_node(*args, **arg, &blk); end

  def post_process(*args, **arg, &blk); end

  def tree(*args, **arg, &blk); end
end

class RBI::TypeMember
  def fully_qualified_name(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(); end
end

class RBI::UnexpectedParserError
  def initialize(*args, **arg, &blk); end

  def last_location(*args, **arg, &blk); end

  def print_debug(*args, **arg, &blk); end
end

class RBI::Visibility
  def ==(*args, **arg, &blk); end

  def private?(*args, **arg, &blk); end

  def protected?(*args, **arg, &blk); end

  def public?(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end
end

class RBI::VisibilityGroup
  def visibility(*args, **arg, &blk); end
end

class RBI::Visitor
  def initialize(*args, **arg, &blk); end

  def visit(*args, **arg, &blk); end

  def visit_all(*args, **arg, &blk); end
end

class RDoc::Alias
  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end
end

class RDoc::AnyMethod
  def _call_seq(); end

  def section_title(); end

  def section_title=(section_title); end
end

class RDoc::Attr
  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end
end

class RDoc::ClassModule
  def initialize(name, superclass=T.unsafe(nil)); end
end

class RDoc::CodeObject
  def initialize_visibility(); end
end

class RDoc::Comment
  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end
end

class RDoc::Constant
  def initialize(name, value, comment); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context
  def add_module_by_normal_module(mod); end

  def initialize_methods_etc(); end

  def instance_methods(); end
end

class RDoc::Context::Section
  def initialize(parent, title, comment); end
end

class RDoc::CrossReference
  def initialize(context); end

  def resolve_method(name); end
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.detect_encoding(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Generator::Darkfish
  def initialize(store, options); end
end

class RDoc::Generator::JsonIndex
  def initialize(parent_generator, options); end
end

class RDoc::Generator::POT
  def initialize(store, options); end
end

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options=T.unsafe(nil)); end
end

class RDoc::Generator::RI
  def initialize(store, options); end
end

class RDoc::I18n::Locale
  def initialize(name); end
end

class RDoc::I18n::Text
  def initialize(raw); end
end

class RDoc::Markdown
  def _Table(); end

  def _TableColumn(); end

  def _TableItem(); end

  def _TableLine(); end

  def _TableRow(); end

  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals
  def initialize(str, debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markup
  def add_regexp_handling(pattern, name); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrChanger
  def self.keyword_init?(); end
end

class RDoc::Markup::AttrSpan
  def initialize(length, exclusive); end
end

class RDoc::Markup::AttributeManager
  def add_regexp_handling(pattern, name, exclusive=T.unsafe(nil)); end

  def convert_attrs_matching_word_pairs(str, attrs, exclusive); end

  def convert_attrs_word_pair_map(str, attrs, exclusive); end

  def convert_regexp_handlings(str, attrs, exclusive=T.unsafe(nil)); end

  def exclusive?(attr); end

  def exclusive_bitmap(); end

  def regexp_handlings(); end
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::Attributes
  def regexp_handling(); end
end

class RDoc::Markup::Document
  def initialize(*parts); end
end

class RDoc::Markup::Formatter
  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def convert_regexp_handling(target); end

  def initialize(options, markup=T.unsafe(nil)); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.keyword_init?(); end
end

class RDoc::Markup::Heading
  def self.keyword_init?(); end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end
end

class RDoc::Markup::IndentedParagraph
  def initialize(indent, *parts); end
end

class RDoc::Markup::List
  def initialize(type=T.unsafe(nil), *items); end
end

class RDoc::Markup::ListItem
  def initialize(label=T.unsafe(nil), *parts); end
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end
end

class RDoc::Markup::Raw
  def initialize(*parts); end
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::Table
  def ==(other); end

  def accept(visitor); end

  def align(); end

  def align=(align); end

  def body(); end

  def body=(body); end

  def header(); end

  def header=(header); end

  def initialize(header, align, body); end
end

class RDoc::Markup::Table
end

class RDoc::Markup::ToHtml
  def accept_table(header, body, aligns); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def init_link_notation_regexp_handlings(); end

  def init_regexp_handlings(); end
end

class RDoc::Markup::ToHtmlCrossref
  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToHtmlSnippet
  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToJoinedParagraph
  def accept_table(*node); end

  def initialize(); end
end

class RDoc::Markup::ToLabel
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToMarkdown
  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToRdoc
  def accept_table(header, body, aligns); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToTableOfContents
  def accept_table(*node); end

  def initialize(); end
end

class RDoc::Markup::ToTtOnly
  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::MethodAttr
  def initialize(text, name); end
end

class RDoc::Mixin
  def initialize(name, comment); end
end

class RDoc::Options
  def initialize(loaded_options=T.unsafe(nil)); end

  def override(map); end
end

class RDoc::Options
  def self.load_options(); end
end

class RDoc::Parser
  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  def add_alias(var_name, class_obj, old_name, new_name, comment); end

  def do_classes_and_modules(); end

  def new_comment(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end
end

class RDoc::Parser::ChangeLog
  def parse_date(date); end
end

module RDoc::Parser::ChangeLog::Git
  def create_entries(entries); end

  def parse_entries(); end

  def parse_info(info); end
  HEADING_LEVEL = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::ChangeLog::Git::LogEntry
  def accept(visitor); end

  def aref(); end

  def author(); end

  def author=(_); end

  def base(); end

  def base=(_); end

  def commit(); end

  def commit=(_); end

  def contents(); end

  def contents=(_); end

  def date(); end

  def date=(_); end

  def email(); end

  def email=(_); end

  def initialize(base, commit, author, email, date, contents); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def text(); end
end

class RDoc::Parser::ChangeLog::Git::LogEntry
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RDoc::Parser::ChangeLog::Git
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  def get_included_module_with_optional_parens(); end

  def parse_included_with_activesupport_concern(container, comment); end

  def retrieve_comment_body(tk); end
end

module RDoc::Parser::RubyTools
  def skip_tkspace_without_nl(); end
end

class RDoc::RD::BlockParser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::Inline
  def initialize(rdoc, reference); end
end

class RDoc::RD::InlineParser
  def initialize(block_parser); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RI::Driver
  def initialize(initial_options=T.unsafe(nil)); end
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end
end

RDoc::RI::Store = RDoc::Store

class RDoc::Require
  def initialize(name, comment); end
end

class RDoc::Servlet
  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end
end

class RDoc::Stats
  def initialize(store, num_files, verbosity=T.unsafe(nil)); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end
end

class RDoc::Store
  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::MissingFileError
  def initialize(store, file, name); end
end

class RDoc::Task
  def inline_source(); end

  def inline_source=(value); end
end

module RDoc::Text
  def language(); end

  def language=(language); end
end

class RDoc::TopLevel
  def initialize(absolute_name, relative_name=T.unsafe(nil)); end
end

module RDoc
  def self.home(); end
end

module REST
  VERSION = ::T.let(nil, ::T.untyped)
end

class REST::Response
  CODES = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end

  def parent(); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  EXTERNAL_ID_PUBLIC = ::T.let(nil, ::T.untyped)
  EXTERNAL_ID_SYSTEM = ::T.let(nil, ::T.untyped)
  PUBLIC_ID = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::ReferenceWriter
  def initialize(id_type, public_id_literal, system_literal, context=T.unsafe(nil)); end

  def write(output); end
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
  MARSHAL_DUMP_ENCODING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Configuration
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_exit_code=(error_exit_code); end

  def error_exit_code?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples(); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_exit_code(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def fuubar_auto_refresh(); end

  def fuubar_output_pending_results(); end

  def fuubar_progress_bar_options(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_alias(name, alias_name); end

  def self.define_predicate(name); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ==(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def eql?(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def ruby2_keywords(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  include ::Capybara::RSpecMatcherProxyInstaller
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.feature(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.ffeature(*args, &example_group_block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fscenario(*all_args, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.scenario(*all_args, &block); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xfeature(*args, &example_group_block); end

  def self.xit(*all_args, &block); end

  def self.xscenario(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*arg); end
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlPrinter
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct_keys(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def deep_transform_values(*args, &block); end

  def deep_transform_values!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def in_order_of(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def maximum(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minimum(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sole(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_defaults(*args, &block); end

  def with_defaults!(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::LegacyExampleGroupHash
  def initialize(metadata); end
end

module RSpec::Core::MemoizedHelpers
  def initialize(*arg); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

class RSpec::Core::MultipleExceptionError
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*arg); end

  def self.from_hash(data); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*arg); end

  def self.for(example); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::RecentlyModified
  def order(list); end
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def as_json(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def check_winsize_changed(*args, &block); end

  def clear_screen(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def console_mode(*args, &block); end

  def console_mode=(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def cursor_down(*args, &block); end

  def cursor_left(*args, &block); end

  def cursor_right(*args, &block); end

  def cursor_up(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def erase_line(*args, &block); end

  def erase_screen(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def goto_column(*args, &block); end

  def iflush(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def method_missing(name, *args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def scroll_backward(*args, &block); end

  def scroll_forward(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def set_encoding_by_bom(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_priority(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def exit_code(examples_passed=T.unsafe(nil)); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::Time
  def self.now(in: T.unsafe(nil)); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def rspec_is_quitting(); end

  def rspec_is_quitting=(rspec_is_quitting); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def strict_predicate_matchers(); end

  def strict_predicate_matchers=(flag); end

  def strict_predicate_matchers?(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

class RSpec::Expectations::ValueExpectationTarget
end

class RSpec::Expectations::ValueExpectationTarget
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  include ::Capybara::RSpecMatcherProxyInstaller
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_complete_translation_of(*expected, &block_arg); end

  def be_a_kind_of(expected); end

  def be_a_subset_of(*expected, &block_arg); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_named_like_top_level_namespace(*expected, &block_arg); end

  def be_nil(); end

  def be_parseable(*expected, &block_arg); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_a_valid_locale(*expected, &block_arg); end

  def have_attributes(expected); end

  def have_legacy_interpolations(*expected, &block_arg); end

  def have_missing_pluralization_keys(*expected, &block_arg); end

  def have_one_top_level_namespace(*expected, &block_arg); end

  def have_valid_pluralization_keys(*expected, &block_arg); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*arg); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual); end

  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

module RSpec::Matchers::BuiltIn::ChangeDetails::UNDEFINED
end

module RSpec::Matchers::BuiltIn::ChangeDetails::UNDEFINED
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

module RSpec::Matchers::BuiltIn::CountExpectation
  def at_least(number); end

  def at_most(number); end

  def count_expectation_type(); end

  def exactly(number); end

  def expected_count(); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

module RSpec::Matchers::BuiltIn::CountExpectation
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, **arg, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message, expected_message, &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end

  def with_message(expected_message); end
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
  def initialize(expected_arity, expected_keywords, arbitrary_keywords, unlimited_arguments); end

  def matches?(actual, name); end

  def method_signature_for(actual, name); end

  def verifier_for(actual, name); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::Capybara::RSpecMatcherProxyInstaller
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  extend ::Capybara::RSpecMatcherProxyInstaller::ClassMethods
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AndInvokeImplementation
  def call(*args, &block); end

  def initialize(procs_to_invoke); end
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, **arg, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AnyInstance::Chain
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*actual_args, **arg); end

  def expected_args(); end

  def initialize(*expected_args, **arg); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

module RSpec::Mocks::ExampleMethods
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::ExpectationTargetMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::Implementation
  def call(*args, **arg, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::HaveReceived
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::Receive
  def and_call_original(*args, **arg, &block); end

  def and_invoke(*args, **arg, &block); end

  def and_raise(*args, **arg, &block); end

  def and_return(*args, **arg, &block); end

  def and_throw(*args, **arg, &block); end

  def and_wrap_original(*args, **arg, &block); end

  def and_yield(*args, **arg, &block); end

  def at_least(*args, **arg, &block); end

  def at_most(*args, **arg, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, **arg, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, **arg, &block); end

  def once(*args, **arg, &block); end

  def ordered(*args, **arg, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, **arg, &block); end

  def time(*args, **arg, &block); end

  def times(*args, **arg, &block); end

  def twice(*args, **arg, &block); end

  def with(*args, **arg, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  def and_call_original(*args, &block); end

  def and_invoke(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageExpectation
  def and_call_original(); end

  def and_invoke(first_proc, *procs); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, **arg, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, **arg, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, **arg, &block); end

  def matches?(message, *args, **arg); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, **arg, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

class RSpec::Mocks::MethodDouble
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def initialize(object, method_name, proxy); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, **arg, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  def as_stubbed_const(options=T.unsafe(nil)); end
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def as_null_object(); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_can_be_proxied!(object); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, **arg, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def null_object?(); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  def initialize(target); end
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end

  def with(*args, &block); end
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingProxy
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

module RSpec::Rails::FeatureCheck
  def self.has_action_cable_testing?(); end

  def self.has_action_mailbox?(); end

  def self.has_action_mailer?(); end

  def self.has_action_mailer_parameterized?(); end

  def self.has_action_mailer_preview?(); end

  def self.has_action_mailer_unified_delivery?(); end

  def self.has_active_job?(); end

  def self.has_active_record?(); end

  def self.has_active_record_migration?(); end

  def self.type_metatag(type); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::ComparableVersion
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::HunkGenerator
  def hunks(); end

  def initialize(actual, expected); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*arg); end

  def self.can_inspect?(_object); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, **arg, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.current_scope(); end

  def self.current_scope=(scope); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.feature(*args, &example_group_block); end

  def self.ffeature(*args, &example_group_block); end

  def self.reset(); end

  def self.shared_context(name, *args, &block); end

  def self.shared_examples(name, *args, &block); end

  def self.shared_examples_for(name, *args, &block); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xfeature(*args, &example_group_block); end
end

class RSpecJUnitFormatter
  def dump_summary(notification); end

  def stop(notification); end
  DISCOURAGED_REGEXP = ::T.let(nil, ::T.untyped)
  DISCOURAGED_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  ILLEGAL_REGEXP = ::T.let(nil, ::T.untyped)
  ILLEGAL_REPLACEMENT = ::T.let(nil, ::T.untyped)
  STRIP_DIFF_COLORS_BLOCK_REGEXP = ::T.let(nil, ::T.untyped)
  STRIP_DIFF_COLORS_CODES_REGEXP = ::T.let(nil, ::T.untyped)
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *arg); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, **arg, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, **arg, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def initialize(io); end

  def read(*args, **arg, &block); end

  def read_nonblock(*args, **arg, &block); end

  def write(*args, **arg, &block); end

  def write_nonblock(*args, **arg, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MiniProfiler
  ASSET_VERSION = ::T.let(nil, ::T.untyped)
  SOURCE_CODE_URI = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::AbstractStore
  MAX_TOKEN_AGE = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::ClientSettings
  BACKTRACE_DEFAULT = ::T.let(nil, ::T.untyped)
  BACKTRACE_FULL = ::T.let(nil, ::T.untyped)
  BACKTRACE_NONE = ::T.let(nil, ::T.untyped)
  COOKIE_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::FileStore
  EXPIRES_IN_SECONDS = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::MemcacheStore
  EXPIRES_IN_SECONDS = ::T.let(nil, ::T.untyped)
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::MemoryStore
  CLEANUP_CYCLE = ::T.let(nil, ::T.untyped)
  CLEANUP_INTERVAL = ::T.let(nil, ::T.untyped)
  EXPIRES_IN_SECONDS = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler::RedisStore
  COUNTER_LUA = ::T.let(nil, ::T.untyped)
  COUNTER_LUA_SHA = ::T.let(nil, ::T.untyped)
  EXPIRES_IN_SECONDS = ::T.let(nil, ::T.untyped)
end

class Rack::MiniProfiler
  extend ::Rack::MiniProfiler::ProfilingMethods
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*arg, **arg1); end
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_h(); end

  def to_params_hash(); end
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*arg); end

  def generate_sid(*arg); end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Session
  include ::Rack::Utils
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.[](headers); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Rails::ApplicationController
  include ::GeneratedUrlHelpers
end

module Rails::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Rails::Conductor
end

module Rails::Conductor::ActionMailbox
end

module Rails::Conductor::ActionMailbox::InboundEmails
end

class Rails::Conductor::ActionMailbox::InboundEmails::SourcesController
  def create(); end

  def new(); end
end

class Rails::Conductor::ActionMailbox::InboundEmails::SourcesController
end

module Rails::Conductor::ActionMailbox::InboundEmails
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
end

class Rails::Conductor::ActionMailbox::IncineratesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::IncineratesController
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::BaseController
  include ::GeneratedUrlHelpers
end

module Rails::Conductor::BaseController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::ApplicationHelper
  include ::Pagy::Frontend
  include ::Pagy::UrlHelpers
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
  include ::PreviewHelper
  include ::DeviseHelper
end

module Rails::Conductor::BaseController::HelperMethods
end

class Rails::Conductor::BaseController
end

module Rails::Conductor
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Info
  def properties(); end

  def properties=(val); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(val); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

module Rails::MailersController::HelperMethods
  include ::Rails::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  include ::ApplicationHelper
  include ::Pagy::Frontend
  include ::Pagy::UrlHelpers
  include ::Pagy::FrontendHelpers::Frontend
  include ::Pagy::BulmaExtra
  include ::PreviewHelper
  include ::DeviseHelper
  def locale_query(*args, **arg, &block); end

  def part_query(*args, **arg, &block); end
end

module Rails::MailersController::HelperMethods
end

class Rails::MailersController
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module RailsAdmin
  AUDITING_ADAPTERS = ::T.let(nil, ::T.untyped)
  AUTHORIZATION_ADAPTERS = ::T.let(nil, ::T.untyped)
  CONFIGURATION_ADAPTERS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module RailsAdmin::Adapters::ActiveRecord
  def adapter_supports_joins?(); end

  def all(options=T.unsafe(nil), scope=T.unsafe(nil)); end

  def associations(); end

  def base_class(); end

  def build_statement(column, type, value, operator); end

  def count(options=T.unsafe(nil), scope=T.unsafe(nil)); end

  def cyclic?(); end

  def destroy(objects); end

  def embedded?(); end

  def encoding(); end

  def filter_scope(scope, filters, fields=T.unsafe(nil)); end

  def first(options=T.unsafe(nil), scope=T.unsafe(nil)); end

  def get(id, scope=T.unsafe(nil)); end

  def new(params=T.unsafe(nil)); end

  def primary_key(*arg, **arg1, &arg2); end

  def properties(); end

  def query_scope(scope, query, fields=T.unsafe(nil)); end

  def scoped(); end

  def table_name(*arg, **arg1, &arg2); end
  DISABLED_COLUMN_TYPES = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::Adapters::ActiveRecord::Association
  def as(); end

  def association(); end

  def association?(); end

  def foreign_inverse_of(); end

  def foreign_key(); end

  def foreign_key_nullable?(); end

  def foreign_type(); end

  def initialize(association, model); end

  def inverse_of(); end

  def key_accessor(); end

  def klass(); end

  def model(); end

  def name(); end

  def nested_options(); end

  def options(*arg, **arg1, &arg2); end

  def polymorphic?(); end

  def polymorphic_parents(*arg, **arg1, &arg2); end

  def pretty_name(); end

  def primary_key(); end

  def read_only?(); end

  def scope(*arg, **arg1, &arg2); end

  def type(); end
end

module RailsAdmin::Adapters::ActiveRecord::ObjectExtension
  def assign_attributes(attributes); end
end

module RailsAdmin::Adapters::ActiveRecord::ObjectExtension
  def self.extended(object); end
end

class RailsAdmin::Adapters::ActiveRecord::Property
  def association?(); end

  def initialize(property, model); end

  def length(); end

  def model(); end

  def name(); end

  def nullable?(); end

  def pretty_name(); end

  def property(); end

  def read_only?(); end

  def serial?(); end

  def type(); end
end

class RailsAdmin::Adapters::ActiveRecord::StatementBuilder
  def initialize(column, type, value, operator, adapter_name); end
end

class RailsAdmin::Adapters::ActiveRecord::WhereBuilder
  def add(field, value, operator); end

  def build(); end

  def initialize(scope); end
end

class RailsAdmin::ApplicationController
  def _current_user(); end

  def abstract_model(); end

  def authorization_adapter(); end

  def get_model(); end

  def get_object(); end

  def model_config(); end

  def object(); end

  def to_model_name(param); end
end

module RailsAdmin::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Hotwire::Livereload::LivereloadTagsHelper
  def _current_user(*args, **arg, &block); end

  def _get_plugin_name(*args, **arg, &block); end
end

module RailsAdmin::ApplicationHelper
  def action(key, abstract_model=T.unsafe(nil), object=T.unsafe(nil)); end

  def actions(scope=T.unsafe(nil), abstract_model=T.unsafe(nil), object=T.unsafe(nil)); end

  def authorized?(action_name, abstract_model=T.unsafe(nil), object=T.unsafe(nil)); end

  def breadcrumb(action=T.unsafe(nil), _acc=T.unsafe(nil)); end

  def bulk_menu(abstract_model=T.unsafe(nil)); end

  def current_action?(action, abstract_model=T.unsafe(nil), object=T.unsafe(nil)); end

  def edit_user_link(); end

  def flash_alert_class(flash_key); end

  def handle_asset_dependency_error(); end

  def logout_method(); end

  def logout_path(); end

  def main_navigation(); end

  def menu_for(parent, abstract_model=T.unsafe(nil), object=T.unsafe(nil), only_icon=T.unsafe(nil)); end

  def navigation(parent_groups, nodes, level=T.unsafe(nil)); end

  def root_navigation(); end

  def static_navigation(); end

  def wording_for(label, action=T.unsafe(nil), abstract_model=T.unsafe(nil), object=T.unsafe(nil)); end
end

module RailsAdmin::Config
  DEFAULT_AUDIT = ::T.let(nil, ::T.untyped)
  DEFAULT_AUTHENTICATION = ::T.let(nil, ::T.untyped)
  DEFAULT_AUTHORIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_CURRENT_USER = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::Config::Fields::Base
  NAMED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::Config::Model
  NAMED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::Config::Sections::Base
  NAMED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::ESModulePreprocessor
  def call(input); end
end

class RailsAdmin::ESModulePreprocessor
  def self.call(input); end

  def self.instance(); end
end

class RailsAdmin::Extensions::PaperTrail::AuditingAdapter
  COLUMN_MAPPING = ::T.let(nil, ::T.untyped)
  E_VERSION_MODEL_NOT_SET = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::FormBuilder
  def dom_id(field); end

  def dom_name(field); end

  def errors_for(field); end

  def field_for(field); end

  def field_wrapper_for(field, nested_in); end

  def fieldset_for(fieldset, nested_in); end

  def generate(options=T.unsafe(nil)); end

  def generator_action(action, nested); end

  def help_for(field); end

  def input_for(field); end

  def jquery_namespace(field); end

  def object_infos(); end

  def visible_groups(model_config, action); end

  def without_field_error_proc_added_div(); end
end

class RailsAdmin::MainController
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def bulk_action(); end

  def list_entries(model_config=T.unsafe(nil), auth_scope_key=T.unsafe(nil), additional_scope=T.unsafe(nil), pagination=T.unsafe(nil)); end
end

module RailsAdmin::MainHelper
  def filterable_fields(); end

  def get_indicator(percent); end

  def ordered_filter_options(); end

  def ordered_filters(); end

  def rails_admin_form_for(*args, &block); end
end

class RailsAdmin::Support::Datetime
  FLATPICKR_TRANSLATIONS = ::T.let(nil, ::T.untyped)
end

class RailsAdmin::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Analyzer
  def analyze(); end

  def analyze_source_codes(); end

  def analyze_vcs(); end

  def display_bar?(); end

  def error_types(); end

  def errors(); end

  def expand_dirs_to_files(*dirs); end

  def file_accept(files, patterns); end

  def file_ignore(files, pattern); end

  def file_sort(files); end

  def generate(); end

  def initialize(path, options=T.unsafe(nil)); end

  def load_git_info(); end

  def load_hg_info(); end

  def output(); end

  def output_html_errors(); end

  def output_json_errors(); end

  def output_terminal_errors(); end

  def output_xml_errors(); end

  def output_yaml_errors(); end

  def parse_files(); end

  def path(); end

  def plain_output(message, color); end

  def process(process); end

  def runner(); end

  def runner=(runner); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  GITHUB_URL = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::CLI
  def self.run(argv); end
end

class RailsBestPractices::Colorize
  def self.green(message); end

  def self.red(message); end
end

class RailsBestPractices::Core::Check
  def add_error(message, filename=T.unsafe(nil), line_number=T.unsafe(nil)); end

  def errors(); end

  def initialize(options=T.unsafe(nil)); end

  def is_ignored?(node_file); end

  def is_interesting_file?(node_file); end

  def method_missing(method_name, *args); end

  def regex_ignored_files(); end

  def url(); end
  ALL_FILES = ::T.let(nil, ::T.untyped)
  CAPFILE = ::T.let(nil, ::T.untyped)
  CONFIG_FILES = ::T.let(nil, ::T.untyped)
  CONTROLLER_FILES = ::T.let(nil, ::T.untyped)
  DEPLOY_FILES = ::T.let(nil, ::T.untyped)
  GEMFILE_LOCK = ::T.let(nil, ::T.untyped)
  HELPER_FILES = ::T.let(nil, ::T.untyped)
  INITIALIZER_FILES = ::T.let(nil, ::T.untyped)
  MAILER_FILES = ::T.let(nil, ::T.untyped)
  MIGRATION_FILES = ::T.let(nil, ::T.untyped)
  MODEL_FILES = ::T.let(nil, ::T.untyped)
  PARTIAL_VIEW_FILES = ::T.let(nil, ::T.untyped)
  ROUTE_FILES = ::T.let(nil, ::T.untyped)
  SCHEMA_FILE = ::T.let(nil, ::T.untyped)
  SKIP_FILES = ::T.let(nil, ::T.untyped)
  VIEW_FILES = ::T.let(nil, ::T.untyped)
end

module RailsBestPractices::Core::Check::Accessable
  def current_access_control(); end
end

module RailsBestPractices::Core::Check::Accessable
  def self.included(base); end
end

module RailsBestPractices::Core::Check::Callable
  def self.included(base); end
end

module RailsBestPractices::Core::Check::Classable
  def classable_modules(); end

  def current_class_name(); end

  def current_extend_class_name(); end

  def klasses(); end
end

module RailsBestPractices::Core::Check::Classable
  def self.included(base); end
end

module RailsBestPractices::Core::Check::Exceptable
  def self.included(base); end

  def self.matches(method, except_method); end
end

module RailsBestPractices::Core::Check::InheritedResourcesable
  def self.included(base); end
end

module RailsBestPractices::Core::Check::Moduleable
  def current_module_name(); end

  def moduleable_modules(); end
end

module RailsBestPractices::Core::Check::Moduleable
  def self.included(base); end
end

class RailsBestPractices::Core::Check
  def self.debug(); end

  def self.debug?(); end

  def self.url(url=T.unsafe(nil)); end
end

class RailsBestPractices::Core::ChecksLoader
  def initialize(config); end

  def load_lexicals(); end

  def load_reviews(); end
end

class RailsBestPractices::Core::Error
  def first_line_number(); end

  def git_commit(); end

  def git_commit=(git_commit); end

  def git_username(); end

  def git_username=(git_username); end

  def hg_commit(); end

  def hg_commit=(hg_commit); end

  def hg_username(); end

  def hg_username=(hg_username); end

  def short_filename(); end

  def type(); end

  def url(); end
end

class RailsBestPractices::Core::Gem
  def initialize(name, version); end

  def name(); end

  def version(); end
end

class RailsBestPractices::Core::Gems
  def gem_version(gem_name); end

  def has_gem?(gem_name); end
end

class RailsBestPractices::Core::Klass
  def class_name(); end

  def extend_class_name(); end

  def initialize(class_name, extend_class_name, modules); end
end

class RailsBestPractices::Core::Klasses
  def include?(class_name); end
end

class RailsBestPractices::Core::Method
  def access_control(); end

  def class_name(); end

  def file(); end

  def initialize(class_name, method_name, access_control, meta); end

  def line_number(); end

  def mark_used(); end

  def method_name(); end

  def publicize(); end

  def used(); end
end

class RailsBestPractices::Core::Methods
  def add_method(class_name, method_name, meta=T.unsafe(nil), access_control=T.unsafe(nil)); end

  def get_all_unused_methods(access_control=T.unsafe(nil)); end

  def get_method(class_name, method_name, access_control=T.unsafe(nil)); end

  def get_methods(class_name, access_control=T.unsafe(nil)); end

  def has_method?(class_name, method_name, access_control=T.unsafe(nil)); end

  def mark_parent_class_method_used(class_name, method_name); end

  def mark_parent_class_methods_publicize(class_name, method_name); end

  def mark_publicize(class_name, method_name); end

  def mark_subclasses_method_used(class_name, method_name); end

  def possible_public_used(method_name); end
end

class RailsBestPractices::Core::Mod
  def add_descendant(descendant); end

  def descendants(); end

  def initialize(module_name, modules); end
end

class RailsBestPractices::Core::ModelAssociations
  def add_association(model_name, association_name, association_meta, association_class=T.unsafe(nil)); end

  def each(&blk); end

  def get_association(model_name, association_name); end

  def get_association_class_name(table_name, association_name); end

  def is_association?(model_name, association_name); end
end

class RailsBestPractices::Core::ModelAttributes
  def add_attribute(model_name, attribute_name, attribute_type); end

  def get_attribute_type(model_name, attribute_name); end

  def is_attribute?(model_name, attribute_name); end
end

class RailsBestPractices::Core::Modules
  def add_module_descendant(module_name, descendant); end
end

class RailsBestPractices::Core::Route
  def action_name(); end

  def controller_name(); end

  def controller_name_with_namespaces(); end

  def initialize(namespaces, controller_name, action_name); end

  def namespaces(); end
end

class RailsBestPractices::Core::Routes
  def add_route(namespaces, controller_name, action_name); end
end

class RailsBestPractices::Core::Runner
  def after_inline_disable(); end

  def after_lexical(); end

  def after_prepare(); end

  def after_review(); end

  def checks(); end

  def errors(); end

  def initialize(options=T.unsafe(nil)); end

  def inline_disable(filename, content); end

  def lexical(filename, content); end

  def prepare(filename, content); end

  def review(filename, content); end
end

class RailsBestPractices::Core::Runner
  def self.base_path(); end

  def self.base_path=(base_path); end

  def self.config_path(); end

  def self.config_path=(config_path); end
end

class RailsBestPractices::InlineDisables::CommentRipper
  def comments(); end

  def initialize(*arg); end

  def on_comment(*arg); end
end

class RailsBestPractices::InlineDisables::InlineDisable
  def check(filename, content); end

  def disabled?(error); end

  def initialize(*args); end
end

class RailsBestPractices::Lexicals::LongLineCheck
  def check(filename, content); end
end

class RailsBestPractices::Lexicals::RemoveTabCheck
  def check(filename, content); end
end

class RailsBestPractices::Lexicals::RemoveTrailingWhitespaceCheck
  def check(filename, content); end
end

class RailsBestPractices::OptionParser
  def self.parse!(argv=T.unsafe(nil)); end
end

class RailsBestPractices::Prepares::ConfigPrepare
  def initialize(); end
end

class RailsBestPractices::Prepares::ControllerPrepare
  def initialize(); end
  DEFAULT_ACTIONS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Prepares::GemfilePrepare
  def check(_filename, content); end

  def initialize(); end
end

class RailsBestPractices::Prepares::HelperPrepare
  def initialize(); end
end

class RailsBestPractices::Prepares::InitializerPrepare
  def include_forbidden_attributes_protection?(node); end

  def initialize(); end
end

class RailsBestPractices::Prepares::MailerPrepare
  def initialize(); end
end

class RailsBestPractices::Prepares::ModelPrepare
  def initialize(); end
  ASSOCIATION_METHODS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Prepares::RoutePrepare
  def add_customize_routes(); end

  def add_resource_routes(node); end

  def add_resources_routes(node); end

  def current_controller_name(); end

  def current_namespaces(); end

  def get_resource_actions(action_names); end

  def get_resources_actions(action_names); end

  def initialize(); end
  RESOURCES_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_ACTIONS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Prepares::SchemaPrepare
  def initialize(); end
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
end

module RailsBestPractices::Prepares
  def self.clear(); end

  def self.configs(); end

  def self.controller_methods(); end

  def self.controllers(); end

  def self.gems(); end

  def self.helper_methods(); end

  def self.helpers(); end

  def self.klasses(); end

  def self.mailers(); end

  def self.model_associations(); end

  def self.model_attributes(); end

  def self.model_methods(); end

  def self.models(); end

  def self.routes(); end
end

class RailsBestPractices::Reviews::CheckDestroyReturnValueReview
  def model_classnames(); end

  def return_value_is_used?(node); end
end

class RailsBestPractices::Reviews::CheckSaveReturnValueReview
  def model_classnames(); end

  def return_value_is_used?(node); end
end

class RailsBestPractices::Reviews::HashSyntaxReview
  def empty_hash?(node); end

  def hash_is_18?(node); end

  def valid_keys?(node); end
  VALID_SYMBOL_KEY = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::KeepFindersOnTheirOwnModelReview
  FINDERS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::LawOfDemeterReview
  ASSOCIATION_METHODS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::MoveCodeIntoControllerReview
  FINDERS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::MoveFinderToNamedScopeReview
  FINDERS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::OveruseRouteCustomizationsReview
  VERBS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::RemoveEmptyHelpersReview
  def empty_body?(module_node); end
end

class RailsBestPractices::Reviews::RemoveUnusedMethodsInControllersReview
  def except_methods(); end

  def excepted?(method); end

  def internal_except_methods(); end

  def mark_publicize(method_name, class_name=T.unsafe(nil)); end

  def methods(); end

  def skip_command_callback_nodes(); end
  INHERITED_RESOURCES_METHODS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::RemoveUnusedMethodsInHelpersReview
  def except_methods(); end

  def excepted?(method); end

  def internal_except_methods(); end

  def methods(); end

  def skip_command_callback_nodes(); end
end

class RailsBestPractices::Reviews::RemoveUnusedMethodsInModelsReview
  def except_methods(); end

  def excepted?(method); end

  def internal_except_methods(); end

  def methods(); end

  def skip_command_callback_nodes(); end
end

class RailsBestPractices::Reviews::RestrictAutoGeneratedRoutesReview
  def check_method_add_block?(node); end

  def resource_methods(); end

  def resources_methods(); end
end

class RailsBestPractices::Reviews::Review
  def model_associations(); end

  def model_attributes(); end

  def models(); end

  def remember_variable_use_count(node); end

  def reset_variable_use_count(); end

  def variable(node); end

  def variable_use_count(); end
end

class RailsBestPractices::Reviews::SimplifyRenderInViewsReview
  def include_partial?(hash_node); end

  def valid_hash?(hash_node); end
  VALID_KEYS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::UseParenthesesInMethodDefReview
  def has_parameters?(def_node); end

  def no_parentheses_around_parameters?(def_node); end
end

class RailsBestPractices::Reviews::UseQueryAttributeReview
  QUERY_METHODS = ::T.let(nil, ::T.untyped)
end

class RailsBestPractices::Reviews::UseSayWithTimeInMigrationsReview
  WITH_SAY_METHODS = ::T.let(nil, ::T.untyped)
end

class RailsI18n::Railtie
  def self.add(pattern); end

  def self.init_pluralization_module(); end

  def self.pattern_from(args); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  def abbrev(*args, &block); end

  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def deconstruct(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fifth(*args, &block); end

  def filter_map(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def in_order_of(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inquiry(*args, &block); end

  def intersect?(*args, &block); end

  def intersection(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def minimum(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def sole(*args, &block); end

  def split(*args, &block); end

  def tally(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_csv(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_fs(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def without(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

Rake::RDocTask = RDoc::Task

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::EachTimeWithZone
  def %(arg); end

  def entries(); end

  def overlaps?(other); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Redis
  include ::Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def _client(); end

  def close(); end

  def commit(); end

  def connected?(); end

  def connection(); end

  def disconnect!(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def multi(&block); end

  def pipelined(&block); end

  def queue(*command); end

  def with_reconnect(val=T.unsafe(nil), &blk); end

  def without_reconnect(&blk); end
  BASE_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::BaseConnectionError
end

class Redis::BaseConnectionError
end

class Redis::BaseError
end

class Redis::BaseError
end

class Redis::CannotConnectError
end

class Redis::CannotConnectError
end

class Redis::Client
  def _parse_driver(driver); end

  def _parse_options(options); end

  def call(command); end

  def call_loop(command, timeout=T.unsafe(nil)); end

  def call_pipeline(pipeline); end

  def call_pipelined(pipeline); end

  def call_with_timeout(command, extra_timeout, &blk); end

  def call_without_timeout(command, &blk); end

  def close(); end

  def command_map(); end

  def connect(); end

  def connect_timeout(); end

  def connected?(); end

  def connection(); end

  def db(); end

  def db=(db); end

  def disconnect(); end

  def driver(); end

  def ensure_connected(); end

  def establish_connection(); end

  def host(); end

  def id(); end

  def inherit_socket?(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def location(); end

  def logger(); end

  def logger=(logger); end

  def logging(commands); end

  def options(); end

  def password(); end

  def path(); end

  def port(); end

  def process(commands); end

  def read(); end

  def read_timeout(); end

  def reconnect(); end

  def scheme(); end

  def timeout(); end

  def username(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_socket_timeout(timeout); end

  def without_reconnect(&blk); end

  def without_socket_timeout(&blk); end

  def write(command); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Redis::Client::Connector
  def check(client); end

  def initialize(options); end

  def resolve(); end
end

class Redis::Client::Connector::Sentinel
  def resolve_master(); end

  def resolve_slave(); end

  def sentinel_detect(); end
end

class Redis::Client::Connector::Sentinel
end

class Redis::Client::Connector
end

class Redis::Client
end

class Redis::Cluster
  def call(command, &block); end

  def call_loop(command, timeout=T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def call_without_timeout(command, &block); end

  def connected?(); end

  def connection_info(); end

  def db(); end

  def db=(_db); end

  def disconnect(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def process(commands, &block); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil), &block); end
end

class Redis::Cluster::AmbiguousNodeError
  def initialize(command); end
end

class Redis::Cluster::AmbiguousNodeError
end

class Redis::Cluster::Command
  def extract_first_key(command); end

  def initialize(details); end

  def should_send_to_master?(command); end

  def should_send_to_slave?(command); end
end

class Redis::Cluster::Command
end

class Redis::Cluster::CommandErrorCollection
  def errors(); end

  def initialize(errors, error_message=T.unsafe(nil)); end
end

class Redis::Cluster::CommandErrorCollection
end

module Redis::Cluster::CommandLoader
end

module Redis::Cluster::CommandLoader
  def self.load(nodes); end
end

class Redis::Cluster::CrossSlotPipeliningError
  def initialize(keys); end
end

class Redis::Cluster::CrossSlotPipeliningError
end

module Redis::Cluster::KeySlotConverter
  HASH_SLOTS = ::T.let(nil, ::T.untyped)
  XMODEM_CRC16_LOOKUP = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::KeySlotConverter
  def self.convert(key); end
end

class Redis::Cluster::Node
  include ::Enumerable
  def call_all(command, &block); end

  def call_master(command, &block); end

  def call_slave(command, &block); end

  def each(&block); end

  def find_by(node_key); end

  def initialize(options, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def process_all(commands, &block); end

  def sample(); end

  def scale_reading_clients(); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node
end

module Redis::Cluster::NodeKey
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::NodeKey
  def self.build_from_host_port(host, port); end

  def self.build_from_uri(uri); end

  def self.optionize(node_key); end

  def self.split(node_key); end
end

module Redis::Cluster::NodeLoader
end

module Redis::Cluster::NodeLoader
  def self.load_flags(nodes); end
end

class Redis::Cluster::Option
  def add_node(host, port); end

  def initialize(options); end

  def per_node_key(); end

  def update_node(addrs); end

  def use_replica?(); end
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Option
end

class Redis::Cluster::OrchestrationCommandNotSupported
  def initialize(command, subcommand=T.unsafe(nil)); end
end

class Redis::Cluster::OrchestrationCommandNotSupported
end

class Redis::Cluster::Slot
  def exists?(slot); end

  def find_node_key_of_master(slot); end

  def find_node_key_of_slave(slot); end

  def initialize(available_slots, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def put(slot, node_key); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Slot
end

module Redis::Cluster::SlotLoader
end

module Redis::Cluster::SlotLoader
  def self.load(nodes); end
end

class Redis::Cluster
end

class Redis::CommandError
end

class Redis::CommandError
end

module Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  def call(*command); end

  def sentinel(subcommand, *args); end
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  HashifyClusterNodeInfo = ::T.let(nil, ::T.untyped)
  HashifyClusterNodes = ::T.let(nil, ::T.untyped)
  HashifyClusterSlaves = ::T.let(nil, ::T.untyped)
  HashifyClusterSlots = ::T.let(nil, ::T.untyped)
  HashifyInfo = ::T.let(nil, ::T.untyped)
  HashifyStreamAutoclaim = ::T.let(nil, ::T.untyped)
  HashifyStreamAutoclaimJustId = ::T.let(nil, ::T.untyped)
  HashifyStreamEntries = ::T.let(nil, ::T.untyped)
  HashifyStreamPendingDetails = ::T.let(nil, ::T.untyped)
  HashifyStreamPendings = ::T.let(nil, ::T.untyped)
  HashifyStreams = ::T.let(nil, ::T.untyped)
  Noop = ::T.let(nil, ::T.untyped)
  Pairify = ::T.let(nil, ::T.untyped)
end

module Redis::Commands::Bitmaps
  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def getbit(key, offset); end

  def setbit(key, offset, value); end
end

module Redis::Commands::Bitmaps
end

module Redis::Commands::Cluster
  def asking(); end

  def cluster(subcommand, *args); end
end

module Redis::Commands::Cluster
end

module Redis::Commands::Connection
  def auth(*args); end

  def echo(value); end

  def ping(message=T.unsafe(nil)); end

  def quit(); end

  def select(db); end
end

module Redis::Commands::Connection
end

module Redis::Commands::Geo
  def geoadd(key, *member); end

  def geodist(key, member1, member2, unit=T.unsafe(nil)); end

  def geohash(key, member); end

  def geopos(key, member); end

  def georadius(*args, **geoptions); end

  def georadiusbymember(*args, **geoptions); end
end

module Redis::Commands::Geo
end

module Redis::Commands::Hashes
  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields, &blk); end

  def hmset(key, *attrs); end

  def hrandfield(key, count=T.unsafe(nil), withvalues: T.unsafe(nil), with_values: T.unsafe(nil)); end

  def hscan(key, cursor, **options); end

  def hscan_each(key, **options, &block); end

  def hset(key, *attrs); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end
end

module Redis::Commands::Hashes
end

module Redis::Commands::HyperLogLog
  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end
end

module Redis::Commands::HyperLogLog
end

module Redis::Commands::Keys
  def _exists(*keys); end

  def copy(source, destination, db: T.unsafe(nil), replace: T.unsafe(nil)); end

  def del(*keys); end

  def dump(key); end

  def exists(*keys); end

  def exists?(*keys); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def keys(pattern=T.unsafe(nil)); end

  def migrate(key, options); end

  def move(key, db); end

  def object(*args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pttl(key); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, replace: T.unsafe(nil)); end

  def scan(cursor, **options); end

  def scan_each(**options, &block); end

  def sort(key, by: T.unsafe(nil), limit: T.unsafe(nil), get: T.unsafe(nil), order: T.unsafe(nil), store: T.unsafe(nil)); end

  def ttl(key); end

  def type(key); end

  def unlink(*keys); end
end

module Redis::Commands::Keys
end

module Redis::Commands::Lists
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, deprecated_timeout=T.unsafe(nil), timeout: T.unsafe(nil)); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lmove(source, destination, where_source, where_destination); end

  def lpop(key, count=T.unsafe(nil)); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def rpop(key, count=T.unsafe(nil)); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end
end

module Redis::Commands::Lists
end

module Redis::Commands::Pubsub
  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def publish(channel, message); end

  def pubsub(subcommand, *args); end

  def punsubscribe(*channels); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscribed?(); end

  def unsubscribe(*channels); end
end

module Redis::Commands::Pubsub
end

module Redis::Commands::Scripting
  def eval(*args); end

  def evalsha(*args); end

  def script(subcommand, *args); end
end

module Redis::Commands::Scripting
end

module Redis::Commands::Server
  def bgrewriteaof(); end

  def bgsave(); end

  def client(subcommand=T.unsafe(nil), *args); end

  def config(action, *args); end

  def dbsize(); end

  def debug(*args); end

  def flushall(options=T.unsafe(nil)); end

  def flushdb(options=T.unsafe(nil)); end

  def info(cmd=T.unsafe(nil)); end

  def lastsave(); end

  def monitor(&block); end

  def save(); end

  def shutdown(); end

  def slaveof(host, port); end

  def slowlog(subcommand, length=T.unsafe(nil)); end

  def sync(); end

  def time(); end
end

module Redis::Commands::Server
end

module Redis::Commands::Sets
  def sadd(key, member); end

  def scard(key); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smismember(key, *members); end

  def smove(source, destination, member); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, **options); end

  def sscan_each(key, **options, &block); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end
end

module Redis::Commands::Sets
end

module Redis::Commands::SortedSets
  def bzpopmax(*args); end

  def bzpopmin(*args); end

  def zadd(key, *args, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil), ch: T.unsafe(nil), incr: T.unsafe(nil)); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zdiff(*keys, with_scores: T.unsafe(nil)); end

  def zdiffstore(*args, **arg); end

  def zincrby(key, increment, member); end

  def zinter(*args, **arg); end

  def zinterstore(*args, **arg); end

  def zlexcount(key, min, max); end

  def zmscore(key, *members); end

  def zpopmax(key, count=T.unsafe(nil)); end

  def zpopmin(key, count=T.unsafe(nil)); end

  def zrandmember(key, count=T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  def zrange(key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  def zrangebylex(key, min, max, limit: T.unsafe(nil)); end

  def zrangebyscore(key, min, max, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  def zrangestore(dest_key, src_key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  def zrevrangebylex(key, max, min, limit: T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscan(key, cursor, **options); end

  def zscan_each(key, **options, &block); end

  def zscore(key, member); end

  def zunion(*args, **arg); end

  def zunionstore(*args, **arg); end
end

module Redis::Commands::SortedSets
end

module Redis::Commands::Streams
  def xack(key, group, *ids); end

  def xadd(key, entry, approximate: T.unsafe(nil), maxlen: T.unsafe(nil), id: T.unsafe(nil)); end

  def xautoclaim(key, group, consumer, min_idle_time, start, count: T.unsafe(nil), justid: T.unsafe(nil)); end

  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  def xdel(key, *ids); end

  def xgroup(subcommand, key, group, id_or_consumer=T.unsafe(nil), mkstream: T.unsafe(nil)); end

  def xinfo(subcommand, key, group=T.unsafe(nil)); end

  def xlen(key); end

  def xpending(key, group, *args); end

  def xrange(key, start=T.unsafe(nil), range_end=T.unsafe(nil), count: T.unsafe(nil)); end

  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  def xreadgroup(group, consumer, keys, ids, count: T.unsafe(nil), block: T.unsafe(nil), noack: T.unsafe(nil)); end

  def xrevrange(key, range_end=T.unsafe(nil), start=T.unsafe(nil), count: T.unsafe(nil)); end

  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end
end

module Redis::Commands::Streams
end

module Redis::Commands::Strings
  def append(key, value); end

  def decr(key); end

  def decrby(key, decrement); end

  def get(key); end

  def getdel(key); end

  def getex(key, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), persist: T.unsafe(nil)); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def mget(*keys, &blk); end

  def mset(*args); end

  def msetnx(*args); end

  def psetex(key, ttl, value); end

  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil), get: T.unsafe(nil)); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def strlen(key); end
end

module Redis::Commands::Strings
end

module Redis::Commands::Transactions
  def discard(); end

  def exec(); end

  def unwatch(); end

  def watch(*keys); end
end

module Redis::Commands::Transactions
end

module Redis::Commands
end

module Redis::Connection
end

module Redis::Connection::CommandHelper
  def build_command(args); end

  def encode(string); end
  COMMAND_DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::CommandHelper
end

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper
  def connected?(); end

  def disconnect(); end

  def format_bulk_reply(line); end

  def format_error_reply(line); end

  def format_integer_reply(line); end

  def format_multi_bulk_reply(line); end

  def format_reply(reply_type, line); end

  def format_status_reply(line); end

  def get_tcp_keepalive(); end

  def initialize(sock); end

  def read(); end

  def set_tcp_keepalive(keepalive); end

  def set_tcp_nodelay(); end

  def timeout=(timeout); end

  def write(command); end

  def write_timeout=(timeout); end
  ASTERISK = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
  MINUS = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
end

class Redis::Connection::Ruby
  def self.connect(config); end
end

class Redis::Connection::SSLSocket
  include ::Redis::Connection::SocketMixin
  def wait_readable(timeout=T.unsafe(nil)); end

  def wait_writable(timeout=T.unsafe(nil)); end
end

class Redis::Connection::SSLSocket
  def self.connect(host, port, timeout, ssl_params); end
end

module Redis::Connection::SocketMixin
  def _read_from_socket(nbytes, buffer=T.unsafe(nil)); end

  def gets(); end

  def initialize(*args); end

  def read(nbytes); end

  def timeout=(timeout); end

  def write(buffer); end

  def write_timeout=(timeout); end
  CRLF = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  def self.connect(host, port, timeout); end

  def self.connect_addrinfo(addrinfo, port, timeout); end
end

class Redis::Connection::UNIXSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::UNIXSocket
  def self.connect(path, timeout); end
end

module Redis::Connection
  def self.drivers(); end
end

class Redis::ConnectionError
end

class Redis::ConnectionError
end

class Redis::Deprecated
end

class Redis::Deprecated
end

class Redis::DeprecatedMulti
  def initialize(pipeline); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Redis::DeprecatedMulti
end

class Redis::DeprecatedPipeline
  def initialize(pipeline); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Redis::DeprecatedPipeline
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, deprecated_timeout=T.unsafe(nil), **options); end

  def copy(source, destination, **options); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(*args); end

  def exists?(*args); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getdel(key); end

  def getex(key, **options); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hrandfield(key, count=T.unsafe(nil), **options); end

  def hset(key, *attrs); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lmove(source, destination, where_source, where_destination); end

  def lpop(key, count=T.unsafe(nil)); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(_hash); end

  def mapped_msetnx(_hash); end

  def mget(*keys); end

  def migrate(_key, _options); end

  def monitor(); end

  def move(key, db); end

  def mset(*_args); end

  def msetnx(*_args); end

  def multi(&block); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, **options); end

  def ring(); end

  def rpop(key, count=T.unsafe(nil)); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, **options); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smismember(key, *members); end

  def smove(source, destination, member); end

  def sort(key, **options); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, **options); end

  def sscan_each(key, **options, &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys, &block); end

  def zadd(key, *args, **arg); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zdiff(*keys, **options); end

  def zdiffstore(destination, keys, **options); end

  def zincrby(key, increment, member); end

  def zinter(*keys, **options); end

  def zinterstore(destination, keys, **options); end

  def zmscore(key, *members); end

  def zrandmember(key, count=T.unsafe(nil), **options); end

  def zrange(key, start, stop, **options); end

  def zrangebyscore(key, min, max, **options); end

  def zrangestore(dest_key, src_key, start, stop, **options); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, **options); end

  def zrevrangebyscore(key, max, min, **options); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunion(*keys, **options); end

  def zunionstore(destination, keys, **options); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  def ==(_other); end

  def _command(); end

  def _set(object); end

  def class(); end

  def initialize(command, transformation, timeout); end

  def inspect(); end

  def is_a?(other); end

  def timeout(); end

  def value(); end
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::Future
end

class Redis::FutureNotReady
  def initialize(); end
end

class Redis::FutureNotReady
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def get_node_pos(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def self.binary_search(ary, value); end
end

class Redis::InheritedError
end

class Redis::InheritedError
end

class Redis::InvalidClientOptionError
end

class Redis::InvalidClientOptionError
end

class Redis::Pipeline
  def call(command, timeout: T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def client(); end

  def commands(); end

  def db(); end

  def db=(db); end

  def empty?(); end

  def finish(replies, &blk); end

  def futures(); end

  def initialize(client); end

  def shutdown?(); end

  def timeout(); end

  def timeouts(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_reconnect?(); end

  def without_reconnect(&blk); end

  def without_reconnect?(); end
  REDIS_INTERNAL_PATH = ::T.let(nil, ::T.untyped)
  STDLIB_PATH = ::T.let(nil, ::T.untyped)
end

class Redis::Pipeline::Multi
  def finish(replies); end
end

class Redis::Pipeline::Multi
end

class Redis::Pipeline
  def self.deprecation_warning(method, caller_locations); end
end

class Redis::PipelinedConnection
  include ::Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  def db(); end

  def db=(db); end

  def initialize(pipeline); end

  def pipelined(); end
end

class Redis::PipelinedConnection
end

class Redis::ProtocolError
  def initialize(reply_type); end
end

class Redis::ProtocolError
end

class Redis::SubscribedClient
  def call(command); end

  def initialize(client); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def punsubscribe(*channels); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscription(start, stop, channels, block, timeout=T.unsafe(nil)); end

  def unsubscribe(*channels); end
end

class Redis::SubscribedClient
end

class Redis::Subscription
  def callbacks(); end

  def message(&block); end

  def pmessage(&block); end

  def psubscribe(&block); end

  def punsubscribe(&block); end

  def subscribe(&block); end

  def unsubscribe(&block); end
end

class Redis::Subscription
end

class Redis::TimeoutError
end

class Redis::TimeoutError
end

class Redis
  def self.current(); end

  def self.current=(redis); end

  def self.deprecate!(message); end

  def self.exists_returns_integer(); end

  def self.exists_returns_integer=(value); end

  def self.raise_deprecations(); end

  def self.raise_deprecations=(raise_deprecations); end

  def self.silence_deprecations(); end

  def self.silence_deprecations=(silence_deprecations); end
end

module Reek
  DEFAULT_CONFIGURATION_FILE_NAME = ::T.let(nil, ::T.untyped)
  DEFAULT_SMELL_CONFIGURATION = ::T.let(nil, ::T.untyped)
  DETECTORS_KEY = ::T.let(nil, ::T.untyped)
  DIRECTORIES_KEY = ::T.let(nil, ::T.untyped)
  EXCLUDE_PATHS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::AST::ASTNodeClassMap
  def extension_map(); end

  def klass_for(type); end
end

class Reek::AST::Node
  def condition(); end

  def contains_nested_node?(target_type); end

  def each_node(target_types, ignoring=T.unsafe(nil), &blk); end

  def format_to_ruby(); end

  def full_comment(); end

  def initialize(type, children=T.unsafe(nil), options=T.unsafe(nil)); end

  def leading_comment(); end

  def length(); end

  def line(); end

  def look_for(target_types, ignoring, &blk); end

  def look_for_recurse(target_types, ignoring, &blk); end

  def name(); end

  def source(); end

  def statements(); end
end

class Reek::AST::ObjectRefs
  def most_popular(); end

  def record_reference(name:, line: T.unsafe(nil)); end

  def references_to(name); end

  def self_is_max?(); end
end

class Reek::AST::ReferenceCollector
  def initialize(ast); end

  def num_refs_to_self(); end
end

module Reek::AST::SexpExtensions::ArgNodeBase
  def anonymous_splat?(); end

  def block?(); end

  def components(); end

  def marked_unused?(); end

  def name(); end

  def optional_argument?(); end

  def plain_name(); end
end

module Reek::AST::SexpExtensions::BeginNode
  def statements(); end
end

module Reek::AST::SexpExtensions::BlockNode
  def args(); end

  def block(); end

  def call(); end

  def parameter_names(); end

  def parameters(); end

  def simple_name(); end

  def without_block_arguments?(); end
end

module Reek::AST::SexpExtensions::BlockargNode
  def block?(); end
end

Reek::AST::SexpExtensions::CSendNode = Reek::AST::SexpExtensions::SendNode

module Reek::AST::SexpExtensions::CaseNode
  def body_nodes(type, ignoring=T.unsafe(nil)); end

  def condition(); end

  def else_body(); end
end

module Reek::AST::SexpExtensions::CasgnNode
  def defines_module?(); end

  def name(); end

  def superclass(); end

  def value(); end
end

module Reek::AST::SexpExtensions::ClassNode
  def superclass(); end
end

module Reek::AST::SexpExtensions::ConstNode
  def name(); end

  def namespace(); end

  def simple_name(); end
end

module Reek::AST::SexpExtensions::ConstantDefiningNodeBase
  def full_name(outer); end

  def simple_name(); end
end

Reek::AST::SexpExtensions::CvasgnNode = Reek::AST::SexpExtensions::CvarNode

Reek::AST::SexpExtensions::CvdeclNode = Reek::AST::SexpExtensions::CvarNode

module Reek::AST::SexpExtensions::DefNode
  def argslist(); end

  def body(); end

  def depends_on_instance?(); end

  def full_name(outer); end

  def name(); end
end

module Reek::AST::SexpExtensions::DefsNode
  def argslist(); end

  def body(); end

  def depends_on_instance?(); end

  def full_name(outer); end

  def name(); end

  def receiver(); end
end

module Reek::AST::SexpExtensions::Forward_ArgNode
  def anonymous_splat?(); end
end

module Reek::AST::SexpExtensions::Forward_ArgsNode
  def anonymous_splat?(); end
end

module Reek::AST::SexpExtensions::IfNode
  def body_nodes(type, ignoring=T.unsafe(nil)); end

  def condition(); end
end

module Reek::AST::SexpExtensions::KwoptargNode
  def optional_argument?(); end
end

module Reek::AST::SexpExtensions::KwrestargNode
  def anonymous_splat?(); end
end

module Reek::AST::SexpExtensions::LambdaNode
  def name(); end
end

module Reek::AST::SexpExtensions::LogicOperatorBase
  def body_nodes(type, ignoring=T.unsafe(nil)); end

  def condition(); end
end

module Reek::AST::SexpExtensions::LvarNode
  def var_name(); end
end

Reek::AST::SexpExtensions::LvasgnNode = Reek::AST::SexpExtensions::LvarNode

module Reek::AST::SexpExtensions::MethodNodeBase
  def arg_names(); end

  def arguments(); end

  def body_nodes(types, ignoring=T.unsafe(nil)); end

  def ends_with_bang?(); end

  def name_without_bang(); end

  def parameter_names(); end

  def parameters(); end
end

module Reek::AST::SexpExtensions::ModuleNodeBase
  def direct_children(); end

  def name(); end
end

module Reek::AST::SexpExtensions::NestedAssignables
  def components(); end
end

Reek::AST::SexpExtensions::Op_AsgnNode = Reek::AST::SexpExtensions::SendNode

module Reek::AST::SexpExtensions::OptargNode
  def optional_argument?(); end
end

module Reek::AST::SexpExtensions::RestargNode
  def anonymous_splat?(); end
end

module Reek::AST::SexpExtensions::SelfNode
  def name(); end
end

module Reek::AST::SexpExtensions::SendNode
  def args(); end

  def attr_with_writable_flag?(); end

  def attribute_writer?(); end

  def module_creation_call?(); end

  def module_creation_receiver?(); end

  def name(); end

  def object_creation_call?(); end

  def participants(); end

  def receiver(); end
  ATTR_DEFN_METHODS = ::T.let(nil, ::T.untyped)
end

module Reek::AST::SexpExtensions::SuperNode
  def name(); end
end

module Reek::AST::SexpExtensions::SymNode
  def full_name(outer); end

  def name(); end
end

module Reek::AST::SexpExtensions::VariableBase
  def name(); end
end

module Reek::AST::SexpExtensions::WhenNode
  def body(); end

  def condition_list(); end
end

module Reek::AST::SexpExtensions::YieldNode
  def args(); end
end

Reek::AST::SexpExtensions::ZsuperNode = Reek::AST::SexpExtensions::SuperNode

module Reek::CLI::Silencer
  def self.silently(); end

  def self.without_warnings(); end
end

class Reek::CodeComment
  def config(); end

  def descriptive?(); end

  def initialize(comment:, line: T.unsafe(nil), source: T.unsafe(nil)); end
  CONFIGURATION_REGEX = ::T.let(nil, ::T.untyped)
  DISABLE_DETECTOR_CONFIGURATION = ::T.let(nil, ::T.untyped)
  MINIMUM_CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  SANITIZE_REGEX = ::T.let(nil, ::T.untyped)
end

class Reek::CodeComment::CodeCommentValidator
  def initialize(detector_name:, original_comment:, line:, source:, options:); end

  def parsed_options(); end

  def validate(); end
end

class Reek::Configuration::AppConfiguration
  def directive_for(source_via); end

  def initialize(values: T.unsafe(nil)); end

  def load_values(values); end

  def path_excluded?(path); end
end

class Reek::Configuration::AppConfiguration
  def self.default(); end

  def self.from_default_path(); end

  def self.from_hash(hash); end

  def self.from_path(path); end
end

class Reek::Configuration::ConfigurationConverter
  def configuration(); end

  def convert(); end

  def initialize(configuration); end
  REGEXABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module Reek::Configuration::ConfigurationFileFinder
  DEFAULT_FILE_NAME = ::T.let(nil, ::T.untyped)
end

module Reek::Configuration::ConfigurationFileFinder
  extend ::Reek::Configuration::ConfigurationValidator
  def self.find(path: T.unsafe(nil), current: T.unsafe(nil), home: T.unsafe(nil)); end

  def self.find_and_load(path: T.unsafe(nil)); end

  def self.load_from_file(path); end
end

module Reek::Configuration::DefaultDirective
  def add(detectors_configuration); end
end

module Reek::Configuration::DirectoryDirectives
  def add(directory_config); end

  def directive_for(source_via); end
end

module Reek::Configuration::ExcludedPaths
  def add(paths); end
end

class Reek::Configuration::SchemaValidator
  def initialize(configuration); end

  def validate(); end
  SCHEMA_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class Reek::Context::AttributeContext
  def apply_current_visibility(current_visibility); end

  def initialize(exp, send_expression); end

  def visibility(); end

  def visibility=(visibility); end
end

class Reek::Context::CodeContext
  def append_child_context(child); end

  def apply_current_visibility(_current_visibility); end

  def children(); end

  def config_for(detector_class); end

  def each(&block); end

  def exp(); end

  def full_name(); end

  def initialize(exp); end

  def instance_method?(); end

  def local_nodes(type, ignored=T.unsafe(nil), &blk); end

  def matches?(candidates); end

  def name(*args, **arg, &block); end

  def number_of_statements(); end

  def parent(); end

  def record_call_to(exp); end

  def record_use_of_self(); end

  def register_with_parent(parent); end

  def singleton_method?(); end

  def statement_counter(); end

  def type(*args, **arg, &block); end
end

class Reek::Context::MethodContext
  def apply_current_visibility(current_visibility); end

  def default_assignments(); end

  def initialize(exp, parent_exp); end

  def method_context_class(); end

  def module_function?(); end

  def non_public_visibility?(); end

  def references_self?(); end

  def unused_params(); end

  def uses_param?(param); end

  def uses_super_with_implicit_arguments?(); end

  def visibility(); end

  def visibility=(visibility); end
end

class Reek::Context::ModuleContext
  def attribute_context_class(); end

  def defined_instance_methods(visibility: T.unsafe(nil)); end

  def descriptively_commented?(); end

  def instance_method_calls(); end

  def method_context_class(); end

  def namespace_module?(); end

  def node_instance_methods(); end

  def track_visibility(visibility, names); end

  def visibility_tracker(); end
  CONSTANT_SEXP_TYPES = ::T.let(nil, ::T.untyped)
end

class Reek::Context::RootContext
  def method_context_class(); end

  def type(); end
end

class Reek::Context::SendContext
  def initialize(exp, name); end

  def name(); end
end

class Reek::Context::SingletonMethodContext
  def defined_as_instance_method?(); end
end

class Reek::Context::StatementCounter
  def decrease_by(number); end

  def increase_by(sexp); end

  def value(); end
end

class Reek::Context::VisibilityTracker
  def apply_visibility(context); end

  def track_singleton_visibility(children:, visibility:, names:); end

  def track_visibility(children:, visibility:, names:); end
  VISIBILITY_MAP = ::T.let(nil, ::T.untyped)
  VISIBILITY_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class Reek::ContextBuilder
  def context_tree(); end

  def initialize(syntax_tree); end
end

class Reek::DetectorRepository
  def examine(context); end

  def initialize(smell_types: T.unsafe(nil), configuration: T.unsafe(nil)); end
end

class Reek::DetectorRepository
  def self.available_detector_names(); end

  def self.eligible_smell_types(filter_by_smells=T.unsafe(nil)); end

  def self.smell_types(); end
end

module Reek::DocumentationLink
  HELP_LINK_TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Reek::DocumentationLink
  def self.build(subject); end

  def self.name_to_param(name); end
end

class Reek::Errors::BadDetectorConfigurationKeyInCommentError
  def initialize(detector_name:, offensive_keys:, source:, line:, original_comment:); end
  UNKNOWN_SMELL_DETECTOR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::BadDetectorInCommentError
  def initialize(detector_name:, source:, line:, original_comment:); end
  UNKNOWN_SMELL_DETECTOR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::BaseError
  def long_message(); end
end

class Reek::Errors::EncodingError
  def initialize(origin:); end
  LONG_TEMPLATE = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::GarbageDetectorConfigurationInCommentError
  def initialize(detector_name:, source:, line:, original_comment:); end
  BAD_DETECTOR_CONFIGURATION_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::IncomprehensibleSourceError
  def initialize(origin:); end
  LONG_TEMPLATE = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::LegacyCommentSeparatorError
  def initialize(source:, line:, original_comment:); end
  MESSAGE = ::T.let(nil, ::T.untyped)
end

class Reek::Errors::SyntaxError
  def initialize(origin:); end
  LONG_TEMPLATE = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Reek::Examiner
  def initialize(source, filter_by_smells: T.unsafe(nil), configuration: T.unsafe(nil), detector_repository_class: T.unsafe(nil), error_handler: T.unsafe(nil)); end

  def origin(); end

  def smells(); end

  def smells_count(); end

  def smelly?(); end
end

class Reek::Examiner::NullHandler
  def handle(_exception); end
end

class Reek::Overrides
  def for_context(context); end

  def initialize(hash); end
end

module Reek::Report
  HEADING_FORMATTERS = ::T.let(nil, ::T.untyped)
  LOCATION_FORMATTERS = ::T.let(nil, ::T.untyped)
  PROGRESS_FORMATTERS = ::T.let(nil, ::T.untyped)
  REPORT_CLASSES = ::T.let(nil, ::T.untyped)
  WARNING_FORMATTER_CLASSES = ::T.let(nil, ::T.untyped)
end

class Reek::Report::BaseReport
  def add_examiner(examiner); end

  def initialize(heading_formatter: T.unsafe(nil), sort_by_issue_count: T.unsafe(nil), warning_formatter: T.unsafe(nil), progress_formatter: T.unsafe(nil)); end

  def show(); end

  def smells(); end

  def smells?(); end

  def total_smell_count(); end

  def total_smell_count=(total_smell_count); end
  NO_WARNINGS_COLOR = ::T.let(nil, ::T.untyped)
  WARNINGS_COLOR = ::T.let(nil, ::T.untyped)
end

module Reek::Report::BlankLocationFormatter
  def self.format(_warning); end
end

module Reek::Report::DefaultLocationFormatter
  def self.format(warning); end
end

class Reek::Report::HeadingFormatterBase
  def header(examiner); end

  def show_header?(_examiner); end
end

class Reek::Report::JSONReport
  def show(out=T.unsafe(nil)); end
end

class Reek::Report::ProgressFormatter::Base
  def footer(); end

  def header(); end

  def initialize(sources_count); end

  def progress(_examiner); end

  def sources_count(); end
end

class Reek::Report::ProgressFormatter::Dots
  def progress(examiner); end
  NO_WARNINGS_COLOR = ::T.let(nil, ::T.untyped)
  WARNINGS_COLOR = ::T.let(nil, ::T.untyped)
end

class Reek::Report::QuietHeadingFormatter
  def show_header?(examiner); end
end

class Reek::Report::SimpleWarningFormatter
  def format(warning); end

  def format_list(warnings); end

  def initialize(location_formatter: T.unsafe(nil)); end
end

module Reek::Report::SingleLineLocationFormatter
  def self.format(warning); end
end

class Reek::Report::TextReport
  def initialize(**args); end
end

class Reek::Report::YAMLReport
  def show(out=T.unsafe(nil)); end
end

module Reek::Report
  def self.heading_formatter(heading_format); end

  def self.location_formatter(location_format); end

  def self.progress_formatter(progress_format); end

  def self.report_class(report_format); end

  def self.warning_formatter_class(warning_format); end
end

class Reek::SmellConfiguration
  def enabled?(); end

  def initialize(hash); end

  def merge(new_options); end

  def overrides_for(context); end

  def value(key, context); end
  ENABLED_KEY = ::T.let(nil, ::T.untyped)
  OVERRIDES_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::Attribute
  def sniff(); end
end

class Reek::SmellDetectors::BaseDetector
  def config(); end

  def initialize(configuration: T.unsafe(nil), context: T.unsafe(nil)); end

  def run(); end

  def smell_type(); end
  DEFAULT_EXCLUDE_SET = ::T.let(nil, ::T.untyped)
  EXCLUDE_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::BaseDetector
  def self.configuration_keys(); end

  def self.contexts(); end

  def self.default_config(); end

  def self.inherited(subclass); end

  def self.smell_type(); end

  def self.to_detector(detector_name); end

  def self.todo_configuration_for(smells); end
end

class Reek::SmellDetectors::BooleanParameter
  def sniff(); end
  BOOLEAN_VALUES = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::ClassVariable
  def class_variables_in_context(); end

  def sniff(); end
end

class Reek::SmellDetectors::ControlParameter
  def sniff(); end
end

class Reek::SmellDetectors::ControlParameterHelpers::CallInConditionFinder
  def initialize(node, parameter); end

  def uses_param_in_call_in_condition?(); end
  COMPARISON_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::ControlParameterHelpers::Candidate
  def initialize(parameter, occurences); end

  def lines(); end

  def name(); end

  def smells?(); end
end

class Reek::SmellDetectors::ControlParameterHelpers::ControlParameterFinder
  def find_matches(); end

  def initialize(node, parameter); end

  def legitimate_uses?(); end
  CONDITIONAL_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::DataClump
  def sniff(); end
  DEFAULT_MAX_COPIES = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_CLUMP_SIZE = ::T.let(nil, ::T.untyped)
  MAX_COPIES_KEY = ::T.let(nil, ::T.untyped)
  MIN_CLUMP_SIZE_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::DataClump
  def self.print_clump(clump); end
end

class Reek::SmellDetectors::DuplicateMethodCall
  def sniff(); end
  ALLOW_CALLS_KEY = ::T.let(nil, ::T.untyped)
  DEFAULT_ALLOW_CALLS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_CALLS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_CALLS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::FeatureEnvy
  def sniff(); end
end

class Reek::SmellDetectors::InstanceVariableAssumption
  def sniff(); end
end

class Reek::SmellDetectors::IrresponsibleModule
  def sniff(); end
end

class Reek::SmellDetectors::LongParameterList
  def sniff(); end
  DEFAULT_MAX_ALLOWED_PARAMS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_PARAMS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::LongYieldList
  def sniff(); end
  DEFAULT_MAX_ALLOWED_PARAMS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_PARAMS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::ManualDispatch
  def sniff(); end
  MESSAGE = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::MissingSafeMethod
  def sniff(); end
end

class Reek::SmellDetectors::ModuleInitialize
  def sniff(); end
end

class Reek::SmellDetectors::NestedIterators
  def sniff(); end
  DEFAULT_IGNORE_ITERATORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_ALLOWED_NESTING = ::T.let(nil, ::T.untyped)
  IGNORE_ITERATORS_KEY = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_NESTING_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::NestedIterators::Iterator
  def depth(); end

  def depth=(_); end

  def exp(); end

  def exp=(_); end

  def line(); end
end

class Reek::SmellDetectors::NestedIterators::Iterator
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Reek::SmellDetectors::NilCheck
  def sniff(); end
end

module Reek::SmellDetectors::NilCheck::NilCallNodeDetector
  def self.comparison_call?(call); end

  def self.comparison_methods(); end

  def self.detect(node); end

  def self.involves_nil?(call); end

  def self.nil_comparison?(call); end

  def self.nil_query?(call); end
end

module Reek::SmellDetectors::NilCheck::NilWhenNodeDetector
  def self.detect(node); end
end

class Reek::SmellDetectors::RepeatedConditional
  def sniff(); end
  BLOCK_GIVEN_CONDITION = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_IFS = ::T.let(nil, ::T.untyped)
  MAX_IDENTICAL_IFS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::SubclassedFromCoreClass
  def sniff(); end
  CORE_CLASSES = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::TooManyConstants
  def sniff(); end
  DEFAULT_MAX_CONSTANTS = ::T.let(nil, ::T.untyped)
  IGNORED_NODES = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_CONSTANTS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::TooManyInstanceVariables
  def sniff(); end
  DEFAULT_MAX_IVARS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_IVARS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::TooManyMethods
  def sniff(); end
  DEFAULT_MAX_METHODS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_METHODS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::TooManyStatements
  def sniff(); end
  DEFAULT_MAX_STATEMENTS = ::T.let(nil, ::T.untyped)
  MAX_ALLOWED_STATEMENTS_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::UncommunicativeMethodName
  def sniff(); end
  ACCEPT_KEY = ::T.let(nil, ::T.untyped)
  DEFAULT_ACCEPT_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_REJECT_PATTERNS = ::T.let(nil, ::T.untyped)
  REJECT_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::UncommunicativeModuleName
  def sniff(); end
  ACCEPT_KEY = ::T.let(nil, ::T.untyped)
  DEFAULT_ACCEPT_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_REJECT_PATTERNS = ::T.let(nil, ::T.untyped)
  REJECT_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::UncommunicativeParameterName
  def sniff(); end
  ACCEPT_KEY = ::T.let(nil, ::T.untyped)
  DEFAULT_ACCEPT_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_REJECT_PATTERNS = ::T.let(nil, ::T.untyped)
  REJECT_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::UncommunicativeVariableName
  def sniff(); end
  ACCEPT_KEY = ::T.let(nil, ::T.untyped)
  DEFAULT_ACCEPT_SET = ::T.let(nil, ::T.untyped)
  DEFAULT_REJECT_SET = ::T.let(nil, ::T.untyped)
  REJECT_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellDetectors::UnusedParameters
  def sniff(); end
end

class Reek::SmellDetectors::UnusedPrivateMethod
  def sniff(); end
end

class Reek::SmellDetectors::UnusedPrivateMethod::Hit
  def initialize(context); end

  def line(); end

  def name(); end
end

class Reek::SmellDetectors::UtilityFunction
  def sniff(); end
  PUBLIC_METHODS_ONLY_DEFAULT = ::T.let(nil, ::T.untyped)
  PUBLIC_METHODS_ONLY_KEY = ::T.let(nil, ::T.untyped)
end

class Reek::SmellWarning
  def base_message(); end

  def context(); end

  def eql?(other); end

  def explanatory_link(); end

  def identifying_values(); end

  def initialize(smell_type, lines:, message:, source:, context: T.unsafe(nil), parameters: T.unsafe(nil)); end

  def lines(); end

  def message(); end

  def parameters(); end

  def smell_type(); end

  def source(); end

  def to_hash(); end

  def yaml_hash(); end
end

class Reek::Source::SourceCode
  def initialize(source:, origin: T.unsafe(nil), parser: T.unsafe(nil)); end

  def origin(); end

  def syntax_tree(); end
  IO_IDENTIFIER = ::T.let(nil, ::T.untyped)
  STRING_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

class Reek::Source::SourceCode
  def self.default_parser(); end

  def self.from(source, origin: T.unsafe(nil)); end
end

class Reek::TreeDresser
  def dress(sexp, comment_map); end

  def initialize(klass_map: T.unsafe(nil)); end
end

module Reek::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class Refinement
end

class Refinement
end

class Regexp
  ENC_EUC = ::T.let(nil, ::T.untyped)
  ENC_NONE = ::T.let(nil, ::T.untyped)
  ENC_SJIS = ::T.let(nil, ::T.untyped)
  ENC_UTF8 = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def base_length(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::FreeSpace
  def match_length(); end

  def quantify(_token, _text, _min=T.unsafe(nil), _max=T.unsafe(nil), _mode=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Passive
  def implicit=(implicit); end

  def implicit?(); end

  def initialize(*arg); end
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Literal
  def match_length(); end
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end

  def negative?(); end
end

class Regexp::Expression::Quantifier
  def ==(other); end

  def eq(other); end

  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::Subexpression
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil)); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil)); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  CONDITION_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text); end

  def scan(input_object, options: T.unsafe(nil), &block); end
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.parse_prop_map(name); end

  def self.scan(input_object, options: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
  def implements!(_type, _token); end

  def implements?(_type, _token); end
end

class Regexp::Syntax::Base
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def features(); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  NumberRef = ::T.let(nil, ::T.untyped)
  Plain = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V1_9_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  Age_V3_1_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Script_V3_1_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_1_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
  V3_1_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

module Regexp::Syntax
  def self.comparable_version(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(arg); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Reline
  DEFAULT_DIALOG_CONTEXT = ::T.let(nil, ::T.untyped)
  DEFAULT_DIALOG_PROC_AUTOCOMPLETE = ::T.let(nil, ::T.untyped)
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  CAPNAME_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  END_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
  START_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
end

class Reline::Config
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Core
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

class Reline::KeyActor::Base
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

class Reline::LineEditor
  DIALOG_DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  PROMPT_LIST_CACHE_TIMEOUT = ::T.let(nil, ::T.untyped)
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  CSI_REGEXP_INDEX = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  GRAPHEME_CLUSTER_INDEX = ::T.let(nil, ::T.untyped)
  HalfwidthDakutenHandakuten = ::T.let(nil, ::T.untyped)
  MBCharWidthRE = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END_INDEX = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START_INDEX = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  OSC_REGEXP_INDEX = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

module RequireAll
  def autoload_all(*paths); end

  def autoload_rel(*paths); end

  def load_all(*paths); end

  def load_rel(*paths); end

  def require_all(*args); end

  def require_rel(*paths); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

RspecJunitFormatter = RSpecJUnitFormatter

class Ruby20Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_585(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_635(val, _values, result); end

  def _reduce_638(val, _values, result); end

  def _reduce_639(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby21Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_612(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_640(val, _values, result); end

  def _reduce_643(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby22Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_585(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_642(val, _values, result); end

  def _reduce_645(val, _values, result); end

  def _reduce_646(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby23Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_585(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_643(val, _values, result); end

  def _reduce_646(val, _values, result); end

  def _reduce_647(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby24Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_611(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_618(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_647(val, _values, result); end

  def _reduce_648(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby25Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_611(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_618(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_647(val, _values, result); end

  def _reduce_648(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby26Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_243(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_585(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_611(val, _values, result); end

  def _reduce_612(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_618(val, _values, result); end

  def _reduce_619(val, _values, result); end

  def _reduce_620(val, _values, result); end

  def _reduce_646(val, _values, result); end

  def _reduce_649(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_650(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby27Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_243(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_585(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_619(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_621(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_631(val, _values, result); end

  def _reduce_632(val, _values, result); end

  def _reduce_633(val, _values, result); end

  def _reduce_634(val, _values, result); end

  def _reduce_635(val, _values, result); end

  def _reduce_636(val, _values, result); end

  def _reduce_637(val, _values, result); end

  def _reduce_638(val, _values, result); end

  def _reduce_639(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_640(val, _values, result); end

  def _reduce_641(val, _values, result); end

  def _reduce_642(val, _values, result); end

  def _reduce_643(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_645(val, _values, result); end

  def _reduce_646(val, _values, result); end

  def _reduce_647(val, _values, result); end

  def _reduce_648(val, _values, result); end

  def _reduce_649(val, _values, result); end

  def _reduce_650(val, _values, result); end

  def _reduce_651(val, _values, result); end

  def _reduce_652(val, _values, result); end

  def _reduce_653(val, _values, result); end

  def _reduce_654(val, _values, result); end

  def _reduce_655(val, _values, result); end

  def _reduce_657(val, _values, result); end

  def _reduce_658(val, _values, result); end

  def _reduce_659(val, _values, result); end

  def _reduce_660(val, _values, result); end

  def _reduce_661(val, _values, result); end

  def _reduce_662(val, _values, result); end

  def _reduce_663(val, _values, result); end

  def _reduce_664(val, _values, result); end

  def _reduce_665(val, _values, result); end

  def _reduce_666(val, _values, result); end

  def _reduce_667(val, _values, result); end

  def _reduce_668(val, _values, result); end

  def _reduce_669(val, _values, result); end

  def _reduce_670(val, _values, result); end

  def _reduce_671(val, _values, result); end

  def _reduce_672(val, _values, result); end

  def _reduce_673(val, _values, result); end

  def _reduce_674(val, _values, result); end

  def _reduce_675(val, _values, result); end

  def _reduce_676(val, _values, result); end

  def _reduce_677(val, _values, result); end

  def _reduce_678(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_680(val, _values, result); end

  def _reduce_683(val, _values, result); end

  def _reduce_684(val, _values, result); end

  def _reduce_685(val, _values, result); end

  def _reduce_687(val, _values, result); end

  def _reduce_688(val, _values, result); end

  def _reduce_689(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_690(val, _values, result); end

  def _reduce_692(val, _values, result); end

  def _reduce_694(val, _values, result); end

  def _reduce_697(val, _values, result); end

  def _reduce_698(val, _values, result); end

  def _reduce_699(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_700(val, _values, result); end

  def _reduce_701(val, _values, result); end

  def _reduce_702(val, _values, result); end

  def _reduce_703(val, _values, result); end

  def _reduce_704(val, _values, result); end

  def _reduce_705(val, _values, result); end

  def _reduce_708(val, _values, result); end

  def _reduce_709(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_712(val, _values, result); end

  def _reduce_713(val, _values, result); end

  def _reduce_714(val, _values, result); end

  def _reduce_716(val, _values, result); end

  def _reduce_717(val, _values, result); end

  def _reduce_718(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_721(val, _values, result); end

  def _reduce_722(val, _values, result); end

  def _reduce_723(val, _values, result); end

  def _reduce_724(val, _values, result); end

  def _reduce_725(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_752(val, _values, result); end

  def _reduce_755(val, _values, result); end

  def _reduce_756(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby30Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_243(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_280(val, _values, result); end

  def _reduce_281(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_586(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_605(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_611(val, _values, result); end

  def _reduce_612(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_618(val, _values, result); end

  def _reduce_619(val, _values, result); end

  def _reduce_620(val, _values, result); end

  def _reduce_621(val, _values, result); end

  def _reduce_622(val, _values, result); end

  def _reduce_626(val, _values, result); end

  def _reduce_627(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_632(val, _values, result); end

  def _reduce_634(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_645(val, _values, result); end

  def _reduce_646(val, _values, result); end

  def _reduce_647(val, _values, result); end

  def _reduce_648(val, _values, result); end

  def _reduce_649(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_650(val, _values, result); end

  def _reduce_651(val, _values, result); end

  def _reduce_652(val, _values, result); end

  def _reduce_653(val, _values, result); end

  def _reduce_654(val, _values, result); end

  def _reduce_655(val, _values, result); end

  def _reduce_656(val, _values, result); end

  def _reduce_657(val, _values, result); end

  def _reduce_658(val, _values, result); end

  def _reduce_659(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_661(val, _values, result); end

  def _reduce_662(val, _values, result); end

  def _reduce_663(val, _values, result); end

  def _reduce_664(val, _values, result); end

  def _reduce_666(val, _values, result); end

  def _reduce_667(val, _values, result); end

  def _reduce_668(val, _values, result); end

  def _reduce_669(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_670(val, _values, result); end

  def _reduce_672(val, _values, result); end

  def _reduce_673(val, _values, result); end

  def _reduce_674(val, _values, result); end

  def _reduce_675(val, _values, result); end

  def _reduce_676(val, _values, result); end

  def _reduce_677(val, _values, result); end

  def _reduce_678(val, _values, result); end

  def _reduce_679(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_680(val, _values, result); end

  def _reduce_681(val, _values, result); end

  def _reduce_682(val, _values, result); end

  def _reduce_683(val, _values, result); end

  def _reduce_684(val, _values, result); end

  def _reduce_685(val, _values, result); end

  def _reduce_686(val, _values, result); end

  def _reduce_687(val, _values, result); end

  def _reduce_688(val, _values, result); end

  def _reduce_689(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_690(val, _values, result); end

  def _reduce_691(val, _values, result); end

  def _reduce_692(val, _values, result); end

  def _reduce_693(val, _values, result); end

  def _reduce_695(val, _values, result); end

  def _reduce_698(val, _values, result); end

  def _reduce_699(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_700(val, _values, result); end

  def _reduce_702(val, _values, result); end

  def _reduce_703(val, _values, result); end

  def _reduce_704(val, _values, result); end

  def _reduce_705(val, _values, result); end

  def _reduce_707(val, _values, result); end

  def _reduce_709(val, _values, result); end

  def _reduce_712(val, _values, result); end

  def _reduce_713(val, _values, result); end

  def _reduce_714(val, _values, result); end

  def _reduce_715(val, _values, result); end

  def _reduce_716(val, _values, result); end

  def _reduce_717(val, _values, result); end

  def _reduce_718(val, _values, result); end

  def _reduce_719(val, _values, result); end

  def _reduce_720(val, _values, result); end

  def _reduce_723(val, _values, result); end

  def _reduce_724(val, _values, result); end

  def _reduce_727(val, _values, result); end

  def _reduce_728(val, _values, result); end

  def _reduce_729(val, _values, result); end

  def _reduce_730(val, _values, result); end

  def _reduce_732(val, _values, result); end

  def _reduce_733(val, _values, result); end

  def _reduce_734(val, _values, result); end

  def _reduce_737(val, _values, result); end

  def _reduce_738(val, _values, result); end

  def _reduce_739(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_740(val, _values, result); end

  def _reduce_741(val, _values, result); end

  def _reduce_742(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_764(val, _values, result); end

  def _reduce_765(val, _values, result); end

  def _reduce_769(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_772(val, _values, result); end

  def _reduce_773(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Ruby31Parser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_119(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_145(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_239(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_240(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_243(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_274(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_278(val, _values, result); end

  def _reduce_279(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_338(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_344(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_435(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_437(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_579(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_580(val, _values, result); end

  def _reduce_581(val, _values, result); end

  def _reduce_582(val, _values, result); end

  def _reduce_583(val, _values, result); end

  def _reduce_584(val, _values, result); end

  def _reduce_587(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_593(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_601(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_607(val, _values, result); end

  def _reduce_608(val, _values, result); end

  def _reduce_609(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_610(val, _values, result); end

  def _reduce_611(val, _values, result); end

  def _reduce_612(val, _values, result); end

  def _reduce_613(val, _values, result); end

  def _reduce_614(val, _values, result); end

  def _reduce_615(val, _values, result); end

  def _reduce_616(val, _values, result); end

  def _reduce_617(val, _values, result); end

  def _reduce_618(val, _values, result); end

  def _reduce_619(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_620(val, _values, result); end

  def _reduce_621(val, _values, result); end

  def _reduce_622(val, _values, result); end

  def _reduce_623(val, _values, result); end

  def _reduce_624(val, _values, result); end

  def _reduce_625(val, _values, result); end

  def _reduce_626(val, _values, result); end

  def _reduce_627(val, _values, result); end

  def _reduce_628(val, _values, result); end

  def _reduce_629(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_630(val, _values, result); end

  def _reduce_631(val, _values, result); end

  def _reduce_632(val, _values, result); end

  def _reduce_636(val, _values, result); end

  def _reduce_637(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_642(val, _values, result); end

  def _reduce_644(val, _values, result); end

  def _reduce_649(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_650(val, _values, result); end

  def _reduce_651(val, _values, result); end

  def _reduce_657(val, _values, result); end

  def _reduce_658(val, _values, result); end

  def _reduce_659(val, _values, result); end

  def _reduce_660(val, _values, result); end

  def _reduce_661(val, _values, result); end

  def _reduce_662(val, _values, result); end

  def _reduce_663(val, _values, result); end

  def _reduce_664(val, _values, result); end

  def _reduce_665(val, _values, result); end

  def _reduce_666(val, _values, result); end

  def _reduce_667(val, _values, result); end

  def _reduce_668(val, _values, result); end

  def _reduce_669(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_670(val, _values, result); end

  def _reduce_671(val, _values, result); end

  def _reduce_672(val, _values, result); end

  def _reduce_674(val, _values, result); end

  def _reduce_675(val, _values, result); end

  def _reduce_677(val, _values, result); end

  def _reduce_678(val, _values, result); end

  def _reduce_679(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_680(val, _values, result); end

  def _reduce_681(val, _values, result); end

  def _reduce_684(val, _values, result); end

  def _reduce_685(val, _values, result); end

  def _reduce_686(val, _values, result); end

  def _reduce_687(val, _values, result); end

  def _reduce_688(val, _values, result); end

  def _reduce_689(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_690(val, _values, result); end

  def _reduce_691(val, _values, result); end

  def _reduce_692(val, _values, result); end

  def _reduce_693(val, _values, result); end

  def _reduce_694(val, _values, result); end

  def _reduce_695(val, _values, result); end

  def _reduce_696(val, _values, result); end

  def _reduce_697(val, _values, result); end

  def _reduce_698(val, _values, result); end

  def _reduce_699(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_700(val, _values, result); end

  def _reduce_701(val, _values, result); end

  def _reduce_702(val, _values, result); end

  def _reduce_703(val, _values, result); end

  def _reduce_704(val, _values, result); end

  def _reduce_705(val, _values, result); end

  def _reduce_707(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_710(val, _values, result); end

  def _reduce_711(val, _values, result); end

  def _reduce_712(val, _values, result); end

  def _reduce_714(val, _values, result); end

  def _reduce_715(val, _values, result); end

  def _reduce_716(val, _values, result); end

  def _reduce_717(val, _values, result); end

  def _reduce_719(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_721(val, _values, result); end

  def _reduce_724(val, _values, result); end

  def _reduce_725(val, _values, result); end

  def _reduce_726(val, _values, result); end

  def _reduce_727(val, _values, result); end

  def _reduce_728(val, _values, result); end

  def _reduce_729(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_730(val, _values, result); end

  def _reduce_731(val, _values, result); end

  def _reduce_732(val, _values, result); end

  def _reduce_735(val, _values, result); end

  def _reduce_736(val, _values, result); end

  def _reduce_739(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_740(val, _values, result); end

  def _reduce_741(val, _values, result); end

  def _reduce_742(val, _values, result); end

  def _reduce_744(val, _values, result); end

  def _reduce_745(val, _values, result); end

  def _reduce_746(val, _values, result); end

  def _reduce_749(val, _values, result); end

  def _reduce_750(val, _values, result); end

  def _reduce_751(val, _values, result); end

  def _reduce_752(val, _values, result); end

  def _reduce_753(val, _values, result); end

  def _reduce_754(val, _values, result); end

  def _reduce_776(val, _values, result); end

  def _reduce_777(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_781(val, _values, result); end

  def _reduce_784(val, _values, result); end

  def _reduce_785(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RubyLex
  def check_code_block(code, tokens=T.unsafe(nil)); end

  def check_corresponding_token_depth(lines, line_index); end

  def check_newline_depth_difference(); end

  def check_state(code, tokens=T.unsafe(nil), context: T.unsafe(nil)); end

  def check_string_literal(tokens); end

  def check_termination_in_prev_line(code, context: T.unsafe(nil)); end

  def each_top_level_statement(); end

  def find_prev_spaces(line_index); end

  def initialize_input(); end

  def is_method_calling?(tokens, index); end

  def is_the_in_correspond_to_a_for(tokens, index); end

  def lex(); end

  def process_continue(tokens=T.unsafe(nil)); end

  def process_literal_type(tokens=T.unsafe(nil)); end

  def process_nesting_level(tokens=T.unsafe(nil)); end

  def prompt(); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), context: T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def take_corresponding_syntax_to_kw_do(tokens, index); end
  ERROR_TOKENS = ::T.let(nil, ::T.untyped)
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
  def self.compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

  def self.ripper_lex_without_warning(code, context: T.unsafe(nil)); end
end

class RubyLexer
  include ::RubyLexer::SSStackish
  def action(); end

  def arg_ambiguous(); end

  def arg_state(); end

  def brace_nest(); end

  def brace_nest=(brace_nest); end

  def cmd_state(); end

  def cmd_state=(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def column(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def debug(n); end

  def eat_whitespace(); end

  def expr_dot?(); end

  def expr_fname?(); end

  def expr_result(token, text); end

  def filename(); end

  def filename=(filename); end

  def heredoc(here); end

  def heredoc_identifier(); end

  def heredoc_restore(); end

  def ignore_body_comments(); end

  def in_fname?(); end

  def initialize(_=T.unsafe(nil)); end

  def int_with_base(base); end

  def is_after_operator?(); end

  def is_arg?(); end

  def is_beg?(); end

  def is_end?(); end

  def is_label_possible?(); end

  def is_label_suffix?(); end

  def is_local_id(id); end

  def is_space_arg?(c=T.unsafe(nil)); end

  def lambda_beginning?(); end

  def last_state(); end

  def last_state=(last_state); end

  def lex_state(); end

  def lex_state=(lex_state); end

  def lex_strterm(); end

  def lex_strterm=(lex_strterm); end

  def lineno(); end

  def lineno=(lineno); end

  def location(); end

  def lpar_beg(); end

  def lpar_beg=(lpar_beg); end

  def lvar_defined?(id); end

  def matches(); end

  def newtok(); end

  def next_token(); end

  def nextc(); end

  def not_end?(); end

  def old_lineno(); end

  def old_lineno=(old_lineno); end

  def old_pos(); end

  def old_pos=(old_pos); end

  def old_ss(); end

  def old_ss=(old_ss); end

  def paren_nest(); end

  def paren_nest=(paren_nest); end

  def parse(str); end

  def parse_file(path); end

  def parse_string(quote); end

  def parser(); end

  def parser=(parser); end

  def possibly_escape_string(text, check); end

  def process_amper(text); end

  def process_backref(text); end

  def process_begin(text); end

  def process_brace_close(text); end

  def process_brace_open(text); end

  def process_colon1(text); end

  def process_colon2(text); end

  def process_dots(text); end

  def process_float(text); end

  def process_gvar(text); end

  def process_gvar_oddity(text); end

  def process_ivar(text); end

  def process_label(text); end

  def process_label_or_string(text); end

  def process_lchevron(text); end

  def process_newline_or_comment(text); end

  def process_nthref(text); end

  def process_paren(text); end

  def process_percent(text); end

  def process_percent_quote(); end

  def process_plus_minus(text); end

  def process_questionmark(text); end

  def process_simple_string(text); end

  def process_slash(text); end

  def process_square_bracket(text); end

  def process_string_or_heredoc(); end

  def process_symbol(text); end

  def process_token(text); end

  def process_token_keyword(keyword); end

  def process_underscore(text); end

  def rb_compile_error(msg); end

  def read_escape(flags=T.unsafe(nil)); end

  def regexp_cache(); end

  def regx_options(); end

  def reset(); end

  def result(new_state, token, text, line=T.unsafe(nil)); end

  def ruby22_label?(); end

  def ruby22plus?(); end

  def ruby23plus?(); end

  def ruby24minus?(); end

  def ruby27plus?(); end

  def scan_variable_name(); end

  def space_seen(); end

  def space_seen=(space_seen); end

  def space_vs_beginning(space_type, beg_type, fallback); end

  def ss(); end

  def start_of_current_line_pos(); end

  def start_of_current_line_pos=(start_of_current_line_pos); end

  def state(); end

  def state=(state); end

  def string(type, beg, nnd=T.unsafe(nil)); end

  def string_buffer(); end

  def string_buffer=(string_buffer); end

  def string_nest(); end

  def string_nest=(string_nest); end

  def string_term(func); end

  def tokadd(c); end

  def tokadd_escape(); end

  def tokadd_string(func, term, paren); end

  def tokadd_utf8(term, func, regexp_literal); end

  def token(); end

  def token=(token); end

  def unescape(s); end

  def warning(s); end

  def was_label?(); end
  BTOKENS = ::T.let(nil, ::T.untyped)
  EOF = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
  ESCAPES = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT_BAD = ::T.let(nil, ::T.untyped)
  HAS_ENC = ::T.let(nil, ::T.untyped)
  IDENT_CHAR = ::T.let(nil, ::T.untyped)
  INT_BIN = ::T.let(nil, ::T.untyped)
  INT_DEC = ::T.let(nil, ::T.untyped)
  INT_DEC2 = ::T.let(nil, ::T.untyped)
  INT_HEX = ::T.let(nil, ::T.untyped)
  INT_OCT = ::T.let(nil, ::T.untyped)
  INT_OCT_BAD = ::T.let(nil, ::T.untyped)
  NUM_BAD = ::T.let(nil, ::T.untyped)
  PERCENT_END = ::T.let(nil, ::T.untyped)
  SIMPLE_RE_META = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING = ::T.let(nil, ::T.untyped)
  SSTRING = ::T.let(nil, ::T.untyped)
  TOKENS = ::T.let(nil, ::T.untyped)
end

module RubyLexer::SSStackish
  def lineno_pop(); end

  def lineno_push(new_lineno); end

  def ss=(o); end

  def ss_pop(); end

  def ss_push(new_ss); end
end

module RubyLexer::SSWrapper
  def beginning_of_line?(); end

  def bol?(); end

  def check(re); end

  def end_of_stream?(); end

  def eos?(); end

  def getch(); end

  def in_heredoc?(); end

  def match(); end

  def matched(); end

  def maybe_pop_stack(); end

  def pos(); end

  def pos=(n); end

  def rest(); end

  def scan(re); end

  def scanner_class(); end

  def ss_string(); end

  def ss_string=(s); end

  def string=(s); end

  def unscan(); end
end

class RubyLexer::State
  def ==(o); end

  def =~(v); end

  def initialize(o, names); end

  def n(); end

  def n=(n); end

  def names(); end

  def names=(names); end

  def |(v); end
end

module RubyLexer::State::Values
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LAB = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_LIT = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_NUM = ::T.let(nil, ::T.untyped)
  EXPR_PAD = ::T.let(nil, ::T.untyped)
  EXPR_PAR = ::T.let(nil, ::T.untyped)
  STR_DQUOTE = ::T.let(nil, ::T.untyped)
  STR_DSYM = ::T.let(nil, ::T.untyped)
  STR_DWORD = ::T.let(nil, ::T.untyped)
  STR_FUNC_BORING = ::T.let(nil, ::T.untyped)
  STR_FUNC_DEDENT = ::T.let(nil, ::T.untyped)
  STR_FUNC_ESCAPE = ::T.let(nil, ::T.untyped)
  STR_FUNC_EXPAND = ::T.let(nil, ::T.untyped)
  STR_FUNC_INDENT = ::T.let(nil, ::T.untyped)
  STR_FUNC_LABEL = ::T.let(nil, ::T.untyped)
  STR_FUNC_LIST = ::T.let(nil, ::T.untyped)
  STR_FUNC_QWORDS = ::T.let(nil, ::T.untyped)
  STR_FUNC_REGEXP = ::T.let(nil, ::T.untyped)
  STR_FUNC_SYMBOL = ::T.let(nil, ::T.untyped)
  STR_FUNC_TERM = ::T.let(nil, ::T.untyped)
  STR_LABEL = ::T.let(nil, ::T.untyped)
  STR_REGEXP = ::T.let(nil, ::T.untyped)
  STR_SQUOTE = ::T.let(nil, ::T.untyped)
  STR_SSYM = ::T.let(nil, ::T.untyped)
  STR_SWORD = ::T.let(nil, ::T.untyped)
  STR_XQUOTE = ::T.let(nil, ::T.untyped)
end

class RubyParser
  def current(); end

  def current=(current); end

  def parse(s, f=T.unsafe(nil), t=T.unsafe(nil)); end

  def process(s, f=T.unsafe(nil), t=T.unsafe(nil)); end

  def reset(); end
  VERSIONS = ::T.let(nil, ::T.untyped)
end

class RubyParser::Parser
  def self.inherited(x); end

  def self.version(); end

  def self.version=(v); end
end

class RubyParser
  def self.for_current_ruby(); end

  def self.latest(); end
end

module RubyParserStuff
  def arg_concat(node1, node2); end

  def argl(x); end

  def args(args); end

  def array_pat_concat(lhs, rhs); end

  def array_to_hash(array); end

  def aryset(receiver, index); end

  def assignable(lhs, value=T.unsafe(nil)); end

  def attrset_id?(id); end

  def backref_assign_error(ref); end

  def block_append(head, tail); end

  def block_dup_check(call_or_args, block); end

  def block_var(*args); end

  def call_args(args); end

  def canonicalize_conditions(); end

  def canonicalize_conditions=(canonicalize_conditions); end

  def clean_mlhs(sexp); end

  def comments(); end

  def cond(node); end

  def debug(n); end

  def debug20(n, v=T.unsafe(nil), r=T.unsafe(nil)); end

  def dedent(sexp); end

  def dedent_size(sexp); end

  def dedent_string(string, width); end

  def end_args(args); end

  def endless_method_name(defn_or_defs); end

  def env(); end

  def file(); end

  def file=(file); end

  def gettable(id); end

  def hack_encoding(str, extra=T.unsafe(nil)); end

  def handle_encoding(str); end

  def in_def(); end

  def in_def=(in_def); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def in_single(); end

  def in_single=(in_single); end

  def initialize(options=T.unsafe(nil)); end

  def invert_block_call(val); end

  def inverted?(val); end

  def last_token_type(); end

  def last_token_type=(last_token_type); end

  def lexer(); end

  def lexer=(lexer); end

  def list_append(list, item); end

  def list_prepend(item, list); end

  def literal_concat(head, tail); end

  def local_pop(in_def); end

  def logical_op(type, left, right); end

  def new_aref(val); end

  def new_arg(val); end

  def new_array_pattern(const, pre_arg, arypat, loc); end

  def new_array_pattern_tail(pre_args, has_rest, rest_arg, post_args); end

  def new_assign(lhs, rhs); end

  def new_attrasgn(recv, meth, call_op=T.unsafe(nil)); end

  def new_begin(val); end

  def new_body(val); end

  def new_brace_body(args, body, lineno); end

  def new_call(recv, meth, args=T.unsafe(nil), call_op=T.unsafe(nil)); end

  def new_case(expr, body, line); end

  def new_class(val); end

  def new_compstmt(val); end

  def new_const_op_asgn(val); end

  def new_defn(val); end

  def new_defs(val); end

  def new_do_body(args, body, lineno); end

  def new_endless_defn(val); end

  def new_endless_defs(val); end

  def new_find_pattern(const, pat); end

  def new_find_pattern_tail(lhs, mid, rhs); end

  def new_for(expr, var, body); end

  def new_hash(val); end

  def new_hash_pattern(const, hash_pat, loc); end

  def new_hash_pattern_tail(kw_args, kw_rest_arg, line); end

  def new_if(c, t, f); end

  def new_in(pat, body, cases, line); end

  def new_iter(call, args, body); end

  def new_masgn(lhs, rhs, wrap=T.unsafe(nil)); end

  def new_masgn_arg(rhs, wrap=T.unsafe(nil)); end

  def new_match(lhs, rhs); end

  def new_module(val); end

  def new_op_asgn(val); end

  def new_op_asgn1(val); end

  def new_op_asgn2(val); end

  def new_qsym_list(); end

  def new_qsym_list_entry(val); end

  def new_qword_list(); end

  def new_qword_list_entry(val); end

  def new_regexp(val); end

  def new_resbody(cond, body); end

  def new_rescue(body, resbody); end

  def new_sclass(val); end

  def new_string(val); end

  def new_super(args); end

  def new_symbol(val); end

  def new_symbol_list(); end

  def new_symbol_list_entry(val); end

  def new_undef(n, m=T.unsafe(nil)); end

  def new_until(block, expr, pre); end

  def new_until_or_while(type, block, expr, pre); end

  def new_when(cond, body); end

  def new_while(block, expr, pre); end

  def new_word_list(); end

  def new_word_list_entry(val); end

  def new_xstring(val); end

  def new_yield(args=T.unsafe(nil)); end

  def next_token(); end

  def on_error(et, ev, values); end

  def parse(str, file=T.unsafe(nil), time=T.unsafe(nil)); end

  def pop_pktbl(); end

  def pop_pvtbl(); end

  def prev_value_to_lineno(v); end

  def process(str, file=T.unsafe(nil), time=T.unsafe(nil)); end

  def push_pktbl(); end

  def push_pvtbl(); end

  def remove_begin(node); end

  def remove_whitespace_width(line, remove_width=T.unsafe(nil)); end

  def reset(); end

  def ret_args(node); end

  def s(*args); end

  def syntax_error(msg); end

  def value_expr(node); end

  def void_stmts(node); end

  def warning(s); end

  def whitespace_width(line, remove_width=T.unsafe(nil)); end

  def wrap(type, node); end

  def yyerror(msg); end
  ARG_TYPES = ::T.let(nil, ::T.untyped)
  ENCODING_ORDER = ::T.let(nil, ::T.untyped)
  JUMP_TYPE = ::T.let(nil, ::T.untyped)
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RubyParserStuff::Environment
  def [](k); end

  def []=(k, v); end

  def all(); end

  def current(); end

  def dyn(); end

  def env(); end

  def extend(dyn=T.unsafe(nil)); end

  def initialize(dyn=T.unsafe(nil)); end

  def reset(); end

  def unextend(); end
end

class RubyParserStuff::Keyword
  WORDLIST = ::T.let(nil, ::T.untyped)
end

class RubyParserStuff::Keyword::KWtable
  def id0(); end

  def id0=(id0); end

  def id1(); end

  def id1=(id1); end

  def initialize(name, id=T.unsafe(nil), state=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def state(); end

  def state=(state); end
end

class RubyParserStuff::Keyword
  def self.keyword(str); end
end

class RubyParserStuff::StackState
  def debug(); end

  def debug=(debug); end

  def initialize(name, debug=T.unsafe(nil)); end

  def is_in_state(); end

  def lexpop(); end

  def log(action); end

  def name(); end

  def pop(); end

  def push(val); end

  def reset(); end

  def restore(oldstate); end

  def stack(); end

  def store(base=T.unsafe(nil)); end
end

module RubyParserStuff
  def self.deprecate(old, new); end
end

class RubyVM::AbstractSyntaxTree::Node
  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end
end

class RubyVM::DebugInspector
  VERSION = ::T.let(nil, ::T.untyped)
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*arg); end

  def self.resume(); end
end

module RubyVM::YJIT
end

module RubyVM::YJIT
  def self.enabled?(); end

  def self.reset_stats!(); end

  def self.runtime_stats(); end

  def self.simulate_oom!(); end

  def self.stats_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

module Rugged
  SORT_DATE = ::T.let(nil, ::T.untyped)
  SORT_NONE = ::T.let(nil, ::T.untyped)
  SORT_REVERSE = ::T.let(nil, ::T.untyped)
  SORT_TOPO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Rugged::Backend
end

class Rugged::Backend
end

class Rugged::Blame
  include ::Enumerable
  def [](arg); end

  def count(); end

  def each(&blk); end

  def for_line(arg); end

  def size(); end
end

class Rugged::Blame
  def self.new(*arg); end
end

class Rugged::Blob
  def binary?(); end

  def content(*arg); end

  def diff(*arg); end

  def hashsig(options=T.unsafe(nil)); end

  def loc(); end

  def similarity(other); end

  def size(); end

  def sloc(); end

  def text(*arg); end
end

class Rugged::Blob::HashSignature
  WHITESPACE_DEFAULT = ::T.let(nil, ::T.untyped)
  WHITESPACE_IGNORE = ::T.let(nil, ::T.untyped)
  WHITESPACE_SMART = ::T.let(nil, ::T.untyped)
end

class Rugged::Blob::HashSignature
  def self.compare(arg, arg1); end

  def self.new(*arg); end
end

class Rugged::Blob
  def self.from_buffer(arg, arg1); end

  def self.from_disk(arg, arg1); end

  def self.from_io(*arg); end

  def self.from_workdir(arg, arg1); end

  def self.merge_files(*arg); end

  def self.to_buffer(*arg); end
end

class Rugged::Branch
  def ==(other); end

  def head?(); end

  def remote(); end

  def remote_name(); end

  def upstream(); end

  def upstream=(upstream); end
end

class Rugged::BranchCollection
  include ::Enumerable
  def [](arg); end

  def create(*arg); end

  def delete(arg); end

  def each(*arg, &blk); end

  def each_name(*arg); end

  def exist?(arg); end

  def exists?(arg); end

  def initialize(arg); end

  def move(*arg); end

  def rename(*arg); end
end

class Rugged::BranchCollection
end

class Rugged::CallbackError
end

class Rugged::CallbackError
end

class Rugged::CheckoutError
end

class Rugged::CheckoutError
end

class Rugged::CherrypickError
end

class Rugged::CherrypickError
end

class Rugged::Commit
  def amend(arg); end

  def author(); end

  def committer(); end

  def diff(*args); end

  def diff_workdir(options=T.unsafe(nil)); end

  def epoch_time(); end

  def header(); end

  def header_field(arg); end

  def header_field?(field); end

  def message(); end

  def modify(new_args, update_ref=T.unsafe(nil)); end

  def parent_ids(); end

  def parent_oids(); end

  def parents(); end

  def summary(); end

  def time(); end

  def to_hash(); end

  def to_mbox(*arg); end

  def trailers(); end

  def tree(); end

  def tree_id(); end

  def tree_oid(); end
end

class Rugged::Commit
  def self.create(arg, arg1); end

  def self.create_to_s(arg, arg1); end

  def self.create_with_signature(*arg); end

  def self.extract_signature(*arg); end

  def self.prettify_message(msg, strip_comments=T.unsafe(nil)); end
end

class Rugged::Config
  def [](arg); end

  def []=(arg, arg1); end

  def delete(arg); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def get(arg); end

  def get_all(arg); end

  def snapshot(); end

  def store(arg, arg1); end

  def to_hash(); end

  def transaction(); end
end

class Rugged::Config
  def self.global(); end

  def self.new(arg); end

  def self.open_global(); end
end

class Rugged::ConfigError
end

class Rugged::ConfigError
end

class Rugged::Credentials::Default
  def call(url, username_from_url, allowed_types); end
end

class Rugged::Credentials::SshKey
  def call(url, username_from_url, allowed_types); end

  def initialize(options); end
end

class Rugged::Credentials::SshKeyFromAgent
  def call(url, username_from_url, allowed_types); end

  def initialize(options); end
end

class Rugged::Credentials::UserPassword
  def call(url, username_from_url, allowed_types); end

  def initialize(options); end
end

class Rugged::DescribeError
end

class Rugged::DescribeError
end

class Rugged::Diff
  def deltas(); end

  def each(&blk); end

  def each_delta(); end

  def each_line(*arg); end

  def each_patch(); end

  def find_similar!(*arg); end

  def merge!(arg); end

  def owner(); end

  def patch(*arg); end

  def patches(); end

  def size(); end

  def sorted_icase?(); end

  def stat(); end

  def write_patch(*arg); end
end

class Rugged::Diff::Delta
  def added?(); end

  def binary(); end

  def binary?(); end

  def copied?(); end

  def deleted?(); end

  def diff(); end

  def ignored?(); end

  def modified?(); end

  def new_file(); end

  def old_file(); end

  def owner(); end

  def renamed?(); end

  def similarity(); end

  def status(); end

  def status_char(); end

  def typechange?(); end

  def untracked?(); end
end

class Rugged::Diff::Hunk
  include ::Enumerable
  def count(); end

  def delta(); end

  def each(&blk); end

  def each_line(); end

  def header(); end

  def hunk_index(); end

  def line_count(); end

  def lines(); end

  def new_lines(); end

  def new_start(); end

  def old_lines(); end

  def old_start(); end

  def size(); end
end

class Rugged::Diff::Line
  def addition?(); end

  def binary?(); end

  def content(); end

  def content_offset(); end

  def context?(); end

  def deletion?(); end

  def eof_newline_added?(); end

  def eof_newline_removed?(); end

  def eof_no_newline?(); end

  def file_header?(); end

  def hunk_header?(); end

  def line_origin(); end

  def new_lineno(); end

  def old_lineno(); end
end

class Rugged::Error
end

class Rugged::Error
end

class Rugged::FetchheadError
end

class Rugged::FetchheadError
end

class Rugged::FilesystemError
end

class Rugged::FilesystemError
end

class Rugged::FilterError
end

class Rugged::FilterError
end

class Rugged::HTTPError
end

class Rugged::HTTPError
end

class Rugged::Index
  def <<(arg); end

  def [](*arg); end

  def add(arg); end

  def add_all(*arg); end

  def clear(); end

  def conflict_add(arg); end

  def conflict_cleanup(); end

  def conflict_get(arg); end

  def conflict_remove(arg); end

  def conflicts(); end

  def conflicts?(); end

  def count(); end

  def diff(*args); end

  def each(&blk); end

  def get(*arg); end

  def merge_file(*arg); end

  def read_tree(arg); end

  def reload(); end

  def remove(*arg); end

  def remove_all(*arg); end

  def remove_dir(*arg); end

  def update(arg); end

  def update_all(*arg); end

  def write(); end

  def write_tree(*arg); end
  ENTRY_FLAGS_STAGE = ::T.let(nil, ::T.untyped)
  ENTRY_FLAGS_STAGE_SHIFT = ::T.let(nil, ::T.untyped)
  ENTRY_FLAGS_VALID = ::T.let(nil, ::T.untyped)
end

class Rugged::Index
  def self.new(*arg); end
end

class Rugged::IndexError
end

class Rugged::IndexError
end

class Rugged::IndexerError
end

class Rugged::IndexerError
end

class Rugged::InvalidError
end

class Rugged::InvalidError
end

class Rugged::MergeError
end

class Rugged::MergeError
end

class Rugged::NetworkError
end

class Rugged::NetworkError
end

class Rugged::NoMemError
end

class Rugged::NoMemError
end

class Rugged::OSError
end

class Rugged::OSError
end

class Rugged::Object
  def create_note(arg); end

  def notes(*arg); end

  def oid(); end

  def read_raw(); end

  def remove_note(*arg); end

  def type(); end
end

class Rugged::Object
  def self.lookup(arg, arg1); end

  def self.new(arg, arg1); end

  def self.rev_parse(arg, arg1); end

  def self.rev_parse_oid(arg, arg1); end
end

class Rugged::ObjectError
end

class Rugged::ObjectError
end

class Rugged::OdbError
end

class Rugged::OdbError
end

class Rugged::OdbObject
  def data(); end

  def len(); end

  def oid(); end

  def type(); end
end

class Rugged::OdbObject
end

class Rugged::Patch
  def additions(); end

  def bytesize(*arg); end

  def changes(); end

  def count(); end

  def deletions(); end

  def delta(); end

  def diff(); end

  def each(&blk); end

  def each_hunk(); end

  def header(); end

  def hunk_count(); end

  def hunks(); end

  def lines(*arg); end

  def owner(); end

  def owner=(owner); end

  def size(); end

  def stat(); end
end

class Rugged::Patch
  def self.from_strings(*arg); end
end

class Rugged::PathError
end

class Rugged::PathError
end

class Rugged::Rebase
  def abort(); end

  def commit(*arg); end

  def finish(arg); end

  def inmemory_index(); end

  def next(); end
end

class Rugged::Rebase
  def self.new(*arg); end
end

class Rugged::RebaseError
end

class Rugged::RebaseError
end

class Rugged::Reference
  def branch?(); end

  def canonical_name(); end

  def log?(); end

  def name(); end

  def peel(); end

  def remote?(); end

  def resolve(); end

  def tag?(); end

  def target(); end

  def target_id(); end

  def type(); end
end

class Rugged::Reference
  def self.valid_name?(arg); end
end

class Rugged::ReferenceCollection
  include ::Enumerable
  def [](arg); end

  def create(*arg); end

  def delete(arg); end

  def each(*arg, &blk); end

  def each_name(*arg); end

  def exist?(arg); end

  def exists?(arg); end

  def initialize(arg); end

  def move(*arg); end

  def rename(*arg); end

  def update(*arg); end
end

class Rugged::ReferenceCollection
end

class Rugged::ReferenceError
end

class Rugged::ReferenceError
end

class Rugged::RegexError
end

class Rugged::RegexError
end

class Rugged::Remote
  def check_connection(*arg); end

  def fetch(*arg); end

  def fetch_refspecs(); end

  def ls(*arg); end

  def name(); end

  def push(*arg); end

  def push_refspecs(); end

  def push_url(); end

  def push_url=(push_url); end

  def url(); end
end

class Rugged::RemoteCollection
  include ::Enumerable
  def [](arg); end

  def add_fetch_refspec(arg, arg1); end

  def add_push_refspec(arg, arg1); end

  def create(arg, arg1); end

  def create_anonymous(arg); end

  def delete(arg); end

  def each(&blk); end

  def each_name(); end

  def initialize(arg); end

  def rename(arg, arg1); end

  def set_push_url(arg, arg1); end

  def set_url(arg, arg1); end
end

class Rugged::RemoteCollection
end

class Rugged::Repository
  def ahead_behind(arg, arg1); end

  def apply(*arg); end

  def attributes(path, options=T.unsafe(nil)); end

  def bare?(); end

  def blob_at(revision, path); end

  def branches(); end

  def checkout(target, options=T.unsafe(nil)); end

  def checkout_head(*arg); end

  def checkout_index(*arg); end

  def checkout_tree(*arg); end

  def cherrypick(*arg); end

  def cherrypick_commit(*arg); end

  def close(); end

  def config(); end

  def config=(config); end

  def create_branch(name, sha_or_ref=T.unsafe(nil)); end

  def default_notes_ref(); end

  def default_signature(); end

  def descendant_of?(arg, arg1); end

  def diff(left, right, opts=T.unsafe(nil)); end

  def diff_from_buffer(arg); end

  def diff_workdir(left, opts=T.unsafe(nil)); end

  def each_id(); end

  def each_note(*arg); end

  def empty?(); end

  def exists?(arg); end

  def expand_oids(*arg); end

  def fetch(remote_or_url, *args, **kwargs); end

  def fetch_attributes(*arg); end

  def head(); end

  def head=(head); end

  def head_detached?(); end

  def head_unborn?(); end

  def ident(); end

  def ident=(ident); end

  def include?(arg); end

  def index(); end

  def index=(index); end

  def last_commit(); end

  def lookup(oid); end

  def merge_analysis(*arg); end

  def merge_base(*arg); end

  def merge_bases(*arg); end

  def merge_commits(*arg); end

  def namespace(); end

  def namespace=(namespace); end

  def path(); end

  def path_ignored?(arg); end

  def push(remote_or_url, *args); end

  def read(arg); end

  def read_header(arg); end

  def ref(ref_name); end

  def ref_names(glob=T.unsafe(nil)); end

  def references(); end

  def refs(glob=T.unsafe(nil)); end

  def remotes(); end

  def reset(arg, arg1); end

  def reset_path(*arg); end

  def rev_parse(spec); end

  def rev_parse_oid(spec); end

  def revert_commit(*arg); end

  def shallow?(); end

  def status(file=T.unsafe(nil), &block); end

  def submodules(); end

  def tags(); end

  def walk(from, sorting=T.unsafe(nil), &block); end

  def workdir(); end

  def workdir=(workdir); end

  def write(arg, arg1); end
end

class Rugged::Repository::Attributes
  def [](attribute); end

  def each(&block); end

  def initialize(repository, path, options=T.unsafe(nil)); end

  def to_h(); end
  LOAD_PRIORITIES = ::T.let(nil, ::T.untyped)
end

class Rugged::Repository::Attributes
  def self.parse_opts(opt); end
end

class Rugged::Repository
  def self.bare(*arg); end

  def self.clone_at(*arg); end

  def self.discover(*arg); end

  def self.hash_data(arg, arg1); end

  def self.hash_file(arg, arg1); end

  def self.init_at(*arg); end

  def self.new(*arg); end
end

class Rugged::RepositoryError
end

class Rugged::RepositoryError
end

class Rugged::RevertError
end

class Rugged::RevertError
end

class Rugged::SHA1Error
end

class Rugged::SHA1Error
end

class Rugged::Settings
end

class Rugged::Settings
  def self.[](arg); end

  def self.[]=(arg, arg1); end

  def self.max_cache_size(); end

  def self.used_cache_size(); end
end

class Rugged::SshError
end

class Rugged::SshError
end

class Rugged::SslError
end

class Rugged::SslError
end

class Rugged::StashError
end

class Rugged::StashError
end

class Rugged::Submodule
  def add_to_index(*arg); end

  def added_to_index?(); end

  def added_to_workdir?(); end

  def deleted_from_index?(); end

  def deleted_from_workdir?(); end

  def dirty_workdir?(); end

  def dirty_workdir_index?(); end

  def fetch_recurse_submodules?(); end

  def finalize_add(); end

  def head_oid(); end

  def ignore_rule(); end

  def in_config?(); end

  def in_head?(); end

  def in_index?(); end

  def in_workdir?(); end

  def index_oid(); end

  def init(*arg); end

  def modified_files_in_workdir?(); end

  def modified_in_index?(); end

  def modified_in_workdir?(); end

  def name(); end

  def path(); end

  def reload(); end

  def repository(); end

  def status(); end

  def sync(); end

  def uninitialized?(); end

  def unmodified?(); end

  def untracked_files_in_workdir?(); end

  def update_rule(); end

  def url(); end

  def workdir_oid(); end
end

class Rugged::Submodule
end

class Rugged::SubmoduleCollection
  include ::Enumerable
  def [](arg); end

  def add(url, path, options=T.unsafe(nil)); end

  def each(&blk); end

  def initialize(arg); end

  def setup_add(*arg); end

  def update(arg, arg1); end
end

class Rugged::SubmoduleError
end

class Rugged::SubmoduleError
end

class Rugged::Tag
  def annotated?(); end

  def annotation(); end
  GPG_SIGNATURE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Rugged::Tag::Annotation
  def message(); end

  def modify(new_args, force=T.unsafe(nil)); end

  def name(); end

  def tagger(); end

  def target(); end

  def target_id(); end

  def target_oid(); end

  def target_type(); end

  def to_hash(); end
end

class Rugged::Tag::Annotation
  def self.prettify_message(msg, strip_comments=T.unsafe(nil)); end
end

class Rugged::Tag
  def self.extract_signature(repo, oid, prefix=T.unsafe(nil)); end
end

class Rugged::TagCollection
  include ::Enumerable
  def [](arg); end

  def create(*arg); end

  def create_annotation(arg, arg1, arg2); end

  def delete(arg); end

  def each(*arg, &blk); end

  def each_name(*arg); end

  def initialize(arg); end
end

class Rugged::TagCollection
end

class Rugged::TagError
end

class Rugged::TagError
end

class Rugged::ThreadError
end

class Rugged::ThreadError
end

class Rugged::Tree
  def [](arg); end

  def count(); end

  def count_recursive(*arg); end

  def diff(other=T.unsafe(nil), options=T.unsafe(nil)); end

  def diff_workdir(*arg); end

  def each(&blk); end

  def each_blob(); end

  def each_tree(); end

  def get_entry(arg); end

  def get_entry_by_oid(arg); end

  def length(); end

  def merge(*arg); end

  def owner(); end

  def path(arg); end

  def repo(); end

  def update(arg); end

  def walk(arg); end

  def walk_blobs(mode=T.unsafe(nil)); end

  def walk_trees(mode=T.unsafe(nil)); end
end

class Rugged::Tree::Builder
  def <<(arg); end

  def [](arg); end

  def clear(); end

  def insert(arg); end

  def reject!(); end

  def remove(arg); end

  def write(); end
end

class Rugged::Tree::Builder
  def self.new(*arg); end
end

class Rugged::Tree
  def self.diff(repo, tree, other_tree=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.empty(arg); end
end

class Rugged::TreeError
end

class Rugged::TreeError
end

class Rugged::Walker
  def each(*arg, &blk); end

  def each_oid(*arg); end

  def hide(arg); end

  def push(arg); end

  def push_range(arg); end

  def reset(); end

  def simplify_first_parent(); end

  def sorting(arg); end

  def walk(*arg); end
end

class Rugged::Walker
  def self.new(arg); end

  def self.walk(*arg); end
end

class Rugged::WorktreeError
end

class Rugged::WorktreeError
end

class Rugged::ZlibError
end

class Rugged::ZlibError
end

module Rugged
  def self.__cache_usage__(); end

  def self.dotgit_attributes?(arg); end

  def self.dotgit_ignore?(arg); end

  def self.dotgit_modules?(arg); end

  def self.features(); end

  def self.hex_to_raw(arg); end

  def self.libgit2_version(); end

  def self.minimize_oid(*arg); end

  def self.prettify_message(*arg); end

  def self.raw_to_hex(arg); end

  def self.signature_from_buffer(*arg); end

  def self.valid_full_oid?(arg); end
end

SE = PryStackExplorer

module SassC
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Dependency
  def filename(); end

  def initialize(filename); end

  def options(); end
end

class SassC::Dependency
  def self.from_filenames(filenames); end
end

class SassC::Engine
  def dependencies(); end

  def filename(); end

  def initialize(template, options=T.unsafe(nil)); end

  def options(); end

  def render(); end

  def source_map(); end

  def template(); end
  OUTPUT_STYLES = ::T.let(nil, ::T.untyped)
end

class SassC::FunctionsHandler
  def initialize(options); end

  def setup(native_options, functions: T.unsafe(nil)); end
end

class SassC::ImportHandler
  def initialize(options); end

  def setup(native_options); end
end

class SassC::Importer
  def imports(path, parent_path); end

  def initialize(options); end

  def options(); end
end

class SassC::Importer::Import
  def initialize(path, source: T.unsafe(nil), source_map_path: T.unsafe(nil)); end

  def path(); end

  def path=(path); end

  def source(); end

  def source=(source); end

  def source_map_path(); end

  def source_map_path=(source_map_path); end
end

module SassC::Native
  def _context_get_included_files(*arg); end

  def _make_data_context(*arg); end

  def boolean_get_value(*arg); end

  def color_get_a(*arg); end

  def color_get_b(*arg); end

  def color_get_g(*arg); end

  def color_get_r(*arg); end

  def color_set_a(*arg); end

  def color_set_b(*arg); end

  def color_set_g(*arg); end

  def color_set_r(*arg); end

  def compile_data_context(*arg); end

  def compile_file_context(*arg); end

  def compiler_get_last_import(*arg); end

  def context_get_error_column(*arg); end

  def context_get_error_file(*arg); end

  def context_get_error_json(*arg); end

  def context_get_error_line(*arg); end

  def context_get_error_message(*arg); end

  def context_get_error_status(*arg); end

  def context_get_options(*arg); end

  def context_get_output_string(*arg); end

  def context_get_source_map_string(*arg); end

  def data_context_get_context(*arg); end

  def data_context_get_options(*arg); end

  def data_context_set_options(*arg); end

  def delete_data_context(*arg); end

  def delete_file_context(*arg); end

  def error_get_message(*arg); end

  def error_set_message(*arg); end

  def file_context_get_context(*arg); end

  def file_context_get_options(*arg); end

  def file_context_set_options(*arg); end

  def function_get_cookie(*arg); end

  def function_get_function(*arg); end

  def function_get_list_entry(*arg); end

  def function_get_signature(*arg); end

  def function_set_list_entry(*arg); end

  def import_get_abs_path(*arg); end

  def import_get_imp_path(*arg); end

  def import_get_source(*arg); end

  def import_set_list_entry(*arg); end

  def list_get_length(*arg); end

  def list_get_value(*arg); end

  def list_set_value(*arg); end

  def make_boolean(*arg); end

  def make_color(*arg); end

  def make_error(*arg); end

  def make_file_context(*arg); end

  def make_function(*arg); end

  def make_function_list(*arg); end

  def make_import_entry(*arg); end

  def make_import_list(*arg); end

  def make_importer(*arg); end

  def make_list(*arg); end

  def make_map(*arg); end

  def make_number(*arg); end

  def make_options(*arg); end

  def make_qstring(*arg); end

  def make_string(*arg); end

  def map_get_key(*arg); end

  def map_get_length(*arg); end

  def map_get_value(*arg); end

  def map_set_key(*arg); end

  def map_set_value(*arg); end

  def number_get_unit(*arg); end

  def number_get_value(*arg); end

  def option_get_c_functions(*arg); end

  def option_get_include_path(*arg); end

  def option_get_input_path(*arg); end

  def option_get_is_indented_syntax_src(*arg); end

  def option_get_omit_source_map_url(*arg); end

  def option_get_output_path(*arg); end

  def option_get_output_style(*arg); end

  def option_get_precision(*arg); end

  def option_get_source_comments(*arg); end

  def option_get_source_map_contents(*arg); end

  def option_get_source_map_embed(*arg); end

  def option_get_source_map_file(*arg); end

  def option_set_c_functions(*arg); end

  def option_set_c_importers(*arg); end

  def option_set_include_path(*arg); end

  def option_set_input_path(*arg); end

  def option_set_is_indented_syntax_src(*arg); end

  def option_set_omit_source_map_url(*arg); end

  def option_set_output_path(*arg); end

  def option_set_output_style(*arg); end

  def option_set_precision(*arg); end

  def option_set_source_comments(*arg); end

  def option_set_source_map_contents(*arg); end

  def option_set_source_map_embed(*arg); end

  def option_set_source_map_file(*arg); end

  def sass2scss(*arg); end

  def string_get_value(*arg); end

  def string_is_quoted(*arg); end

  def value_get_tag(*arg); end

  def value_is_null(*arg); end

  def version(*arg); end
  SassInputStyle = ::T.let(nil, ::T.untyped)
  SassOutputStyle = ::T.let(nil, ::T.untyped)
  SassSeparator = ::T.let(nil, ::T.untyped)
  SassTag = ::T.let(nil, ::T.untyped)
end

module SassC::Native
  def self._context_get_included_files(*arg); end

  def self._make_data_context(*arg); end

  def self.attach_function(*args); end

  def self.boolean_get_value(*arg); end

  def self.color_get_a(*arg); end

  def self.color_get_b(*arg); end

  def self.color_get_g(*arg); end

  def self.color_get_r(*arg); end

  def self.color_set_a(*arg); end

  def self.color_set_b(*arg); end

  def self.color_set_g(*arg); end

  def self.color_set_r(*arg); end

  def self.compile_data_context(*arg); end

  def self.compile_file_context(*arg); end

  def self.compiler_get_last_import(*arg); end

  def self.context_get_error_column(*arg); end

  def self.context_get_error_file(*arg); end

  def self.context_get_error_json(*arg); end

  def self.context_get_error_line(*arg); end

  def self.context_get_error_message(*arg); end

  def self.context_get_error_status(*arg); end

  def self.context_get_included_files(*args); end

  def self.context_get_options(*arg); end

  def self.context_get_output_string(*arg); end

  def self.context_get_source_map_string(*arg); end

  def self.data_context_get_context(*arg); end

  def self.data_context_get_options(*arg); end

  def self.data_context_set_options(*arg); end

  def self.delete_data_context(*arg); end

  def self.delete_file_context(*arg); end

  def self.error_get_message(*arg); end

  def self.error_set_message(*arg); end

  def self.file_context_get_context(*arg); end

  def self.file_context_get_options(*arg); end

  def self.file_context_set_options(*arg); end

  def self.function_get_cookie(*arg); end

  def self.function_get_function(*arg); end

  def self.function_get_list_entry(*arg); end

  def self.function_get_signature(*arg); end

  def self.function_set_list_entry(*arg); end

  def self.import_get_abs_path(*arg); end

  def self.import_get_imp_path(*arg); end

  def self.import_get_source(*arg); end

  def self.import_set_list_entry(*arg); end

  def self.list_get_length(*arg); end

  def self.list_get_value(*arg); end

  def self.list_set_value(*arg); end

  def self.make_boolean(*arg); end

  def self.make_color(*arg); end

  def self.make_data_context(data); end

  def self.make_error(*arg); end

  def self.make_file_context(*arg); end

  def self.make_function(*arg); end

  def self.make_function_list(*arg); end

  def self.make_import_entry(*arg); end

  def self.make_import_list(*arg); end

  def self.make_importer(*arg); end

  def self.make_list(*arg); end

  def self.make_map(*arg); end

  def self.make_number(*arg); end

  def self.make_options(*arg); end

  def self.make_qstring(*arg); end

  def self.make_string(*arg); end

  def self.map_get_key(*arg); end

  def self.map_get_length(*arg); end

  def self.map_get_value(*arg); end

  def self.map_set_key(*arg); end

  def self.map_set_value(*arg); end

  def self.native_string(string); end

  def self.number_get_unit(*arg); end

  def self.number_get_value(*arg); end

  def self.option_get_c_functions(*arg); end

  def self.option_get_include_path(*arg); end

  def self.option_get_input_path(*arg); end

  def self.option_get_is_indented_syntax_src(*arg); end

  def self.option_get_omit_source_map_url(*arg); end

  def self.option_get_output_path(*arg); end

  def self.option_get_output_style(*arg); end

  def self.option_get_precision(*arg); end

  def self.option_get_source_comments(*arg); end

  def self.option_get_source_map_contents(*arg); end

  def self.option_get_source_map_embed(*arg); end

  def self.option_get_source_map_file(*arg); end

  def self.option_set_c_functions(*arg); end

  def self.option_set_c_importers(*arg); end

  def self.option_set_include_path(*arg); end

  def self.option_set_input_path(*arg); end

  def self.option_set_is_indented_syntax_src(*arg); end

  def self.option_set_omit_source_map_url(*arg); end

  def self.option_set_output_path(*arg); end

  def self.option_set_output_style(*arg); end

  def self.option_set_precision(*arg); end

  def self.option_set_source_comments(*arg); end

  def self.option_set_source_map_contents(*arg); end

  def self.option_set_source_map_embed(*arg); end

  def self.option_set_source_map_file(*arg); end

  def self.return_string_array(ptr); end

  def self.sass2scss(*arg); end

  def self.string_get_type(native_value); end

  def self.string_get_value(*arg); end

  def self.string_is_quoted(*arg); end

  def self.value_get_tag(*arg); end

  def self.value_is_null(*arg); end

  def self.version(*arg); end
end

class SassC::Sass2Scss
  def self.convert(sass); end
end

class SassC::Script::Value
  def ==(other); end

  def _perform(environment); end

  def assert_int!(); end

  def bracketed(); end

  def eql?(other); end

  def initialize(value=T.unsafe(nil)); end

  def null?(); end

  def options(); end

  def options=(options); end

  def separator(); end

  def source_range(); end

  def source_range=(source_range); end

  def to_a(); end

  def to_bool(); end

  def to_h(); end

  def to_i(); end

  def to_s(opts=T.unsafe(nil)); end

  def to_sass(opts=T.unsafe(nil)); end

  def value(); end

  def with_contents(contents, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end
end

class SassC::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Bool
  def self.new(value); end
end

class SassC::Script::Value::Color
  def ==(other_color); end

  def alpha(); end

  def alpha_string(); end

  def blue(); end

  def eql?(other_color); end

  def green(); end

  def hlsa?(); end

  def hue(); end

  def initialize(red: T.unsafe(nil), green: T.unsafe(nil), blue: T.unsafe(nil), hue: T.unsafe(nil), saturation: T.unsafe(nil), lightness: T.unsafe(nil), alpha: T.unsafe(nil)); end

  def lightness(); end

  def red(); end

  def rgba?(); end

  def saturation(); end

  def to_s(); end
end

class SassC::Script::Value::List
  def eq(other); end

  def initialize(value, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::List
  def self.assert_valid_index(list, n); end
end

class SassC::Script::Value::Map
  def eq(other); end

  def initialize(hash); end

  def inspect(opts=T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::Number
  def coerce(num_units, den_units); end

  def comparable_to?(other); end

  def denominator_units(); end

  def initialize(value, numerator_units=T.unsafe(nil), denominator_units=T.unsafe(nil)); end

  def inspect(opts=T.unsafe(nil)); end

  def int?(); end

  def is_unit?(unit); end

  def legal_units?(); end

  def numerator_units(); end

  def original(); end

  def original=(original); end

  def unit_str(); end

  def unitless?(); end
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Number
  def self.basically_equal?(num1, num2); end

  def self.epsilon(); end

  def self.precision(); end

  def self.precision=(digits); end

  def self.precision_factor(); end

  def self.round(num); end
end

class SassC::Script::Value::String
  def initialize(value, type=T.unsafe(nil)); end

  def plus(other); end

  def type(); end
end

class SassC::Script::Value::String
  def self.quote(contents, opts=T.unsafe(nil)); end
end

module SassC::Script::ValueConversion
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::ValueConversion::Base
  def initialize(value); end
end

class SassC::Script::ValueConversion::Bool
  def to_native(); end
end

class SassC::Script::ValueConversion::Color
  def to_native(); end
end

class SassC::Script::ValueConversion::List
  def to_native(); end
end

class SassC::Script::ValueConversion::Map
  def to_native(); end
end

class SassC::Script::ValueConversion::Number
  def to_native(); end
end

class SassC::Script::ValueConversion::String
  def to_native(opts=T.unsafe(nil)); end
end

module SassC::Script::ValueConversion
  def self.from_native(native_value, options); end

  def self.to_native(value); end
end

module SassC::Script
  def self.custom_functions(functions: T.unsafe(nil)); end

  def self.formatted_function_name(function_name, functions: T.unsafe(nil)); end
end

class SassC::SyntaxError
  def initialize(message, filename: T.unsafe(nil), line: T.unsafe(nil)); end

  def sass_backtrace(); end
end

module SassC::Util
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SassC::Util::NormalizedMap
  def [](k); end

  def []=(k, v); end

  def as_stored(); end

  def delete(k); end

  def denormalize(key); end

  def each(&blk); end

  def empty?(); end

  def has_key?(k); end

  def initialize(map=T.unsafe(nil)); end

  def keys(); end

  def map(); end

  def method_missing(method, *args, &block); end

  def normalize(key); end

  def size(); end

  def sort_by(); end

  def to_a(); end

  def to_hash(); end

  def update(map); end

  def values(); end
end

module SassC
  def self.load_paths(); end
end

module Sawyer
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  NO_BODY = ::T.let(nil, ::T.untyped)
end

class Sawyer::LinkParsers::Simple
  LINK_REGEX = ::T.let(nil, ::T.untyped)
end

class Sawyer::Resource
  ATTR_PREDICATE = ::T.let(nil, ::T.untyped)
  ATTR_SETTER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
end

ScanError = StringScanner::Error

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ActionBuilder
  def add_key_input(name); end

  def add_pointer_input(kind, name); end

  def clear_all_actions(); end

  def devices(); end

  def get_device(name); end

  def initialize(bridge, mouse, keyboard, async=T.unsafe(nil)); end

  def key_inputs(); end

  def pause(device, duration=T.unsafe(nil)); end

  def pauses(device, number, duration=T.unsafe(nil)); end

  def perform(); end

  def pointer_inputs(); end

  def release_actions(); end
end

class Selenium::WebDriver::Alert
  def accept(); end

  def dismiss(); end

  def initialize(bridge); end

  def send_keys(keys); end

  def text(); end
end

class Selenium::WebDriver::Chrome::Driver
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Driver
end

module Selenium::WebDriver::Chrome::Features
  def available_log_types(); end

  def cast_issue_message(); end

  def cast_sink_to_use=(name); end

  def cast_sinks(); end

  def commands(command); end

  def delete_network_conditions(); end

  def launch_app(id); end

  def log(type); end

  def network_conditions(); end

  def network_conditions=(conditions); end

  def send_command(command_params); end

  def set_permission(name, value); end

  def start_cast_tab_mirroring(name); end

  def stop_casting(name); end
  CHROME_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Features
end

class Selenium::WebDriver::Chrome::Options
  def add_argument(arg); end

  def add_emulation(**opts); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def add_preference(name, value); end

  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), use_running_app: T.unsafe(nil), activity: T.unsafe(nil)); end

  def extensions(); end

  def extensions=(extensions); end

  def headless!(); end

  def initialize(profile: T.unsafe(nil), **opts); end

  def logging_prefs(); end

  def logging_prefs=(logging_prefs); end

  def profile(); end

  def profile=(profile); end
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
end

class Selenium::WebDriver::Chrome::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def [](key); end

  def []=(key, value); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def directory(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end
end

class Selenium::WebDriver::Chrome::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
end

class Selenium::WebDriver::Chrome::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  MISSING_TEXT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::DevTools
  def callbacks(); end

  def close(); end

  def initialize(url:); end

  def method_missing(method, *_args); end

  def send_cmd(method, **params); end
  RESPONSE_WAIT_INTERVAL = ::T.let(nil, ::T.untyped)
  RESPONSE_WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::DevTools::ConsoleEvent
  def args(); end

  def args=(args); end

  def initialize(type:, timestamp:, args:); end

  def timestamp(); end

  def timestamp=(timestamp); end

  def type(); end

  def type=(type); end
end

class Selenium::WebDriver::DevTools::ConsoleEvent
end

class Selenium::WebDriver::DevTools::ExceptionEvent
  def description(); end

  def description=(description); end

  def initialize(description:, timestamp:, stacktrace:); end

  def stacktrace(); end

  def stacktrace=(stacktrace); end

  def timestamp(); end

  def timestamp=(timestamp); end
end

class Selenium::WebDriver::DevTools::ExceptionEvent
end

class Selenium::WebDriver::DevTools::MutationEvent
  def attribute_name(); end

  def attribute_name=(attribute_name); end

  def current_value(); end

  def current_value=(current_value); end

  def element(); end

  def element=(element); end

  def initialize(element:, attribute_name:, current_value:, old_value:); end

  def old_value(); end

  def old_value=(old_value); end
end

class Selenium::WebDriver::DevTools::MutationEvent
end

class Selenium::WebDriver::DevTools::PinnedScript
  def callable(); end

  def devtools_identifier(); end

  def devtools_identifier=(devtools_identifier); end

  def initialize(script); end

  def key(); end

  def key=(key); end

  def remove(); end

  def script(); end

  def script=(script); end

  def to_json(*arg); end
end

class Selenium::WebDriver::DevTools::PinnedScript
end

class Selenium::WebDriver::DevTools::Request
  def ==(other); end

  def headers(); end

  def headers=(headers); end

  def id(); end

  def initialize(id:, url:, method:, headers:, post_data:); end

  def method(); end

  def method=(method); end

  def post_data(); end

  def post_data=(post_data); end

  def url(); end

  def url=(url); end
end

class Selenium::WebDriver::DevTools::Request
  def self.from(id, params); end
end

class Selenium::WebDriver::DevTools::Response
  def ==(other); end

  def body(); end

  def body=(body); end

  def code(); end

  def code=(code); end

  def headers(); end

  def headers=(headers); end

  def id(); end

  def initialize(id:, code:, body:, headers:); end
end

class Selenium::WebDriver::DevTools::Response
  def self.from(id, encoded_body, params); end
end

class Selenium::WebDriver::DevTools
end

class Selenium::WebDriver::Dimension
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end
end

class Selenium::WebDriver::Dimension
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Selenium::WebDriver::Driver
  def [](sel); end

  def action(); end

  def all(*args); end

  def browser(); end

  def capabilities(); end

  def close(); end

  def current_url(); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def first(*args); end

  def get(url); end

  def initialize(bridge: T.unsafe(nil), listener: T.unsafe(nil), **opts); end

  def keyboard(); end

  def manage(); end

  def mouse(); end

  def navigate(); end

  def page_source(); end

  def quit(); end

  def ref(); end

  def script(script, *args); end

  def status(); end

  def switch_to(); end

  def title(); end

  def window_handle(); end

  def window_handles(); end
end

class Selenium::WebDriver::Driver
  def self.for(browser, opts=T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def download_path=(path); end
end

module Selenium::WebDriver::DriverExtensions::FullPageScreenshot
  def save_full_page_screenshot(path); end
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  def install_addon(path, temporary=T.unsafe(nil)); end

  def uninstall_addon(id); end
end

module Selenium::WebDriver::DriverExtensions::HasApplePermissions
  def permissions(); end

  def permissions=(permissions); end
end

module Selenium::WebDriver::DriverExtensions::HasAuthentication
  def register(username:, password:, uri: T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions::HasCDP
  def execute_cdp(cmd, **params); end
end

module Selenium::WebDriver::DriverExtensions::HasCasting
  def cast_issue_message(); end

  def cast_sink_to_use=(name); end

  def cast_sinks(); end

  def start_cast_tab_mirroring(name); end

  def stop_casting(name); end
end

module Selenium::WebDriver::DriverExtensions::HasContext
  def context(); end

  def context=(value); end
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  def attach_debugger(); end
end

module Selenium::WebDriver::DriverExtensions::HasDevTools
  def devtools(); end
end

module Selenium::WebDriver::DriverExtensions::HasLaunching
  def launch_app(id); end
end

module Selenium::WebDriver::DriverExtensions::HasLocation
  def location(); end

  def location=(*location); end

  def set_location(); end
end

module Selenium::WebDriver::DriverExtensions::HasLogEvents
  def on_log_event(kind, &block); end
  KINDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::HasLogs
  def logs(); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  def delete_network_conditions(); end

  def network_conditions(); end

  def network_conditions=(conditions); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
  def network_connection_type(); end

  def network_connection_type=(*network_connection_type); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkInterception
  def intercept(&block); end
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  def add_permission(name, value); end

  def add_permissions(opt); end
end

module Selenium::WebDriver::DriverExtensions::HasPinnedScripts
  def pin_script(script); end

  def pinned_scripts(); end

  def unpin_script(script); end
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  def remote_status(); end
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  def session_id(); end
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  def local_storage(); end

  def session_storage(); end
end

module Selenium::WebDriver::DriverExtensions::PrintsPage
  def print_page(**options); end

  def save_print_page(path, **options); end
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  def file_detector=(detector); end
end

class Selenium::WebDriver::Edge::Driver
end

class Selenium::WebDriver::Edge::Driver
end

module Selenium::WebDriver::Edge::Features
  include ::Selenium::WebDriver::Chrome::Features
  def commands(command); end
  EDGE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Edge::Features
end

class Selenium::WebDriver::Edge::Options
  BROWSER = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Edge::Options
end

class Selenium::WebDriver::Edge::Profile
end

class Selenium::WebDriver::Edge::Profile
end

class Selenium::WebDriver::Edge::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  MISSING_TEXT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Edge
  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::Element
  def ==(other); end

  def [](name); end

  def accessible_name(); end

  def all(*args); end

  def aria_role(); end

  def as_json(*arg); end

  def attribute(name); end

  def clear(); end

  def click(); end

  def css_value(prop); end

  def displayed?(); end

  def dom_attribute(name); end

  def enabled?(); end

  def eql?(other); end

  def first(*args); end

  def initialize(bridge, id); end

  def location(); end

  def location_once_scrolled_into_view(); end

  def property(name); end

  def rect(); end

  def ref(); end

  def selected?(); end

  def send_key(*args); end

  def send_keys(*args); end

  def shadow_root(); end

  def size(); end

  def style(prop); end

  def submit(); end

  def tag_name(); end

  def text(); end

  def to_json(*arg); end
  ELEMENT_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Error::ServerError
  def initialize(response); end
end

class Selenium::WebDriver::Error::ServerError
end

module Selenium::WebDriver::Error
  def self.for_error(error); end
end

module Selenium::WebDriver::FileReaper
  def self.<<(file); end

  def self.reap(file); end

  def self.reap!(); end

  def self.reap=(reap); end

  def self.reap?(); end

  def self.tmp_files(); end
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
  DEVTOOLS_VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Driver
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Driver
end

class Selenium::WebDriver::Firefox::Extension
  def initialize(path); end

  def write_to(extensions_dir); end
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
end

module Selenium::WebDriver::Firefox::Features
  def commands(command); end

  def context(); end

  def context=(context); end

  def full_screenshot(); end

  def install_addon(path, temporary); end

  def uninstall_addon(id); end
  FIREFOX_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Features
end

class Selenium::WebDriver::Firefox::Options
  def add_argument(arg); end

  def add_preference(name, value); end

  def debugger_address(); end

  def debugger_address=(debugger_address); end

  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), activity: T.unsafe(nil), intent_arguments: T.unsafe(nil)); end

  def headless!(); end

  def initialize(log_level: T.unsafe(nil), **opts); end

  def log_level(); end

  def log_level=(level); end

  def profile(); end

  def profile=(profile); end
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
end

class Selenium::WebDriver::Firefox::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def []=(key, value); end

  def add_extension(path, name=T.unsafe(nil)); end

  def as_json(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end

  def load_no_focus_lib=(load_no_focus_lib); end

  def log_file(); end

  def log_file=(file); end

  def name(); end

  def port=(port); end

  def proxy=(proxy); end

  def secure_ssl=(secure_ssl); end
  DEFAULT_PREFERENCES = ::T.let(nil, ::T.untyped)
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
  def self.decoded(json); end

  def self.from_name(name); end

  def self.ini(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
  def [](name); end

  def refresh(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
end

class Selenium::WebDriver::Firefox::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  MISSING_TEXT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::HTML5::LocalStorage
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::SessionStorage
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(&blk); end

  def empty?(); end

  def fetch(key); end

  def has_key?(key); end

  def key?(key); end

  def member?(key); end
end

class Selenium::WebDriver::IE::Driver
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Driver
end

class Selenium::WebDriver::IE::Options
  def add_argument(arg); end

  def args(); end

  def initialize(**opts); end
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Options
end

class Selenium::WebDriver::IE::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  MISSING_TEXT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::IE
  def self.driver_path(); end

  def self.driver_path=(path); end
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SOURCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::InputDevice
  def actions(); end

  def add_action(action); end

  def clear_actions(); end

  def create_pause(duration=T.unsafe(nil)); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def no_actions?(); end
end

class Selenium::WebDriver::Interactions::Interaction
  def initialize(source); end

  def source(); end
  PAUSE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput
  def create_key_down(key); end

  def create_key_up(key); end

  def encode(); end

  def type(); end
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction
  def assert_type(type); end

  def encode(); end

  def initialize(source, type, key); end

  def type(); end
end

class Selenium::WebDriver::Interactions::NoneInput
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::Pause
  def encode(); end

  def initialize(source, duration=T.unsafe(nil)); end

  def type(); end
end

class Selenium::WebDriver::Interactions::PointerCancel
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::PointerInput
  def assert_kind(pointer); end

  def create_pointer_cancel(); end

  def create_pointer_down(button); end

  def create_pointer_move(duration: T.unsafe(nil), x: T.unsafe(nil), y: T.unsafe(nil), element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def create_pointer_up(button); end

  def encode(); end

  def initialize(kind, name: T.unsafe(nil)); end

  def kind(); end

  def type(); end
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
  def encode(); end

  def initialize(source, duration, x, y, element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def type(); end
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
  def assert_button(button); end

  def assert_direction(direction); end

  def encode(); end

  def initialize(source, direction, button); end

  def type(); end
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Interactions
  def self.key(name); end

  def self.none(name=T.unsafe(nil)); end

  def self.pointer(kind, **kwargs); end
end

module Selenium::WebDriver::KeyActions
  def key_down(*args, device: T.unsafe(nil)); end

  def key_up(*args, device: T.unsafe(nil)); end

  def send_keys(*args, device: T.unsafe(nil)); end
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  def self.[](key); end

  def self.encode(keys); end

  def self.encode_key(key); end
end

class Selenium::WebDriver::Location
  def altitude(); end

  def altitude=(_); end

  def latitude(); end

  def latitude=(_); end

  def longitude(); end

  def longitude=(_); end
end

class Selenium::WebDriver::Location
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Selenium::WebDriver::LogEntry
  def as_json(*arg); end

  def initialize(level, timestamp, message); end

  def level(); end

  def message(); end

  def time(); end

  def timestamp(); end
end

class Selenium::WebDriver::Logger
  def close(*args, **arg, &block); end

  def debug(*args, **arg, &block); end

  def debug?(*args, **arg, &block); end

  def deprecate(old, new=T.unsafe(nil), id: T.unsafe(nil), reference: T.unsafe(nil), &block); end

  def error(*args, **arg, &block); end

  def error?(*args, **arg, &block); end

  def fatal(*args, **arg, &block); end

  def fatal?(*args, **arg, &block); end

  def ignore(id); end

  def info(*args, **arg, &block); end

  def info?(*args, **arg, &block); end

  def initialize(progname=T.unsafe(nil)); end

  def io(); end

  def level(*args, **arg, &block); end

  def level=(*args, **arg, &block); end

  def output=(io); end

  def warn(message, id: T.unsafe(nil)); end

  def warn?(*args, **arg, &block); end
end

class Selenium::WebDriver::Logs
  def available_types(); end

  def get(type); end

  def initialize(bridge); end
end

class Selenium::WebDriver::Manager
  def add_cookie(opts=T.unsafe(nil)); end

  def all_cookies(); end

  def cookie_named(name); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def initialize(bridge); end

  def logs(); end

  def new_window(type=T.unsafe(nil)); end

  def timeouts(); end

  def window(); end
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Navigation
  def back(); end

  def forward(); end

  def initialize(bridge); end

  def refresh(); end

  def to(url); end
end

class Selenium::WebDriver::Options
  def ==(other); end

  def add_option(name, value=T.unsafe(nil)); end

  def as_json(*arg); end

  def eql?(other); end

  def initialize(options: T.unsafe(nil), **opts); end

  def options(); end

  def options=(options); end
  W3C_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Options
  def self.chrome(**opts); end

  def self.driver_path(); end

  def self.edge(**opts); end

  def self.firefox(**opts); end

  def self.ie(**opts); end

  def self.internet_explorer(**opts); end

  def self.microsoftedge(**opts); end

  def self.safari(**opts); end

  def self.set_capabilities(); end
end

module Selenium::WebDriver::Platform
  def self.assert_executable(path); end

  def self.assert_file(path); end

  def self.bitsize(); end

  def self.ci(); end

  def self.cygwin?(); end

  def self.cygwin_path(path, **opts); end

  def self.engine(); end

  def self.exit_hook(); end

  def self.find_binary(*binary_names); end

  def self.find_in_program_files(*binary_names); end

  def self.home(); end

  def self.interfaces(); end

  def self.ip(); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.localhost(); end

  def self.mac?(); end

  def self.make_writable(file); end

  def self.null_device(); end

  def self.os(); end

  def self.ruby_version(); end

  def self.unix_path(path); end

  def self.windows?(); end

  def self.windows_path(path); end

  def self.wrap_in_quotes_if_necessary(str); end

  def self.wsl?(); end
end

class Selenium::WebDriver::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Selenium::WebDriver::PointerActions
  def click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def default_move_duration(); end

  def default_move_duration=(default_move_duration); end

  def double_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def drag_and_drop(source, target, device: T.unsafe(nil)); end

  def drag_and_drop_by(source, right_by, down_by, device: T.unsafe(nil)); end

  def move_by(right_by, down_by, device: T.unsafe(nil)); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil), device: T.unsafe(nil)); end

  def move_to_location(x, y, device: T.unsafe(nil)); end

  def pointer_down(button, device: T.unsafe(nil)); end

  def pointer_up(button, device: T.unsafe(nil)); end

  def release(device: T.unsafe(nil)); end
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  def self.above(port); end

  def self.free?(port); end
end

module Selenium::WebDriver::ProfileHelper
  def as_json(*arg); end

  def encoded(); end

  def to_json(*arg); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  def from_json(json); end
end

module Selenium::WebDriver::ProfileHelper
  def self.decoded(json); end

  def self.included(base); end
end

class Selenium::WebDriver::Proxy
  def ==(other); end

  def as_json(*arg); end

  def auto_detect(); end

  def auto_detect=(bool); end

  def eql?(other); end

  def ftp(); end

  def ftp=(value); end

  def http(); end

  def http=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def no_proxy(); end

  def no_proxy=(value); end

  def pac(); end

  def pac=(url); end

  def socks(); end

  def socks=(value); end

  def socks_password(); end

  def socks_password=(value); end

  def socks_username(); end

  def socks_username=(value); end

  def socks_version(); end

  def socks_version=(value); end

  def ssl(); end

  def ssl=(value); end

  def to_json(*arg); end

  def type(); end

  def type=(type); end
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  def self.json_create(data); end
end

class Selenium::WebDriver::Rectangle
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end

  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Rectangle
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Selenium::WebDriver::Remote
end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms
  def accept_alert(); end

  def action(async=T.unsafe(nil)); end

  def actions(async=T.unsafe(nil)); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def browser(); end

  def capabilities(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click_element(element); end

  def close(); end

  def cookie(name); end

  def cookies(); end

  def create_session(capabilities); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def element_aria_label(element); end

  def element_aria_role(element); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_dom_attribute(element, name); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_screenshot(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def file_detector(); end

  def file_detector=(file_detector); end

  def find_element_by(how, what, parent_ref=T.unsafe(nil)); end

  def find_elements_by(how, what, parent_ref=T.unsafe(nil)); end

  def full_screen_window(); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def http(); end

  def http=(http); end

  def initialize(url:, http_client: T.unsafe(nil)); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def minimize_window(); end

  def mouse(); end

  def new_window(type); end

  def page_source(); end

  def print_page(options=T.unsafe(nil)); end

  def quit(); end

  def refresh(); end

  def release_actions(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screenshot(); end

  def send_actions(data); end

  def send_keys_to_element(element, keys); end

  def session_id(); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end

  def shadow_root(element); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeouts(); end

  def timeouts=(timeouts); end

  def title(); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(); end

  def window_rect(); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
end

class Selenium::WebDriver::Remote::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def accept_insecure_certs(); end

  def accept_insecure_certs=(value); end

  def as_json(*arg); end

  def browser_name(); end

  def browser_name=(value); end

  def browser_version(); end

  def browser_version=(value); end

  def capabilities(); end

  def eql?(other); end

  def implicit_timeout(); end

  def implicit_timeout=(timeout); end

  def initialize(opts=T.unsafe(nil)); end

  def merge!(other); end

  def page_load_strategy(); end

  def page_load_strategy=(value); end

  def page_load_timeout(); end

  def page_load_timeout=(timeout); end

  def platform(); end

  def platform=(value); end

  def platform_name(); end

  def platform_name=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def remote_session_id(); end

  def remote_session_id=(value); end

  def script_timeout(); end

  def script_timeout=(timeout); end

  def set_window_rect(); end

  def set_window_rect=(value); end

  def strict_file_interactability(); end

  def strict_file_interactability=(value); end

  def timeouts(); end

  def timeouts=(timeouts); end

  def to_json(*arg); end

  def unhandled_prompt_behavior(); end

  def unhandled_prompt_behavior=(value); end

  def version(); end

  def version=(value); end

  def web_socket_url(); end

  def web_socket_url=(value); end
  KNOWN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  def self.always_match(capabilities); end

  def self.camel_case(str_or_sym); end

  def self.chrome(opts=T.unsafe(nil)); end

  def self.edge(opts=T.unsafe(nil)); end

  def self.ff(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.first_match(*capabilities); end

  def self.htmlunit(opts=T.unsafe(nil)); end

  def self.ie(opts=T.unsafe(nil)); end

  def self.internet_explorer(opts=T.unsafe(nil)); end

  def self.json_create(data); end

  def self.microsoftedge(opts=T.unsafe(nil)); end

  def self.safari(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::HasRemoteStatus
end

class Selenium::WebDriver::Remote::Driver
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end

  def close(); end

  def quit_errors(); end

  def server_url=(server_url); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
end

class Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def proxy=(proxy); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Response
  def [](key); end

  def code(); end

  def error(); end

  def initialize(code, payload=T.unsafe(nil)); end

  def payload(); end
end

class Selenium::WebDriver::Remote::Response
end

module Selenium::WebDriver::Remote
end

module Selenium::WebDriver::Safari
end

class Selenium::WebDriver::Safari::Driver
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Driver
end

module Selenium::WebDriver::Safari::Features
  def attach_debugger(); end

  def commands(command); end

  def permissions(); end

  def permissions=(permissions); end
  SAFARI_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Features
end

class Selenium::WebDriver::Safari::Options
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Options
end

class Selenium::WebDriver::Safari::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  MISSING_TEXT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Service
end

module Selenium::WebDriver::Safari
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end

  def self.technology_preview(); end

  def self.technology_preview!(); end

  def self.technology_preview?(); end

  def self.use_technology_preview(); end

  def self.use_technology_preview=(use_technology_preview); end
end

module Selenium::WebDriver::SearchContext
  def find_element(*args); end

  def find_elements(*args); end
  FINDERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Service
  def executable_path(); end

  def extra_args(); end

  def extract_service_args(driver_opts); end

  def host(); end

  def host=(host); end

  def initialize(path: T.unsafe(nil), port: T.unsafe(nil), args: T.unsafe(nil)); end

  def launch(); end

  def port(); end

  def shutdown_supported(); end
end

class Selenium::WebDriver::Service
  def self.chrome(**opts); end

  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.edge(**opts); end

  def self.firefox(**opts); end

  def self.ie(**opts); end

  def self.internet_explorer(**opts); end

  def self.microsoftedge(**opts); end

  def self.safari(**opts); end
end

class Selenium::WebDriver::ServiceManager
  def initialize(config); end

  def start(); end

  def stop(); end

  def uri(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ShadowRoot
  def ==(other); end

  def as_json(*arg); end

  def eql?(other); end

  def initialize(bridge, id); end

  def ref(); end

  def to_json(*arg); end
  ROOT_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketLock
  def initialize(port, timeout); end

  def locked(); end
end

class Selenium::WebDriver::SocketPoller
  def closed?(); end

  def connected?(); end

  def initialize(host, port, timeout=T.unsafe(nil), interval=T.unsafe(nil)); end
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end

  def after_click(element, driver); end

  def after_close(driver); end

  def after_execute_script(script, driver); end

  def after_find(by, what, driver); end

  def after_navigate_back(driver); end

  def after_navigate_forward(driver); end

  def after_navigate_to(url, driver); end

  def after_quit(driver); end

  def before_change_value_of(element, driver); end

  def before_click(element, driver); end

  def before_close(driver); end

  def before_execute_script(script, driver); end

  def before_find(by, what, driver); end

  def before_navigate_back(driver); end

  def before_navigate_forward(driver); end

  def before_navigate_to(url, driver); end

  def before_quit(driver); end
end

class Selenium::WebDriver::Support::AbstractEventListener
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::BlockEventListener
end

class Selenium::WebDriver::Support::Color
  def ==(other); end

  def alpha(); end

  def blue(); end

  def eql?(other); end

  def green(); end

  def hex(); end

  def initialize(red, green, blue, alpha=T.unsafe(nil)); end

  def red(); end

  def rgb(); end

  def rgba(); end
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  def self.from_hsl(h, s, l, a); end

  def self.from_string(str); end

  def self.hue_to_rgb(lum1, lum2, hue); end
end

module Selenium::WebDriver::Support::Escaper
end

module Selenium::WebDriver::Support::Escaper
  def self.escape(str); end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def clear_element(ref); end

  def click_element(ref); end

  def close(); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def initialize(delegate, listener); end

  def quit(); end

  def send_keys_to_element(ref, keys); end
end

class Selenium::WebDriver::Support::EventFiringBridge
end

class Selenium::WebDriver::Support::RelativeLocator
  def as_json(); end

  def initialize(locator); end
  KEYS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::RelativeLocator
end

class Selenium::WebDriver::Support::Select
  def deselect_all(); end

  def deselect_by(how, what); end

  def first_selected_option(); end

  def initialize(element); end

  def multiple?(); end

  def options(); end

  def select_all(); end

  def select_by(how, what); end

  def selected_options(); end
end

class Selenium::WebDriver::Support::Select
end

module Selenium::WebDriver::Support
end

module Selenium::WebDriver::TakesScreenshot
  def save_screenshot(png_path, full_page: T.unsafe(nil)); end

  def screenshot_as(format, full_page: T.unsafe(nil)); end
end

class Selenium::WebDriver::TargetLocator
  def active_element(); end

  def alert(); end

  def default_content(); end

  def frame(id); end

  def initialize(bridge); end

  def new_window(type=T.unsafe(nil)); end

  def parent_frame(); end

  def window(id); end
end

class Selenium::WebDriver::Timeouts
  def implicit_wait(); end

  def implicit_wait=(seconds); end

  def initialize(bridge); end

  def page_load(); end

  def page_load=(seconds); end

  def script(); end

  def script=(seconds); end

  def script_timeout(); end

  def script_timeout=(seconds); end
end

class Selenium::WebDriver::Wait
  def initialize(opts=T.unsafe(nil)); end

  def until(); end
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Window
  def full_screen(); end

  def initialize(bridge); end

  def maximize(); end

  def minimize(); end

  def move_to(x, y); end

  def position(); end

  def position=(point); end

  def rect(); end

  def rect=(rectangle); end

  def resize_to(width, height); end

  def size(); end

  def size=(dimension); end
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  def self.unzip(path); end

  def self.zip(path); end

  def self.zip_file(path); end
end

module Selenium::WebDriver
  def self.for(*args); end

  def self.logger(); end

  def self.root(); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Sexp
  def /(pattern); end

  def ==(obj); end

  def =~(pattern); end

  def _concat(*arg); end

  def all(); end

  def all_conditions(); end

  def argument(); end

  def arguments(); end

  def array_size(); end

  def array_type?(); end

  def array_values(); end

  def base_class(); end

  def block_node(); end

  def block_pass?(); end

  def body(); end

  def check(visitor); end

  def check_line_numbers(); end

  def children(); end

  def class_name(); end

  def comments(); end

  def comments=(comments); end

  def conditional_statement(); end

  def const?(); end

  def deep_each(&block); end

  def depth(); end

  def each_of_type(t, &b); end

  def each_sexp(); end

  def eql?(o); end

  def exception_classes(); end

  def exception_variable(); end

  def file(); end

  def file=(file); end

  def find_and_replace_all(from, to); end

  def find_node(name, delete=T.unsafe(nil)); end

  def find_nodes(name); end

  def grep_node(options); end

  def grep_nodes(options); end

  def grep_nodes_count(options); end

  def gsub(pattern, repl); end

  def hash_keys(); end

  def hash_size(); end

  def hash_value(key); end

  def hash_values(); end

  def head(); end

  def initialize(*args); end

  def key(); end

  def left_value(); end

  def line(n=T.unsafe(nil)); end

  def line=(line); end

  def line_max(); end

  def line_min(); end

  def line_number(); end

  def map(&blk); end

  def mass(); end

  def message(); end

  def method_missing(meth, delete=T.unsafe(nil)); end

  def method_name(); end

  def module_name(); end

  def new(*body); end

  def new_method(); end

  def nil_line?(); end

  def old_method(); end

  def origin_argument(); end

  def origin_arguments(); end

  def origin_base_class(); end

  def origin_block_node(); end

  def origin_body(); end

  def origin_class_name(); end

  def origin_conditional_statement(); end

  def origin_left_value(); end

  def origin_message(); end

  def origin_method_name(); end

  def origin_receiver(); end

  def origin_right_value(); end

  def origin_sexp_type(); end

  def paren(); end

  def paren=(paren); end

  def receiver(); end

  def recursive_children(); end

  def remove_line_and_column(); end

  def replace_sexp(pattern, &block); end

  def respond_to?(msg, private=T.unsafe(nil)); end

  def rest(from=T.unsafe(nil)); end

  def right_value(); end

  def satisfy?(pattern); end

  def search_each(pattern, &block); end

  def sexp_body(from=T.unsafe(nil)); end

  def sexp_body=(v); end

  def sexp_type(); end

  def sexp_type=(v); end

  def statements(); end

  def structure(); end

  def sub(pattern, repl); end

  def to_object(); end

  def to_s(); end

  def value(); end
  UNASSIGNED = ::T.let(nil, ::T.untyped)
end

class Sexp::All
  def ==(o); end

  def initialize(*options); end

  def options(); end
end

class Sexp::Any
  def ==(o); end

  def initialize(*options); end

  def options(); end
end

class Sexp::Child
  def ==(o); end

  def child(); end

  def initialize(child); end
end

class Sexp::Include
  def ==(o); end

  def initialize(value); end
end

class Sexp::MatchCollection
  def /(pattern); end

  def to_s(); end
end

class Sexp::Matcher
  def &(other); end

  def -@(); end

  def /(sexp); end

  def ===(sexp); end

  def =~(sexp); end

  def >>(other); end

  def greedy?(); end

  def satisfy?(o); end

  def |(other); end
end

class Sexp::Matcher::Parser
  def initialize(s); end

  def lex(s); end

  def next_token(); end

  def parse(); end

  def parse_cmd(); end

  def parse_list(); end

  def parse_sexp(); end

  def peek_token(); end

  def tokens(); end

  def tokens=(tokens); end
  ALLOWED = ::T.let(nil, ::T.untyped)
end

class Sexp::Matcher
  def self.match_subs=(o); end

  def self.match_subs?(); end

  def self.parse(s); end
end

class Sexp::Not
  def ==(o); end

  def initialize(value); end
end

class Sexp::Pattern
  def ==(o); end

  def initialize(pattern); end

  def pattern(); end
end

class Sexp::Sibling
  def ==(o); end

  def distance(); end

  def initialize(subject, sibling, distance=T.unsafe(nil)); end

  def sibling(); end

  def subject(); end
end

class Sexp::Type
  def ==(o); end

  def initialize(type); end
end

class Sexp
  def self.-(arg); end

  def self._(); end

  def self.___(); end

  def self.all(*args); end

  def self.any(*args); end

  def self.atom(); end

  def self.child(child); end

  def self.from_array(a); end

  def self.include(child); end

  def self.k(klass); end

  def self.m(*values); end

  def self.not?(arg); end

  def self.q(*args); end

  def self.s(*args); end

  def self.t(name); end
end

class Shared::ErrorMessagesComponent
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::GeneratedUrlHelpers
  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end
end

class Shared::ErrorMessagesComponent
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

module Shoulda::Matchers
  TERMINAL_MAX_WIDTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Shoulda::Matchers::ActionController
  def filter_param(key); end

  def permit(*params); end

  def redirect_to(url_or_description, &block); end

  def render_template(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def render_with_layout(expected_layout=T.unsafe(nil)); end

  def rescue_from(exception); end

  def respond_with(status); end

  def route(method, path, port: T.unsafe(nil)); end

  def set_flash(); end

  def set_session(); end

  def use_after_action(callback); end

  def use_around_action(callback); end

  def use_before_action(callback); end
end

module Shoulda::Matchers::ActiveModel
  def allow_value(*values); end

  def allow_values(*values); end

  def have_secure_password(attr=T.unsafe(nil)); end

  def validate_absence_of(attr); end

  def validate_acceptance_of(attr); end

  def validate_confirmation_of(attr); end

  def validate_exclusion_of(attr); end

  def validate_inclusion_of(attr); end

  def validate_length_of(attr); end

  def validate_numericality_of(attr); end

  def validate_presence_of(attr); end
end

module Shoulda::Matchers::ActiveRecord
  def accept_nested_attributes_for(name); end

  def belong_to(name); end

  def define_enum_for(attribute_name); end

  def have_and_belong_to_many(name); end

  def have_db_column(column); end

  def have_db_index(columns); end

  def have_implicit_order_column(column_name); end

  def have_many(name); end

  def have_many_attached(name); end

  def have_one(name); end

  def have_one_attached(name); end

  def have_readonly_attribute(value); end

  def have_rich_text(rich_text_attribute); end

  def have_secure_token(token_attribute=T.unsafe(nil)); end

  def serialize(name); end

  def validate_uniqueness_of(attr); end
end

class Shoulda::Matchers::Configuration
  def integrate(&block); end

  def integrations(); end
end

class Shoulda::Matchers::Document
  def document(); end

  def indent(); end

  def initialize(document, indent: T.unsafe(nil)); end

  def wrap(); end
end

class Shoulda::Matchers::Doublespeak::Double
  def activate(); end

  def activated?(); end

  def call_original_method(call); end

  def calls(); end

  def deactivate(); end

  def implementation(); end

  def initialize(world, klass, method_name, implementation); end

  def klass(); end

  def method_name(); end

  def original_method(); end

  def record_call(call); end

  def replace_method_with_double(); end

  def restore_original_method(); end

  def store_original_method(); end

  def to_return(value=T.unsafe(nil), &block); end

  def world(); end
end

class Shoulda::Matchers::Doublespeak::DoubleCollection
  def activate(); end

  def calls_by_method_name(); end

  def calls_to(method_name); end

  def deactivate(); end

  def doubles_by_method_name(); end

  def initialize(world, klass); end

  def klass(); end

  def register_double(method_name, implementation_type); end

  def register_proxy(method_name); end

  def register_stub(method_name); end

  def world(); end
end

module Shoulda::Matchers::Doublespeak::DoubleImplementationRegistry
  def self.find(type); end

  def self.register(klass, type); end
end

class Shoulda::Matchers::Doublespeak::MethodCall
  def ==(other); end

  def args(); end

  def block(); end

  def caller(); end

  def double(); end

  def initialize(args); end

  def method_name(); end

  def object(); end

  def return_value(); end

  def return_value=(return_value); end

  def to_hash(); end

  def with_return_value(return_value); end
end

class Shoulda::Matchers::Doublespeak::ObjectDouble
  def calls(); end

  def calls_by_method_name(); end

  def calls_to(method_name); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(_name, _include_private=T.unsafe(nil)); end
end

class Shoulda::Matchers::Doublespeak::ProxyImplementation
  def call(call); end

  def initialize(stub_implementation); end

  def returns(*args, **arg, &block); end

  def stub_implementation(); end
end

class Shoulda::Matchers::Doublespeak::ProxyImplementation
  def self.create(); end
end

class Shoulda::Matchers::Doublespeak::StubImplementation
  def call(call); end

  def implementation(); end

  def returns(value=T.unsafe(nil), &block); end
end

class Shoulda::Matchers::Doublespeak::StubImplementation
  def self.create(); end
end

class Shoulda::Matchers::Doublespeak::World
  def double_collection_for(klass); end

  def doubles_activated?(); end

  def original_method_for(klass, method_name); end

  def store_original_method_for(klass, method_name); end

  def with_doubles_activated(); end
end

module Shoulda::Matchers::Doublespeak
  def self.debug(&block); end

  def self.debugging_enabled?(); end

  def self.double_collection_for(*args, **arg, &block); end

  def self.with_doubles_activated(*args, **arg, &block); end

  def self.world(); end
end

class Shoulda::Matchers::Error
  def initialize(*args); end
end

class Shoulda::Matchers::Error
  def self.create(attributes); end
end

module Shoulda::Matchers::Independent
  def delegate_method(delegating_method); end
end

class Shoulda::Matchers::Independent::DelegateMethodMatcher
  def allow_nil(); end

  def as(delegate_method); end

  def build_delegating_method_prefix(prefix); end

  def call_delegating_method_with_delegate_method_returning(value); end

  def calls_on_delegate_object(); end

  def calls_to_delegate_method(); end

  def class_or_instance_method_indicator(); end

  def class_under_test(); end

  def context(); end

  def delegate_method(); end

  def delegate_object(); end

  def delegate_object_reader_method(); end

  def delegate_object_received_call?(); end

  def delegate_object_received_call_with_delegated_arguments?(); end

  def delegated_arguments(); end

  def delegating_method(); end

  def description(); end

  def ensure_delegate_object_has_been_specified!(); end

  def expects_to_allow_nil_delegate_object?(); end

  def failed_to_allow_nil_delegate_object?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def formatted_calls_on_delegate_object(); end

  def formatted_delegate_method(options=T.unsafe(nil)); end

  def formatted_delegate_object_reader_method_name(options=T.unsafe(nil)); end

  def formatted_delegating_method_name(options=T.unsafe(nil)); end

  def formatted_method_name_for(method_name, options); end

  def in_context(context); end

  def initialize(delegating_method); end

  def matches?(subject); end

  def method(); end

  def possible_class_under_test(options); end

  def register_subject_double_collection_to(returned_value); end

  def subject(); end

  def subject_delegates_to_delegate_object_correctly?(); end

  def subject_handles_nil_delegate_object?(); end

  def subject_has_delegate_object_reader_method?(); end

  def subject_has_delegating_method?(); end

  def subject_is_a_class?(); end

  def to(delegate_object_reader_method); end

  def with_arguments(*arguments); end

  def with_prefix(prefix=T.unsafe(nil)); end
end

class Shoulda::Matchers::Integrations::Configuration
  def apply(); end

  def initialize(&block); end

  def library(name); end

  def test_framework(name); end

  def test_frameworks(); end
end

class Shoulda::Matchers::Integrations::Configuration
  def self.apply(&block); end
end

module Shoulda::Matchers::Integrations::Inclusion
  def include_into(mod, *other_mods, &block); end
end

class Shoulda::Matchers::Integrations::Libraries::ActionController
  def integrate_with(test_framework); end
end

class Shoulda::Matchers::Integrations::Libraries::ActiveModel
  def integrate_with(test_framework); end
end

class Shoulda::Matchers::Integrations::Libraries::ActiveRecord
  def integrate_with(test_framework); end
end

class Shoulda::Matchers::Integrations::Libraries::MissingLibrary
  def integrate_with(test_framework); end

  def rails?(); end
end

class Shoulda::Matchers::Integrations::Libraries::Rails
  def integrate_with(test_framework); end
  SUB_LIBRARIES = ::T.let(nil, ::T.untyped)
end

class Shoulda::Matchers::Integrations::Libraries::Routing
  def integrate_with(test_framework); end
end

module Shoulda::Matchers::Integrations::Rails
  def rails?(); end
end

class Shoulda::Matchers::Integrations::Registry
  def find!(name); end

  def register(klass, name); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::ActiveSupportTestCase
  def configuration(); end

  def include(*modules, **_options); end

  def n_unit?(); end

  def validate!(); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Minitest4
  def include(*modules, **_options); end

  def n_unit?(); end

  def validate!(); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Minitest5
  def include(*modules, **_options); end

  def n_unit?(); end

  def validate!(); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::MissingTestFramework
  def include(*modules, **options); end

  def n_unit?(); end

  def validate!(); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::Rspec
  def include(*modules, **options); end

  def n_unit?(); end

  def validate!(); end
end

class Shoulda::Matchers::Integrations::TestFrameworks::TestUnit
  def include(*modules, **_options); end

  def n_unit?(); end

  def validate!(); end
end

module Shoulda::Matchers::Integrations
  def self.find_library!(name); end

  def self.find_test_framework!(name); end

  def self.register_library(klass, name); end

  def self.register_test_framework(klass, name); end
end

class Shoulda::Matchers::Line
  def indent(); end

  def indentation(); end

  def initialize(line, indent: T.unsafe(nil)); end

  def line_to_wrap(); end

  def original_line(); end

  def previous_line_to_wrap(); end

  def wrap(); end
  OFFSETS = ::T.let(nil, ::T.untyped)
end

class Shoulda::Matchers::MatcherContext
  def context(); end

  def initialize(context); end

  def subject_is_a_class?(); end
end

class Shoulda::Matchers::Paragraph
  def indent(); end

  def initialize(paragraph, indent: T.unsafe(nil)); end

  def paragraph(); end

  def wrap(); end
end

module Shoulda::Matchers::RailsShim
  def self.action_pack_version(); end

  def self.active_record_gte_6?(); end

  def self.active_record_version(); end

  def self.attribute_serialization_coder_for(model, attribute_name); end

  def self.attribute_type_for(model, attribute_name); end

  def self.attribute_types_for(model); end

  def self.digestible_attributes_in(record); end

  def self.generate_validation_message(record, attribute, type, model_name, options); end

  def self.has_secure_password?(record, attribute_name); end

  def self.parent_of(mod); end

  def self.secure_password_module(); end

  def self.serialized_attributes_for(model); end

  def self.supports_full_attributes_api?(model); end

  def self.verb_for_update(); end
end

module Shoulda::Matchers::Routing
  def route(method, path, port: T.unsafe(nil)); end
end

class Shoulda::Matchers::Text
  def indented?(); end

  def list_item?(); end

  def match_as_list_item(); end
  LIST_ITEM_REGEXP = ::T.let(nil, ::T.untyped)
end

module Shoulda::Matchers::Util
  MAXIMUM_LENGTH_OF_VALUE_TO_DISPLAY = ::T.let(nil, ::T.untyped)
end

module Shoulda::Matchers::Util
  def self.a_or_an(next_word); end

  def self.deconstantize(path); end

  def self.dummy_value_for(column_type, array: T.unsafe(nil)); end

  def self.indent(string, width); end

  def self.inspect_hash(hash); end

  def self.inspect_range(range); end

  def self.inspect_value(value); end

  def self.inspect_values(values); end

  def self.safe_constantize(camel_cased_word); end
end

module Shoulda::Matchers::WordWrap
  def word_wrap(document, options=T.unsafe(nil)); end
  TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

module Shoulda::Matchers
  def self.assertion_exception_class(); end

  def self.assertion_exception_class=(assertion_exception_class); end

  def self.configuration(); end

  def self.configure(); end

  def self.integrations(); end

  def self.warn(message); end

  def self.warn_about_deprecated_method(old_method, new_method); end
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def at_fork(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def enable_for_subprocesses(value=T.unsafe(nil)); end

  def enabled_for_subprocesses?(); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def primary_coverage(criterion=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def raise_on_invalid_coverage(coverage, coverage_setting); end

  def refuse_coverage_drop(*criteria); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes::ExitCodeHandling
  def self.call(result, coverage_limits:); end

  def self.coverage_checks(result, coverage_limits); end
end

class SimpleCov::ExitCodes::MaximumCoverageDropCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, maximum_coverage_drop); end

  def report(); end
  MAX_DROP_ACCURACY = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ExitCodes::MinimumCoverageByFileCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage_by_file); end

  def report(); end
end

class SimpleCov::ExitCodes::MinimumOverallCoverageCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage); end

  def report(); end
end

class SimpleCov::FileList
  def branch_covered_percent(); end

  def count(*args, **arg, &block); end

  def coverage_statistics(); end

  def coverage_statistics_by_file(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, **arg, &block); end

  def empty?(*args, **arg, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, **arg, &block); end

  def lines_of_code(); end

  def map(*args, **arg, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, **arg, &block); end

  def skipped_lines(); end

  def to_a(*args, **arg, &block); end

  def to_ary(*args, **arg, &block); end

  def total_branches(); end
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

class SimpleCov::Formatter::HTMLFormatter
  def branchable_result?(); end

  def format(result); end

  def line_status?(source_file, line); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::JSONFormatter
  def format(result); end

  def output_filename(); end

  def output_filepath(); end

  def output_message(result); end
end

class SimpleCov::Formatter::LcovFormatter
  def format(result); end
end

class SimpleCov::Formatter::LcovFormatter
  def self.config(); end

  def self.report_with_single_file=(value); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

module SimpleCov::Formatter
  def self.from_env(env); end
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, **arg, &block); end

  def coverage_statistics_by_file(*args, **arg, &block); end

  def covered_branches(*args, **arg, &block); end

  def covered_lines(*args, **arg, &block); end

  def covered_percent(*args, **arg, &block); end

  def covered_percentages(*args, **arg, &block); end

  def covered_strength(*args, **arg, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result, command_name: T.unsafe(nil), created_at: T.unsafe(nil)); end

  def least_covered_file(*args, **arg, &block); end

  def missed_branches(*args, **arg, &block); end

  def missed_lines(*args, **arg, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_branches(*args, **arg, &block); end

  def total_lines(*args, **arg, &block); end
end

class SimpleCov::Result
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
  def self.adapt_pre_simplecov_0_18_result(result); end

  def self.adapt_result(result); end

  def self.create_result(command_names, coverage); end

  def self.merge_and_store(*file_paths, ignore_timeout: T.unsafe(nil)); end

  def self.merge_coverage(*results); end

  def self.merge_results(*file_paths, ignore_timeout: T.unsafe(nil)); end

  def self.merge_valid_results(results, ignore_timeout: T.unsafe(nil)); end

  def self.merged_result(); end

  def self.parse_file(path); end

  def self.parse_json(content); end

  def self.pre_simplecov_0_18_result?(result); end

  def self.read_file(path); end

  def self.read_resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.synchronize_resultset(); end

  def self.time_since_result_creation(data); end

  def self.valid_results(file_path, ignore_timeout: T.unsafe(nil)); end

  def self.within_merge_timeout?(data); end
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
  RUBY_FILE_ENCODING_MAGIC_COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SHEBANG_REGEX = ::T.let(nil, ::T.untyped)
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end

  def self.root_regx(); end
end

module SimpleCov
  def self.at_exit_behavior(); end

  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), ignore_timeout: T.unsafe(nil), &block); end

  def self.exit_and_report_previous_error(exit_status); end

  def self.exit_status_from_exception(); end

  def self.external_at_exit(); end

  def self.external_at_exit=(external_at_exit); end

  def self.external_at_exit?(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.previous_error?(error_exit_status); end

  def self.process_result(result); end

  def self.process_results_and_report_error(); end

  def self.ready_to_process_results?(); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result); end

  def self.round_coverage(coverage); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(result); end
end

class SimpleCovLcov::Configuration
  def lcov_file_name(); end

  def lcov_file_name=(lcov_file_name); end

  def output_directory(); end

  def output_directory=(output_directory); end

  def report_with_single_file=(report_with_single_file); end

  def report_with_single_file?(); end

  def single_report_path(); end

  def single_report_path=(new_path); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SimpleForm
  def boolean_label_class(); end

  def boolean_label_class=(val); end

  def boolean_style(); end

  def boolean_style=(val); end

  def browser_validations(); end

  def browser_validations=(val); end

  def button_class(); end

  def button_class=(val); end

  def cache_discovery(); end

  def cache_discovery=(val); end

  def collection_label_methods(); end

  def collection_label_methods=(val); end

  def collection_value_methods(); end

  def collection_value_methods=(val); end

  def collection_wrapper_class(); end

  def collection_wrapper_class=(val); end

  def collection_wrapper_tag(); end

  def collection_wrapper_tag=(val); end

  def country_priority(); end

  def country_priority=(val); end

  def custom_inputs_namespaces(); end

  def custom_inputs_namespaces=(val); end

  def default_form_class(); end

  def default_form_class=(val); end

  def default_wrapper(); end

  def default_wrapper=(val); end

  def error_method(); end

  def error_method=(val); end

  def error_notification_class(); end

  def error_notification_class=(val); end

  def error_notification_tag(); end

  def error_notification_tag=(val); end

  def field_error_proc(); end

  def field_error_proc=(val); end

  def form_class(); end

  def generate_additional_classes_for(); end

  def generate_additional_classes_for=(val); end

  def i18n_scope(); end

  def i18n_scope=(val); end

  def include_default_input_wrapper_class(); end

  def include_default_input_wrapper_class=(val); end

  def input_class(); end

  def input_class=(val); end

  def input_field_error_class(); end

  def input_field_error_class=(val); end

  def input_field_valid_class(); end

  def input_field_valid_class=(val); end

  def input_mappings(); end

  def input_mappings=(val); end

  def inputs_discovery(); end

  def inputs_discovery=(val); end

  def item_wrapper_class(); end

  def item_wrapper_class=(val); end

  def item_wrapper_tag(); end

  def item_wrapper_tag=(val); end

  def label_class(); end

  def label_class=(val); end

  def label_text(); end

  def label_text=(val); end

  def required_by_default(); end

  def required_by_default=(val); end

  def time_zone_priority(); end

  def time_zone_priority=(val); end

  def translate_labels(); end

  def translate_labels=(val); end

  def wrapper_mappings(); end

  def wrapper_mappings=(val); end
  CUSTOM_INPUT_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
  FILE_METHODS_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
end

module SimpleForm::ActionViewExtensions
end

module SimpleForm::ActionViewExtensions::Builder
  def simple_fields_for(*args, &block); end
end

module SimpleForm::ActionViewExtensions::Builder
end

module SimpleForm::ActionViewExtensions::FormHelper
  def simple_fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def simple_form_for(record, options=T.unsafe(nil), &block); end
end

module SimpleForm::ActionViewExtensions::FormHelper
end

module SimpleForm::ActionViewExtensions
end

module SimpleForm::Components
end

module SimpleForm::Components::Errors
  def error(wrapper_options=T.unsafe(nil)); end

  def error_method(); end

  def error_text(); end

  def errors(); end

  def errors_on_association(); end

  def errors_on_attribute(); end

  def full_error(wrapper_options=T.unsafe(nil)); end

  def full_error_text(); end

  def full_errors(); end

  def full_errors_on_association(); end

  def full_errors_on_attribute(); end

  def has_custom_error?(); end

  def has_errors?(); end

  def has_value?(); end

  def object_with_errors?(); end

  def valid?(); end
end

module SimpleForm::Components::Errors
end

module SimpleForm::Components::HTML5
  def has_required?(); end

  def html5(wrapper_options=T.unsafe(nil)); end

  def html5?(); end

  def initialize(*arg); end

  def input_html_aria_required_option(); end

  def input_html_required_option(); end
end

module SimpleForm::Components::HTML5
end

module SimpleForm::Components::Hints
  def has_hint?(); end

  def hint(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Hints
end

module SimpleForm::Components::LabelInput
  def label_input(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::LabelInput
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Labels
  def generate_label_for_attribute?(); end

  def label(wrapper_options=T.unsafe(nil)); end

  def label_html_options(); end

  def label_target(); end

  def label_text(wrapper_options=T.unsafe(nil)); end

  def label_translation(); end

  def raw_label_text(); end

  def required_label_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
  def translate_required_html(); end

  def translate_required_mark(); end

  def translate_required_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
end

module SimpleForm::Components::Labels
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Maxlength
  def maxlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Maxlength
end

module SimpleForm::Components::MinMax
  def min_max(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::MinMax
end

module SimpleForm::Components::Minlength
  def minlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Minlength
end

module SimpleForm::Components::Pattern
  def pattern(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Pattern
end

module SimpleForm::Components::Placeholders
  def placeholder(wrapper_options=T.unsafe(nil)); end

  def placeholder_text(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Placeholders
end

module SimpleForm::Components::Readonly
  def readonly(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Readonly
end

module SimpleForm::Components
  extend ::ActiveSupport::Autoload
end

class SimpleForm::ErrorNotification
  def error_message(); end

  def error_notification_tag(); end

  def errors(); end

  def has_errors?(); end

  def html_options(); end

  def initialize(builder, options); end

  def object(*arg, **arg1, &arg2); end

  def object_name(*arg, **arg1, &arg2); end

  def render(); end

  def template(*arg, **arg1, &arg2); end

  def translate_error_notification(); end
end

class SimpleForm::ErrorNotification
end

class SimpleForm::FormBuilder
  include ::SimpleForm::Inputs
  def association(association, options=T.unsafe(nil), &block); end

  def attribute(attribute_name, options=T.unsafe(nil), &block); end

  def button(type, *args, &block); end

  def button_button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def error(attribute_name, options=T.unsafe(nil)); end

  def error_notification(options=T.unsafe(nil)); end

  def full_error(attribute_name, options=T.unsafe(nil)); end

  def hint(attribute_name, options=T.unsafe(nil)); end

  def initialize(*arg); end

  def input(attribute_name, options=T.unsafe(nil), &block); end

  def input_field(attribute_name, options=T.unsafe(nil)); end

  def label(attribute_name, *args); end

  def lookup_action(); end

  def lookup_model_names(); end

  def mappings(); end

  def mappings=(mappings); end

  def mappings?(); end

  def template(); end

  def wrapper(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SimpleForm::FormBuilder
  extend ::SimpleForm::MapType
  def self.discovery_cache(); end

  def self.mappings(); end

  def self.mappings=(value); end

  def self.mappings?(); end
end

module SimpleForm::Helpers
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Validators
  def has_validators?(); end
end

module SimpleForm::Helpers::Validators
end

module SimpleForm::Helpers
end

module SimpleForm::Inputs
end

module SimpleForm::Inputs
  extend ::ActiveSupport::Autoload
end

module SimpleForm::MapType
  def map_type(*types); end
end

module SimpleForm::MapType
  def self.extended(base); end
end

class SimpleForm::Railtie
end

class SimpleForm::Railtie
end

module SimpleForm::Tags
end

class SimpleForm::Tags::CollectionCheckBoxes
  include ::SimpleForm::Tags::CollectionExtensions
  def render(); end
end

class SimpleForm::Tags::CollectionCheckBoxes
end

module SimpleForm::Tags::CollectionExtensions
end

module SimpleForm::Tags::CollectionExtensions
end

class SimpleForm::Tags::CollectionRadioButtons
  include ::SimpleForm::Tags::CollectionExtensions
  def render(); end
end

class SimpleForm::Tags::CollectionRadioButtons
end

module SimpleForm::Tags
end

class SimpleForm::WrapperNotFound
end

class SimpleForm::WrapperNotFound
end

module SimpleForm::Wrappers
end

class SimpleForm::Wrappers::Builder
  def initialize(options); end

  def optional(name, options=T.unsafe(nil), &block); end

  def to_a(); end

  def use(name, options=T.unsafe(nil)); end

  def wrapper(name, options=T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Builder
end

class SimpleForm::Wrappers::Leaf
  def find(name); end

  def initialize(namespace, options=T.unsafe(nil)); end

  def namespace(); end

  def render(input); end
end

class SimpleForm::Wrappers::Leaf
end

class SimpleForm::Wrappers::Many
  def components(); end

  def defaults(); end

  def find(name); end

  def initialize(namespace, components, defaults=T.unsafe(nil)); end

  def namespace(); end

  def render(input); end
end

class SimpleForm::Wrappers::Many
end

class SimpleForm::Wrappers::Root
  def initialize(*args); end

  def options(); end
end

class SimpleForm::Wrappers::Root
end

class SimpleForm::Wrappers::Single
  def initialize(name, wrapper_options=T.unsafe(nil), options=T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Single
end

module SimpleForm::Wrappers
end

module SimpleForm
  extend ::ActiveSupport::Autoload
  def self.additional_classes_for(component); end

  def self.boolean_label_class(); end

  def self.boolean_label_class=(val); end

  def self.boolean_style(); end

  def self.boolean_style=(val); end

  def self.browser_validations(); end

  def self.browser_validations=(val); end

  def self.build(options=T.unsafe(nil)); end

  def self.button_class(); end

  def self.button_class=(val); end

  def self.cache_discovery(); end

  def self.cache_discovery=(val); end

  def self.collection_label_methods(); end

  def self.collection_label_methods=(val); end

  def self.collection_value_methods(); end

  def self.collection_value_methods=(val); end

  def self.collection_wrapper_class(); end

  def self.collection_wrapper_class=(val); end

  def self.collection_wrapper_tag(); end

  def self.collection_wrapper_tag=(val); end

  def self.configured?(); end

  def self.country_priority(); end

  def self.country_priority=(val); end

  def self.custom_inputs_namespaces(); end

  def self.custom_inputs_namespaces=(val); end

  def self.default_form_class(); end

  def self.default_form_class=(val); end

  def self.default_input_size=(*default_input_size); end

  def self.default_wrapper(); end

  def self.default_wrapper=(val); end

  def self.error_method(); end

  def self.error_method=(val); end

  def self.error_notification_class(); end

  def self.error_notification_class=(val); end

  def self.error_notification_tag(); end

  def self.error_notification_tag=(val); end

  def self.field_error_proc(); end

  def self.field_error_proc=(val); end

  def self.file_methods(); end

  def self.file_methods=(file_methods); end

  def self.form_class(); end

  def self.form_class=(value); end

  def self.generate_additional_classes_for(); end

  def self.generate_additional_classes_for=(val); end

  def self.i18n_scope(); end

  def self.i18n_scope=(val); end

  def self.include_component(component); end

  def self.include_default_input_wrapper_class(); end

  def self.include_default_input_wrapper_class=(val); end

  def self.input_class(); end

  def self.input_class=(val); end

  def self.input_field_error_class(); end

  def self.input_field_error_class=(val); end

  def self.input_field_valid_class(); end

  def self.input_field_valid_class=(val); end

  def self.input_mappings(); end

  def self.input_mappings=(val); end

  def self.inputs_discovery(); end

  def self.inputs_discovery=(val); end

  def self.item_wrapper_class(); end

  def self.item_wrapper_class=(val); end

  def self.item_wrapper_tag(); end

  def self.item_wrapper_tag=(val); end

  def self.label_class(); end

  def self.label_class=(val); end

  def self.label_text(); end

  def self.label_text=(val); end

  def self.required_by_default(); end

  def self.required_by_default=(val); end

  def self.setup(); end

  def self.time_zone_priority(); end

  def self.time_zone_priority=(val); end

  def self.translate_labels(); end

  def self.translate_labels=(val); end

  def self.wrapper(name); end

  def self.wrapper_mappings(); end

  def self.wrapper_mappings=(val); end

  def self.wrappers(*args, &block); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Skiptrace
  VERSION = ::T.let(nil, ::T.untyped)
end

class Skiptrace::BindingLocations
  def initialize(locations, bindings); end
end

class Skiptrace::Location
  def absolute_path(); end

  def base_label(); end

  def initialize(location, binding); end

  def label(); end

  def lineno(); end
end

module Skiptrace
  def self.current_bindings(); end
end

module SmartProperties
  def [](name); end

  def []=(name, value); end

  def initialize(*args, &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SmartProperties::AssignmentError
  def initialize(sender, property, message); end

  def property(); end

  def property=(property); end

  def sender(); end

  def sender=(sender); end
end

module SmartProperties::ClassMethods
  def properties(); end

  def property(name, **options); end

  def property!(name, **options); end
end

class SmartProperties::ConstructorArgumentForwardingError
  def initialize(positional_arguments, keyword_arguments); end
end

class SmartProperties::InitializationError
  def initialize(sender, properties); end

  def properties(); end

  def properties=(properties); end

  def sender(); end

  def sender=(sender); end

  def to_hash(); end
end

class SmartProperties::InvalidValueError
  def initialize(sender, property, value); end

  def to_hash(); end

  def value(); end

  def value=(value); end
end

class SmartProperties::MissingValueError
  def initialize(sender, property); end

  def to_hash(); end
end

module SmartProperties::ModuleMethods
  def included(target); end
end

class SmartProperties::Property
  def accepter(); end

  def accepts?(value, scope); end

  def convert(scope, value); end

  def converter(); end

  def default(scope); end

  def define(klass); end

  def get(scope); end

  def initialize(name, **attrs); end

  def instance_variable_name(); end

  def missing?(scope); end

  def name(); end

  def optional?(scope); end

  def prepare(scope, value); end

  def present?(scope); end

  def reader(); end

  def required?(scope); end

  def set(scope, value); end

  def set_default(scope); end

  def to_h(); end

  def writable(); end

  def writable?(); end
  ALLOWED_DEFAULT_CLASSES = ::T.let(nil, ::T.untyped)
  MODULE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class SmartProperties::Property
  def self.define(scope, name, **options); end
end

class SmartProperties::PropertyCollection
  def [](name); end

  def []=(name, value); end

  def children(); end

  def children=(children); end

  def collection(); end

  def collection=(collection); end

  def collection_with_parent_collection(); end

  def collection_with_parent_collection=(collection_with_parent_collection); end

  def each(&block); end

  def key?(name); end

  def keys(); end

  def notify_children(); end

  def parent(); end

  def refresh(parent_collection); end

  def register(child); end

  def to_hash(); end

  def values(); end
end

class SmartProperties::PropertyCollection
  def self.for(scope); end
end

class SmartProperties::Validations::Ancestor
  def to_proc(); end

  def validate(klass); end
end

class SmartProperties::Validations::Ancestor
  def self.must_be(*arg, **arg1); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module SorbetRails::CustomFinderMethods
  def find_by_id(id); end

  def find_by_id!(id); end

  def find_n(*ids); end

  def first_n(n); end

  def last_n(n); end

  def select_columns(*args); end

  def where_missing(*args); end
end

SorbetRails::JobRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

SorbetRails::MailerRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

module SorbetRails::ModelPlugins
  include ::DEBUGGER__::TrapInterceptor
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

module SorbetRails::PluckToTStruct
  NILCLASS_STRING = ::T.let(nil, ::T.untyped)
end

module SorbetRails::SorbetUtils
  include ::DEBUGGER__::TrapInterceptor
end

class SorbetRails::TypedEnumConfig
  def class_name(); end

  def strict_mode(); end
end

class SorbetRails::TypedEnumConfig
  def self.inherited(s); end
end

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom
  SPOOM_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli
end

class Spoom::Cli::Bump
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def bump(*args, **arg, &blk); end

  def config_files(path: T.unsafe(nil)); end

  def print_changes(files, command:, from: T.unsafe(nil), to: T.unsafe(nil), dry: T.unsafe(nil), path: T.unsafe(nil)); end

  def undo_changes(files, from_strictness); end
end

class Spoom::Cli::Bump
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Cli::Config
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def show(); end
end

class Spoom::Cli::Config
end

class Spoom::Cli::Coverage
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def bundle_install(path, sha); end

  def message_no_data(file); end

  def open(file=T.unsafe(nil)); end

  def parse_time(string, option); end

  def report(); end

  def snapshot(); end

  def timeline(); end
  DATA_DIR = ::T.let(nil, ::T.untyped)
end

class Spoom::Cli::Coverage
end

module Spoom::Cli::Helper
  include ::Spoom::Colorize
  def blue(*args, **arg, &blk); end

  def check_sorbet_segfault(*args, **arg, &blk); end

  def color?(*args, **arg, &blk); end

  def colorize(*args, **arg, &blk); end

  def cyan(*args, **arg, &blk); end

  def exec_path(*args, **arg, &blk); end

  def gray(*args, **arg, &blk); end

  def green(*args, **arg, &blk); end

  def highlight(*args, **arg, &blk); end

  def in_sorbet_project!(*args, **arg, &blk); end

  def in_sorbet_project?(*args, **arg, &blk); end

  def red(*args, **arg, &blk); end

  def say(*args, **arg, &blk); end

  def say_error(*args, **arg, &blk); end

  def sorbet_config(*args, **arg, &blk); end

  def sorbet_config_file(*args, **arg, &blk); end

  def yellow(*args, **arg, &blk); end
  HIGHLIGHT_COLOR = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli::Helper
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Cli::LSP
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def defs(file, line, col); end

  def find(query); end

  def hover(file, line, col); end

  def list(); end

  def lsp_client(); end

  def refs(file, line, col); end

  def run(&block); end

  def show(); end

  def sigs(file, line, col); end

  def symbol_printer(); end

  def symbols(file); end

  def to_uri(path); end

  def types(file, line, col); end
end

class Spoom::Cli::LSP
end

class Spoom::Cli::Main
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def __print_version(); end

  def bump(*args); end

  def config(*args); end

  def coverage(*args); end

  def files(); end

  def lsp(*args); end

  def tc(*args); end
end

class Spoom::Cli::Main
  extend ::T::Sig
end

class Spoom::Cli::Run
  include ::Spoom::Cli::Helper
  include ::Spoom::Colorize
  def colorize_message(message); end

  def format_error(error, format); end

  def tc(*arg); end
  DEFAULT_FORMAT = ::T.let(nil, ::T.untyped)
  SORT_CODE = ::T.let(nil, ::T.untyped)
  SORT_ENUM = ::T.let(nil, ::T.untyped)
  SORT_LOC = ::T.let(nil, ::T.untyped)
end

class Spoom::Cli::Run
end

module Spoom::Cli
end

class Spoom::Color
  def ansi_code(*args, **arg, &blk); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  LIGHT_BLACK = ::T.let(nil, ::T.untyped)
  LIGHT_BLUE = ::T.let(nil, ::T.untyped)
  LIGHT_CYAN = ::T.let(nil, ::T.untyped)
  LIGHT_GREEN = ::T.let(nil, ::T.untyped)
  LIGHT_MAGENTA = ::T.let(nil, ::T.untyped)
  LIGHT_RED = ::T.let(nil, ::T.untyped)
  LIGHT_WHITE = ::T.let(nil, ::T.untyped)
  LIGHT_YELLOW = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Spoom::Color
  extend ::T::Helpers
end

module Spoom::Colorize
  def set_color(*args, **arg, &blk); end
end

module Spoom::Colorize
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage
end

module Spoom::Coverage::Cards
end

class Spoom::Coverage::Cards::Card
  def body(); end

  def title(*args, **arg, &blk); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Card
end

class Spoom::Coverage::Cards::Erb
end

class Spoom::Coverage::Cards::Erb
end

class Spoom::Coverage::Cards::Map
end

class Spoom::Coverage::Cards::Map
end

class Spoom::Coverage::Cards::Snapshot
  def pie_calls(*args, **arg, &blk); end

  def pie_sigils(*args, **arg, &blk); end

  def pie_sigs(*args, **arg, &blk); end

  def snapshot(*args, **arg, &blk); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Cards::Snapshot
end

class Spoom::Coverage::Cards::SorbetIntro
end

class Spoom::Coverage::Cards::SorbetIntro
end

class Spoom::Coverage::Cards::Timeline
end

class Spoom::Coverage::Cards::Timeline::Calls
end

class Spoom::Coverage::Cards::Timeline::Calls
end

class Spoom::Coverage::Cards::Timeline::RBIs
end

class Spoom::Coverage::Cards::Timeline::RBIs
end

class Spoom::Coverage::Cards::Timeline::Runtimes
end

class Spoom::Coverage::Cards::Timeline::Runtimes
end

class Spoom::Coverage::Cards::Timeline::Sigils
end

class Spoom::Coverage::Cards::Timeline::Sigils
end

class Spoom::Coverage::Cards::Timeline::Sigs
end

class Spoom::Coverage::Cards::Timeline::Sigs
end

class Spoom::Coverage::Cards::Timeline::Versions
end

class Spoom::Coverage::Cards::Timeline::Versions
end

class Spoom::Coverage::Cards::Timeline
end

module Spoom::Coverage::Cards
end

module Spoom::Coverage::D3
  COLOR_FALSE = ::T.let(nil, ::T.untyped)
  COLOR_IGNORE = ::T.let(nil, ::T.untyped)
  COLOR_STRICT = ::T.let(nil, ::T.untyped)
  COLOR_STRONG = ::T.let(nil, ::T.untyped)
  COLOR_TRUE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::D3::Base
  def html(*args, **arg, &blk); end

  def id(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def script(*args, **arg, &blk); end

  def tooltip(*args, **arg, &blk); end
end

class Spoom::Coverage::D3::Base
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.header_script(*args, **arg, &blk); end

  def self.header_style(*args, **arg, &blk); end
end

class Spoom::Coverage::D3::CircleMap
end

class Spoom::Coverage::D3::CircleMap::Sigils
  def tree_node_score(*args, **arg, &blk); end

  def tree_node_strictness(*args, **arg, &blk); end

  def tree_node_to_json(*args, **arg, &blk); end
end

class Spoom::Coverage::D3::CircleMap::Sigils
end

class Spoom::Coverage::D3::CircleMap
end

class Spoom::Coverage::D3::ColorPalette
  def false(); end

  def false=(val); end

  def ignore(); end

  def ignore=(val); end

  def initialize(hash=T.unsafe(nil)); end

  def strict(); end

  def strict=(val); end

  def strong(); end

  def strong=(val); end

  def true(); end

  def true=(val); end
end

class Spoom::Coverage::D3::ColorPalette
  def self.inherited(s); end
end

class Spoom::Coverage::D3::Pie
end

class Spoom::Coverage::D3::Pie::Calls
end

class Spoom::Coverage::D3::Pie::Calls
end

class Spoom::Coverage::D3::Pie::Sigils
end

class Spoom::Coverage::D3::Pie::Sigils
end

class Spoom::Coverage::D3::Pie::Sigs
end

class Spoom::Coverage::D3::Pie::Sigs
end

class Spoom::Coverage::D3::Pie
end

class Spoom::Coverage::D3::Timeline
  def area(*args, **arg, &blk); end

  def line(*args, **arg, &blk); end

  def plot(*args, **arg, &blk); end

  def points(*args, **arg, &blk); end

  def x_scale(*args, **arg, &blk); end

  def x_ticks(*args, **arg, &blk); end

  def y_scale(*args, **arg, &blk); end

  def y_ticks(*args, **arg, &blk); end
end

class Spoom::Coverage::D3::Timeline::Calls
end

class Spoom::Coverage::D3::Timeline::Calls
end

class Spoom::Coverage::D3::Timeline::RBIs
end

class Spoom::Coverage::D3::Timeline::RBIs
end

class Spoom::Coverage::D3::Timeline::Runtimes
end

class Spoom::Coverage::D3::Timeline::Runtimes
end

class Spoom::Coverage::D3::Timeline::Sigils
end

class Spoom::Coverage::D3::Timeline::Sigils
end

class Spoom::Coverage::D3::Timeline::Sigs
end

class Spoom::Coverage::D3::Timeline::Sigs
end

class Spoom::Coverage::D3::Timeline::Stacked
end

class Spoom::Coverage::D3::Timeline::Stacked
end

class Spoom::Coverage::D3::Timeline::Versions
end

class Spoom::Coverage::D3::Timeline::Versions
end

class Spoom::Coverage::D3::Timeline
end

module Spoom::Coverage::D3
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.header_script(*args, **arg, &blk); end

  def self.header_style(*args, **arg, &blk); end
end

class Spoom::Coverage::Page
  def body_html(*args, **arg, &blk); end

  def cards(*args, **arg, &blk); end

  def footer_html(*args, **arg, &blk); end

  def header_html(*args, **arg, &blk); end

  def header_script(*args, **arg, &blk); end

  def header_style(*args, **arg, &blk); end

  def palette(*args, **arg, &blk); end

  def title(*args, **arg, &blk); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Page
end

class Spoom::Coverage::Report
  def project_name(*args, **arg, &blk); end

  def sigils_tree(*args, **arg, &blk); end

  def snapshots(*args, **arg, &blk); end

  def sorbet_intro_commit(*args, **arg, &blk); end

  def sorbet_intro_date(*args, **arg, &blk); end
end

class Spoom::Coverage::Report
end

class Spoom::Coverage::Snapshot
  def calls_typed(); end

  def calls_typed=(val); end

  def calls_untyped(); end

  def calls_untyped=(val); end

  def classes(); end

  def classes=(val); end

  def commit_sha(); end

  def commit_sha=(val); end

  def commit_timestamp(); end

  def commit_timestamp=(val); end

  def duration(); end

  def duration=(val); end

  def files(); end

  def files=(val); end

  def initialize(hash=T.unsafe(nil)); end

  def methods_with_sig(); end

  def methods_with_sig=(val); end

  def methods_without_sig(); end

  def methods_without_sig=(val); end

  def modules(); end

  def modules=(val); end

  def print(*args, **arg, &blk); end

  def rbi_files(); end

  def rbi_files=(val); end

  def sigils(); end

  def sigils=(val); end

  def singleton_classes(); end

  def singleton_classes=(val); end

  def timestamp(); end

  def timestamp=(val); end

  def to_json(*args, **arg, &blk); end

  def version_runtime(); end

  def version_runtime=(val); end

  def version_static(); end

  def version_static=(val); end
  STRICTNESSES = ::T.let(nil, ::T.untyped)
end

class Spoom::Coverage::Snapshot
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.from_obj(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::Coverage::SnapshotPrinter
  def print_snapshot(*args, **arg, &blk); end
end

class Spoom::Coverage::SnapshotPrinter
end

class Spoom::Coverage::Template
  def erb(*args, **arg, &blk); end

  def get_binding(*args, **arg, &blk); end

  def html(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end
end

class Spoom::Coverage::Template
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.report(*args, **arg, &blk); end

  def self.sigils_tree(*args, **arg, &blk); end

  def self.snapshot(*args, **arg, &blk); end

  def self.sorbet_config(*args, **arg, &blk); end
end

class Spoom::Error
end

class Spoom::Error
end

class Spoom::ExecResult
  def err(); end

  def exit_code(); end

  def initialize(hash=T.unsafe(nil)); end

  def out(); end

  def status(); end
end

class Spoom::ExecResult
  def self.inherited(s); end
end

class Spoom::FileTree
  def add_path(*args, **arg, &blk); end

  def add_paths(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def nodes(*args, **arg, &blk); end

  def paths(*args, **arg, &blk); end

  def print(*args, **arg, &blk); end

  def roots(*args, **arg, &blk); end

  def strip_prefix(*args, **arg, &blk); end
end

class Spoom::FileTree::Node
  def children(); end

  def initialize(hash=T.unsafe(nil)); end

  def name(); end

  def parent(); end

  def path(*args, **arg, &blk); end
end

class Spoom::FileTree::Node
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(s); end
end

class Spoom::FileTree::TreePrinter
  def print_node(*args, **arg, &blk); end

  def print_nodes(*args, **arg, &blk); end

  def print_tree(*args, **arg, &blk); end

  def tree(*args, **arg, &blk); end
end

class Spoom::FileTree::TreePrinter
end

class Spoom::FileTree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Git
end

module Spoom::Git
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.checkout(*args, **arg, &blk); end

  def self.commit_time(*args, **arg, &blk); end

  def self.commit_timestamp(*args, **arg, &blk); end

  def self.current_branch(*args, **arg, &blk); end

  def self.diff(*args, **arg, &blk); end

  def self.epoch_to_time(*args, **arg, &blk); end

  def self.exec(*args, **arg, &blk); end

  def self.last_commit(*args, **arg, &blk); end

  def self.log(*args, **arg, &blk); end

  def self.rev_parse(*args, **arg, &blk); end

  def self.show(*args, **arg, &blk); end

  def self.sorbet_intro_commit(*args, **arg, &blk); end

  def self.sorbet_removal_commit(*args, **arg, &blk); end

  def self.workdir_clean?(*args, **arg, &blk); end
end

module Spoom::LSP
end

class Spoom::LSP::Client
  def close(*args, **arg, &blk); end

  def definitions(*args, **arg, &blk); end

  def document_symbols(*args, **arg, &blk); end

  def hover(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def next_id(*args, **arg, &blk); end

  def open(*args, **arg, &blk); end

  def read(*args, **arg, &blk); end

  def read_raw(*args, **arg, &blk); end

  def references(*args, **arg, &blk); end

  def send(*args, **arg, &blk); end

  def send_raw(*args, **arg, &blk); end

  def signatures(*args, **arg, &blk); end

  def symbols(*args, **arg, &blk); end

  def type_definitions(*args, **arg, &blk); end
end

class Spoom::LSP::Client
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Diagnostic
  include ::Spoom::LSP::PrintableSymbol
  def code(); end

  def informations(); end

  def initialize(hash=T.unsafe(nil)); end

  def message(); end

  def range(); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::LSP::Diagnostic
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::DocumentSymbol
  include ::Spoom::LSP::PrintableSymbol
  def children(); end

  def detail(); end

  def initialize(hash=T.unsafe(nil)); end

  def kind(); end

  def kind_string(*args, **arg, &blk); end

  def location(); end

  def name(); end

  def range(); end

  def to_s(*args, **arg, &blk); end
  SYMBOL_KINDS = ::T.let(nil, ::T.untyped)
end

class Spoom::LSP::DocumentSymbol
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::Error
end

class Spoom::LSP::Error::AlreadyOpen
end

class Spoom::LSP::Error::AlreadyOpen
end

class Spoom::LSP::Error::BadHeaders
end

class Spoom::LSP::Error::BadHeaders
end

class Spoom::LSP::Error::Diagnostics
  def diagnostics(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def uri(*args, **arg, &blk); end
end

class Spoom::LSP::Error::Diagnostics
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end
end

class Spoom::LSP::Error
end

class Spoom::LSP::Hover
  include ::Spoom::LSP::PrintableSymbol
  def contents(); end

  def initialize(hash=T.unsafe(nil)); end

  def range(); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::LSP::Hover
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::Location
  include ::Spoom::LSP::PrintableSymbol
  def initialize(hash=T.unsafe(nil)); end

  def range(); end

  def to_s(*args, **arg, &blk); end

  def uri(); end
end

class Spoom::LSP::Location
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::Message
  def as_json(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def jsonrpc(*args, **arg, &blk); end

  def to_json(*args, **arg, &blk); end
end

class Spoom::LSP::Message
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Notification
  def method(*args, **arg, &blk); end

  def params(*args, **arg, &blk); end
end

class Spoom::LSP::Notification
end

class Spoom::LSP::Position
  include ::Spoom::LSP::PrintableSymbol
  def char(); end

  def initialize(hash=T.unsafe(nil)); end

  def line(); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::LSP::Position
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

module Spoom::LSP::PrintableSymbol
  def accept_printer(*args, **arg, &blk); end
end

module Spoom::LSP::PrintableSymbol
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Range
  include ::Spoom::LSP::PrintableSymbol
  def end(); end

  def initialize(hash=T.unsafe(nil)); end

  def start(); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::LSP::Range
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::Request
  def id(*args, **arg, &blk); end

  def method(*args, **arg, &blk); end

  def params(*args, **arg, &blk); end
end

class Spoom::LSP::Request
end

class Spoom::LSP::ResponseError
  def code(*args, **arg, &blk); end

  def data(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def message(*args, **arg, &blk); end
end

class Spoom::LSP::ResponseError
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end
end

class Spoom::LSP::SignatureHelp
  include ::Spoom::LSP::PrintableSymbol
  def doc(); end

  def initialize(hash=T.unsafe(nil)); end

  def label(); end

  def params(); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::LSP::SignatureHelp
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_json(*args, **arg, &blk); end

  def self.inherited(s); end
end

class Spoom::LSP::SymbolPrinter
  def clean_uri(*args, **arg, &blk); end

  def prefix(*args, **arg, &blk); end

  def prefix=(prefix); end

  def print_list(*args, **arg, &blk); end

  def print_object(*args, **arg, &blk); end

  def print_objects(*args, **arg, &blk); end

  def seen(*args, **arg, &blk); end

  def seen=(seen); end
end

class Spoom::LSP::SymbolPrinter
end

module Spoom::LSP
end

class Spoom::Printer
  include ::Spoom::Colorize
  def colorize(*args, **arg, &blk); end

  def dedent(*args, **arg, &blk); end

  def indent(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def out(*args, **arg, &blk); end

  def out=(out); end

  def print(*args, **arg, &blk); end

  def print_colored(*args, **arg, &blk); end

  def printl(*args, **arg, &blk); end

  def printn(*args, **arg, &blk); end

  def printt(*args, **arg, &blk); end
end

class Spoom::Printer
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet
  BIN_PATH = ::T.let(nil, ::T.untyped)
  CONFIG_PATH = ::T.let(nil, ::T.untyped)
  GEM_PATH = ::T.let(nil, ::T.untyped)
  SEGFAULT_CODE = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Config
  def allowed_extensions(); end

  def copy(*args, **arg, &blk); end

  def ignore(); end

  def initialize(*args, **arg, &blk); end

  def no_stdlib(*args, **arg, &blk); end

  def no_stdlib=(no_stdlib); end

  def options_string(*args, **arg, &blk); end

  def paths(*args, **arg, &blk); end
end

class Spoom::Sorbet::Config
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.parse_file(*args, **arg, &blk); end

  def self.parse_string(*args, **arg, &blk); end
end

module Spoom::Sorbet::Errors
  DEFAULT_ERROR_URL_BASE = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Errors::Error
  include ::Comparable
  def code(); end

  def file(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def line(*args, **arg, &blk); end

  def message(); end

  def more(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class Spoom::Sorbet::Errors::Error
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Errors::Parser
  def initialize(*args, **arg, &blk); end

  def parse(*args, **arg, &blk); end
  HEADER = ::T.let(nil, ::T.untyped)
end

class Spoom::Sorbet::Errors::Parser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.parse_string(*args, **arg, &blk); end
end

module Spoom::Sorbet::Errors
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.sort_errors_by_code(*args, **arg, &blk); end
end

module Spoom::Sorbet::MetricsParser
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::MetricsParser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.parse_file(*args, **arg, &blk); end

  def self.parse_hash(*args, **arg, &blk); end

  def self.parse_string(*args, **arg, &blk); end
end

module Spoom::Sorbet::Sigils
  SIGIL_REGEXP = ::T.let(nil, ::T.untyped)
  STRICTNESS_FALSE = ::T.let(nil, ::T.untyped)
  STRICTNESS_IGNORE = ::T.let(nil, ::T.untyped)
  STRICTNESS_INTERNAL = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRICT = ::T.let(nil, ::T.untyped)
  STRICTNESS_STRONG = ::T.let(nil, ::T.untyped)
  STRICTNESS_TRUE = ::T.let(nil, ::T.untyped)
  VALID_STRICTNESS = ::T.let(nil, ::T.untyped)
end

module Spoom::Sorbet::Sigils
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.change_sigil_in_file(*args, **arg, &blk); end

  def self.change_sigil_in_files(*args, **arg, &blk); end

  def self.file_strictness(*args, **arg, &blk); end

  def self.files_with_sigil_strictness(*args, **arg, &blk); end

  def self.sigil_string(*args, **arg, &blk); end

  def self.strictness_in_content(*args, **arg, &blk); end

  def self.update_sigil(*args, **arg, &blk); end

  def self.valid_strictness?(*args, **arg, &blk); end
end

module Spoom::Sorbet
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.srb(*args, **arg, &blk); end

  def self.srb_files(*args, **arg, &blk); end

  def self.srb_metrics(*args, **arg, &blk); end

  def self.srb_tc(*args, **arg, &blk); end

  def self.srb_version(*args, **arg, &blk); end

  def self.version_from_gemfile_lock(*args, **arg, &blk); end
end

class Spoom::Timeline
  def commits_for_dates(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def months(*args, **arg, &blk); end

  def ticks(*args, **arg, &blk); end
end

class Spoom::Timeline
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.exec(*args, **arg, &blk); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::Autoload::SassC = SassC

class Sprockets::BabelProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Base
  include ::Sprockets::SourceMapUtils
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Bower
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::MemoryStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::NullStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::ClosureCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::DigestUtils
end

class Sprockets::Context::ENVProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::DigestUtils
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

class Sprockets::JSMincCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Loader
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::ManifestUtils
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::Mime
  include ::Sprockets::Utils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::PathUtils
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::Paths
  include ::Sprockets::Utils
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
end

module Sprockets::ProcessorUtils
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Rails::AssetUrlProcessor
  REGEX = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Rails::SourcemappingUrlProcessor
  REGEX = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
end

class Sprockets::SassCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Server
  ALLOWED_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

module Sprockets::SourceMapUtils
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
end

class Sprockets::UglifierCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Exporting
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Mime
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::DigestUtils
end

class Stable
  def autosave_associated_records_for_user(*args); end
end

class Stable::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stable::GeneratedRelationMethods
end

class Stable::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stable::GeneratedRelationMethods
end

class Stable::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stable::GeneratedRelationMethods
end

module Stable::GeneratedAssociationMethods
  def user_changed?(); end

  def user_previously_changed?(); end
end

module Stable::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Stable::GeneratedRelationMethods
end

module Stable::GeneratedRelationMethods
  extend ::Mutex_m
end

module Stimulus
  VERSION = ::T.let(nil, ::T.untyped)
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def iseuc(); end

  def isjis(); end

  def issjis(); end

  def isutf8(); end

  def kconv(to_enc, from_enc=T.unsafe(nil)); end

  def parse_csv(**options); end

  def shell_split(); end

  def shellescape(); end

  def shellsplit(); end

  def toeuc(); end

  def tojis(); end

  def tolocale(); end

  def tosjis(); end

  def toutf16(); end

  def toutf32(); end

  def toutf8(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

class Struct
  def self.new(*arg); end
end

class SubstitutionContext
  def match(matches, attribute, matcher); end

  def substitute!(selector, values, format_for_presentation=T.unsafe(nil)); end
end

class Symbol
  include ::FriendlyId::UnfriendlyUtils
  def ends_with?(*arg); end

  def name(); end

  def starts_with?(*arg); end
end

class SymbolHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def initialize(symbolize_value=T.unsafe(nil)); end

  def key?(key); end

  def merge(hash); end

  def merge!(hash); end

  def update(hash); end
end

class SymbolHash
  def self.[](*hsh); end
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

module Tapioca
  BINARY_FILE = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_ANNOTATIONS_DIR = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_INDEX_PATH = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_ROOT_URI = ::T.let(nil, ::T.untyped)
  DEFAULT_ANNOTATIONS_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_DSL_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_GEM_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_OVERRIDES = ::T.let(nil, ::T.untyped)
  DEFAULT_POSTREQUIRE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_RBI_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_SHIM_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_TODO_FILE = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  TAPIOCA_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  TAPIOCA_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Temple
  VERSION = ::T.let(nil, ::T.untyped)
end

class Temple::ERB::Engine
end

class Temple::ERB::Engine
end

class Temple::ERB::Parser
  def call(input); end
  ERB_PATTERN = ::T.let(nil, ::T.untyped)
end

class Temple::ERB::Parser
end

class Temple::ERB::Template
end

class Temple::ERB::Template
end

class Temple::ERB::Trimming
end

class Temple::ERB::Trimming
end

class Temple::FilterError
end

class Temple::FilterError
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::Encoding
  def call(s); end
end

class Temple::Filters::Encoding
end

class Temple::Filters::Eraser
  def do?(list, exp); end
end

class Temple::Filters::Eraser
end

class Temple::Filters::Escapable
  def on_dynamic(value); end

  def on_static(value); end
end

class Temple::Filters::Escapable
end

class Temple::Filters::RemoveBOM
  def call(s); end
end

class Temple::Filters::RemoveBOM
end

class Temple::Filters::StaticAnalyzer
  def on_dynamic(code); end
end

class Temple::Filters::StaticAnalyzer
end

class Temple::Filters::StringSplitter
  def on_dynamic(code); end
end

class Temple::Filters::StringSplitter::SyntaxChecker
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker
  def self.syntax_error?(code); end
end

class Temple::Filters::StringSplitter
  def self.compile(code); end
end

class Temple::Filters::Validator
end

class Temple::Filters::Validator
end

class Temple::Generator
  include ::Temple::Utils
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::Options
  def buffer(); end

  def capture_generator(); end

  def concat(str); end

  def create_buffer(); end

  def on(*exp); end

  def on_capture(name, exp); end

  def on_code(code); end

  def on_dynamic(code); end

  def on_multi(*exp); end

  def on_newline(); end

  def on_static(text); end

  def postamble(); end

  def preamble(); end

  def restore_buffer(); end

  def return_buffer(); end

  def save_buffer(); end
end

class Temple::Generator
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

class Temple::Generators::Array
end

class Temple::Generators::Array
end

class Temple::Generators::ArrayBuffer
end

class Temple::Generators::ArrayBuffer
end

class Temple::Generators::ERB
end

class Temple::Generators::ERB
end

class Temple::Generators::RailsOutputBuffer
end

class Temple::Generators::RailsOutputBuffer
end

class Temple::Generators::StringBuffer
end

class Temple::Generators::StringBuffer
end

module Temple::Grammar
  Bool = ::T.let(nil, ::T.untyped)
  Case = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  EmptyExp = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  HTMLAttr = ::T.let(nil, ::T.untyped)
  HTMLIdentifier = ::T.let(nil, ::T.untyped)
end

module Temple::Grammar
  extend ::Temple::Mixins::GrammarDSL
end

class Temple::HTML::AttributeMerger
end

class Temple::HTML::AttributeMerger
end

class Temple::HTML::AttributeRemover
  def on_html_attr(name, value); end
end

class Temple::HTML::AttributeRemover
end

class Temple::HTML::AttributeSorter
end

class Temple::HTML::AttributeSorter
end

module Temple::HTML::Dispatcher
  def on_html_attr(name, content); end

  def on_html_attrs(*attrs); end

  def on_html_comment(content); end

  def on_html_condcomment(condition, content); end

  def on_html_js(content); end

  def on_html_tag(name, attrs, content=T.unsafe(nil)); end
end

module Temple::HTML::Dispatcher
end

class Temple::HTML::Fast
  def on_html_attr(name, value); end

  def on_html_doctype(type); end
  DOCTYPES = ::T.let(nil, ::T.untyped)
  HTML_VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Temple::HTML::Fast
end

class Temple::HTML::Filter
  include ::Temple::HTML::Dispatcher
  def contains_nonempty_static?(exp); end
end

class Temple::HTML::Filter
end

class Temple::HTML::Pretty
  def indent(); end

  def on_dynamic(code); end

  def on_static(content); end

  def preamble(); end

  def tag_indent(name); end
end

class Temple::HTML::Pretty
end

class Temple::InvalidExpression
end

class Temple::InvalidExpression
end

module Temple::Mixins::GrammarDSL
  def ===(exp); end

  def =~(exp); end

  def Rule(rule); end

  def Value(value); end

  def const_missing(name); end

  def extended(mod); end

  def match?(exp); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Element
  def initialize(grammar, rule); end
end

class Temple::Mixins::GrammarDSL::Element
end

class Temple::Mixins::GrammarDSL::Or
  def <<(rule); end

  def after_copy(source); end

  def initialize(grammar, *children); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Or
end

class Temple::Mixins::GrammarDSL::Root
  def initialize(grammar, name); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Root
end

class Temple::Mixins::GrammarDSL::Rule
  def ===(exp); end

  def =~(exp); end

  def copy_to(grammar); end

  def initialize(grammar); end

  def match?(exp); end

  def |(rule); end
end

class Temple::Mixins::GrammarDSL::Rule
end

class Temple::Mixins::GrammarDSL::Value
  def initialize(grammar, value); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Value
end

module Temple::Mixins::GrammarDSL
end

module Temple::Mixins::Template
  include ::Temple::Mixins::ClassOptions
  def compile(code, options); end

  def create(engine, options); end

  def register_as(*names); end
end

module Temple::Mixins::Template
end

class Temple::Parser
  include ::Temple::Utils
  include ::Temple::Mixins::Options
end

class Temple::Parser
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

module Temple::StaticAnalyzer
  DYNAMIC_TOKENS = ::T.let(nil, ::T.untyped)
  STATIC_KEYWORDS = ::T.let(nil, ::T.untyped)
  STATIC_OPERATORS = ::T.let(nil, ::T.untyped)
  STATIC_TOKENS = ::T.let(nil, ::T.untyped)
end

module Temple::Templates
end

class Temple::Templates::Rails
  def call(template, source=T.unsafe(nil)); end

  def supports_streaming?(); end
end

class Temple::Templates::Rails
  extend ::Temple::Mixins::Template
  extend ::Temple::Mixins::ClassOptions
end

class Temple::Templates::Tilt
  def precompiled_template(locals=T.unsafe(nil)); end
end

class Temple::Templates::Tilt
  extend ::Temple::Mixins::Template
  extend ::Temple::Mixins::ClassOptions
  def self.default_mime_type=(mime_type); end
end

module Temple::Templates
  def self.method_missing(name, engine, options=T.unsafe(nil)); end
end

class Terminal::Table
  VERSION = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::AsciiBorder
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::UnicodeBorder
  ALLOWED_SEPARATOR_BORDER_STYLES = ::T.let(nil, ::T.untyped)
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Thor::Actions::CapturableERB
end

class Thor::Actions::CapturableERB
end

module Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Thor::Actions::ClassMethods
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::CreateLink
end

class Thor::Actions::CreateLink
end

class Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Thor::Actions::Directory
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

class Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Thor::Actions::InjectIntoFile
end

module Thor::Actions
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

Thor::Correctable = DidYouMean::Correctable

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Thor::NestedContext
end

class Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Thor::NoKwargSpellChecker
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UndefinedCommandError::SpellChecker
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UnknownArgumentError::SpellChecker
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Thread
  def native_thread_id(); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread::Queue
  def initialize(*arg); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubisTemplate
end

class Tilt::ErubisTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::HamlTemplate
  def precompiled_template(locals); end
end

class Tilt::HamlTemplate
end

class Tilt::KramdownTemplate
  def allows_script?(); end
  DUMB_QUOTES = ::T.let(nil, ::T.untyped)
end

class Tilt::KramdownTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = SassC

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Time
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::FriendlyId::UnfriendlyUtils
end

module Turbo::Broadcastable
  def broadcast_action(action, target: T.unsafe(nil), **rendering); end

  def broadcast_action_later(action:, target: T.unsafe(nil), **rendering); end

  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), **rendering); end

  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), **rendering); end

  def broadcast_after_to(*streamables, target:, **rendering); end

  def broadcast_append(target: T.unsafe(nil), **rendering); end

  def broadcast_append_later(target: T.unsafe(nil), **rendering); end

  def broadcast_append_later_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_append_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_before_to(*streamables, target:, **rendering); end

  def broadcast_prepend(target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_later(target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_later_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_remove(); end

  def broadcast_remove_to(*streamables, target: T.unsafe(nil)); end

  def broadcast_render(**rendering); end

  def broadcast_render_later(**rendering); end

  def broadcast_render_later_to(*streamables, **rendering); end

  def broadcast_render_to(*streamables, **rendering); end

  def broadcast_replace(**rendering); end

  def broadcast_replace_later(**rendering); end

  def broadcast_replace_later_to(*streamables, **rendering); end

  def broadcast_replace_to(*streamables, **rendering); end

  def broadcast_update(**rendering); end

  def broadcast_update_later(**rendering); end

  def broadcast_update_later_to(*streamables, **rendering); end

  def broadcast_update_to(*streamables, **rendering); end
end

module Turbo::DriveHelper
  def turbo_exempts_page_from_cache(); end
end

class Turbo::Engine
  PRECOMPILE_ASSETS = ::T.let(nil, ::T.untyped)
end

module Turbo::FramesHelper
  def turbo_frame_tag(id, src: T.unsafe(nil), target: T.unsafe(nil), **attributes, &block); end
end

module Turbo::IncludesHelper
  def turbo_include_tags(); end
end

class Turbo::Native::NavigationController
  def recede(); end

  def refresh(); end

  def resume(); end
end

class Turbo::Streams::ActionBroadcastJob
  def perform(stream, action:, target:, **rendering); end
end

module Turbo::Streams::ActionHelper
  def turbo_stream_action_tag(action, target: T.unsafe(nil), targets: T.unsafe(nil), template: T.unsafe(nil)); end
end

class Turbo::Streams::BroadcastJob
  def perform(stream, **rendering); end
end

module Turbo::Streams::Broadcasts
  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), **rendering); end

  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), **rendering); end

  def broadcast_after_later_to(*streamables, **opts); end

  def broadcast_after_to(*streamables, **opts); end

  def broadcast_append_later_to(*streamables, **opts); end

  def broadcast_append_to(*streamables, **opts); end

  def broadcast_before_later_to(*streamables, **opts); end

  def broadcast_before_to(*streamables, **opts); end

  def broadcast_prepend_later_to(*streamables, **opts); end

  def broadcast_prepend_to(*streamables, **opts); end

  def broadcast_remove_to(*streamables, **opts); end

  def broadcast_render_later_to(*streamables, **rendering); end

  def broadcast_render_to(*streamables, **rendering); end

  def broadcast_replace_later_to(*streamables, **opts); end

  def broadcast_replace_to(*streamables, **opts); end

  def broadcast_stream_to(*streamables, content:); end

  def broadcast_update_later_to(*streamables, **opts); end

  def broadcast_update_to(*streamables, **opts); end
end

module Turbo::Streams::StreamName
  def signed_stream_name(streamables); end

  def verified_stream_name(signed_stream_name); end
end

module Turbo::Streams::StreamName::ClassMethods
  def verified_stream_name_from_params(); end
end

class Turbo::Streams::TagBuilder
  def action(name, target, content=T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end

  def action_all(name, targets, content=T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end

  def after(target, content=T.unsafe(nil), **rendering, &block); end

  def after_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def append(target, content=T.unsafe(nil), **rendering, &block); end

  def append_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def before(target, content=T.unsafe(nil), **rendering, &block); end

  def before_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def initialize(view_context); end

  def prepend(target, content=T.unsafe(nil), **rendering, &block); end

  def prepend_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def remove(target); end

  def remove_all(targets); end

  def replace(target, content=T.unsafe(nil), **rendering, &block); end

  def replace_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def update(target, content=T.unsafe(nil), **rendering, &block); end

  def update_all(targets, content=T.unsafe(nil), **rendering, &block); end
end

class Turbo::StreamsChannel
  extend ::Turbo::Streams::StreamName
end

module Turbo::StreamsHelper
  def turbo_stream(); end

  def turbo_stream_from(*streamables, **attributes); end
end

module TypeCoerce::Configuration
  extend ::T::Private::Methods::SingletonMethodHooks
end

class TypeCoerce::Converter
  PRIMITIVE_TYPES = ::T.let(nil, ::T.untyped)
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::HTTP
  def authority(); end

  def buffer_open(buf, proxy, options); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WS
end

module URI
  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.open(name, *rest, &block); end

  def self.register_scheme(scheme, klass); end
end

class UnboundMethod
  def private?(); end

  def protected?(); end

  def public?(); end
end

module Undercover
  VERSION = ::T.let(nil, ::T.untyped)
end

module Undercover::CLI
  WARNINGS_TO_S = ::T.let(nil, ::T.untyped)
end

module Undercover::CLI
  def self.changeset(opts); end

  def self.run(args); end

  def self.run_report(opts); end

  def self.syntax_version(version); end
end

class Undercover::Changeset
  def each(*args, **arg, &block); end

  def each_changed_line(); end

  def file_paths(); end

  def files(); end

  def initialize(dir, compare_base=T.unsafe(nil)); end

  def last_modified(); end

  def update(); end

  def validate(lcov_report_path); end
  T_ZERO = ::T.let(nil, ::T.untyped)
end

class Undercover::Formatter
  def initialize(results); end
end

class Undercover::LcovParser
  def coverage(filepath); end

  def initialize(lcov_io); end

  def io(); end

  def parse(); end

  def source_files(); end
end

class Undercover::LcovParser
  def self.parse(lcov_report_path); end
end

class Undercover::Options
  def compare(); end

  def compare=(compare); end

  def git_dir(); end

  def git_dir=(git_dir); end

  def lcov(); end

  def lcov=(lcov); end

  def parse(args); end

  def path(); end

  def path=(path); end

  def syntax_version(); end

  def syntax_version=(syntax_version); end
  OUTPUT_FORMATTERS = ::T.let(nil, ::T.untyped)
  OUTPUT_STDOUT = ::T.let(nil, ::T.untyped)
  RUN_MODE = ::T.let(nil, ::T.untyped)
  RUN_MODE_DIFF_STRICT = ::T.let(nil, ::T.untyped)
end

class Undercover::Report
  def all_results(); end

  def build(); end

  def build_warnings(); end

  def changeset(); end

  def code_dir(); end

  def flagged_results(); end

  def initialize(changeset, opts); end

  def lcov(); end

  def results(); end

  def validate(*args, **arg, &block); end
end

class Undercover::Result
  def coverage(); end

  def coverage_f(); end

  def file_path(); end

  def file_path_with_lines(); end

  def first_line(*args, **arg, &block); end

  def flag(); end

  def flagged?(); end

  def initialize(node, file_cov, file_path); end

  def last_line(*args, **arg, &block); end

  def name(*args, **arg, &block); end

  def node(); end

  def pretty_print(); end

  def pretty_print_lines(); end

  def uncovered?(line_no); end
end

class Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
  ACCENTS = ::T.let(nil, ::T.untyped)
  CLASS_TABLE = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  DECOMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  KOMPATIBLE_TABLE = ::T.let(nil, ::T.untyped)
  LBASE = ::T.let(nil, ::T.untyped)
  LCOUNT = ::T.let(nil, ::T.untyped)
  MAX_HASH_LENGTH = ::T.let(nil, ::T.untyped)
  NCOUNT = ::T.let(nil, ::T.untyped)
  NF_HASH_C = ::T.let(nil, ::T.untyped)
  NF_HASH_D = ::T.let(nil, ::T.untyped)
  REGEXP_C = ::T.let(nil, ::T.untyped)
  REGEXP_C_STRING = ::T.let(nil, ::T.untyped)
  REGEXP_D = ::T.let(nil, ::T.untyped)
  REGEXP_D_STRING = ::T.let(nil, ::T.untyped)
  REGEXP_K = ::T.let(nil, ::T.untyped)
  REGEXP_K_STRING = ::T.let(nil, ::T.untyped)
  SBASE = ::T.let(nil, ::T.untyped)
  SCOUNT = ::T.let(nil, ::T.untyped)
  TBASE = ::T.let(nil, ::T.untyped)
  TCOUNT = ::T.let(nil, ::T.untyped)
  UNICODE_ENCODINGS = ::T.let(nil, ::T.untyped)
  VBASE = ::T.let(nil, ::T.untyped)
  VCOUNT = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
  def self.canonical_ordering_one(string); end

  def self.hangul_comp_one(string); end

  def self.hangul_decomp_one(target); end

  def self.nfc_one(string); end

  def self.nfd_one(string); end

  def self.normalize(string, form=T.unsafe(nil)); end

  def self.normalized?(string, form=T.unsafe(nil)); end
end

class UniformNotifier
  AVAILABLE_NOTIFIERS = ::T.let(nil, ::T.untyped)
  NOTIFIERS = ::T.let(nil, ::T.untyped)
end

class UniformNotifier::RollbarNotifier
  DEFAULT_LEVEL = ::T.let(nil, ::T.untyped)
end

class UniformNotifier::Slack
  POSSIBLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class User
  include ::User::GeneratedAttributeMethods
  include ::User::GeneratedAssociationMethods
  include ::FriendlyId::Reserved
  include ::FriendlyId::Model
  include ::FriendlyId::Slugged
  include ::Devise::Models::Authenticatable
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
  include ::Devise::Models::DatabaseAuthenticatable
  include ::Devise::Models::Rememberable
  include ::Devise::Models::Recoverable
  include ::Devise::Models::Registerable
  include ::Devise::Models::Validatable
  include ::Devise::Models::Confirmable
  include ::Devise::Models::Lockable
  include ::Devise::Models::Timeoutable
  include ::Devise::Models::Trackable
  def autosave_associated_records_for_stable(*args); end

  def current_password(); end

  def devise_modules(); end

  def devise_modules?(); end

  def password(); end

  def password_confirmation(); end

  def password_confirmation=(password_confirmation); end

  def typed_status(); end

  def typed_status=(value); end

  def validate_associated_records_for_stable(*args); end
  RelationType = ::T.let(nil, ::T.untyped)
end

class User::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

class User::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

class User::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

module User::GeneratedAssociationMethods
  def build_stable(*args, &block); end

  def create_stable(*args, &block); end

  def create_stable!(*args, &block); end

  def reload_stable(); end

  def stable(); end

  def stable=(value); end

  def stable_attributes=(attributes); end
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAttributeMethods
  def admin(); end

  def admin=(value); end

  def admin?(); end

  def admin_before_last_save(); end

  def admin_before_type_cast(); end

  def admin_came_from_user?(); end

  def admin_change(); end

  def admin_change_to_be_saved(); end

  def admin_changed?(**options); end

  def admin_for_database(); end

  def admin_in_database(); end

  def admin_previous_change(); end

  def admin_previously_changed?(**options); end

  def admin_previously_was(); end

  def admin_was(); end

  def admin_will_change!(); end

  def clear_admin_change(); end

  def clear_confirmation_sent_at_change(); end

  def clear_confirmation_token_change(); end

  def clear_confirmed_at_change(); end

  def clear_created_at_change(); end

  def clear_current_sign_in_at_change(); end

  def clear_current_sign_in_ip_change(); end

  def clear_discourse_id_change(); end

  def clear_email_change(); end

  def clear_encrypted_password_change(); end

  def clear_failed_attempts_change(); end

  def clear_id_change(); end

  def clear_last_sign_in_at_change(); end

  def clear_last_sign_in_ip_change(); end

  def clear_locked_at_change(); end

  def clear_name_change(); end

  def clear_remember_created_at_change(); end

  def clear_reset_password_sent_at_change(); end

  def clear_reset_password_token_change(); end

  def clear_sign_in_count_change(); end

  def clear_slug_change(); end

  def clear_status_change(); end

  def clear_unconfirmed_email_change(); end

  def clear_unlock_token_change(); end

  def clear_updated_at_change(); end

  def clear_username_change(); end

  def confirmation_sent_at(); end

  def confirmation_sent_at=(value); end

  def confirmation_sent_at?(); end

  def confirmation_sent_at_before_last_save(); end

  def confirmation_sent_at_before_type_cast(); end

  def confirmation_sent_at_came_from_user?(); end

  def confirmation_sent_at_change(); end

  def confirmation_sent_at_change_to_be_saved(); end

  def confirmation_sent_at_changed?(**options); end

  def confirmation_sent_at_for_database(); end

  def confirmation_sent_at_in_database(); end

  def confirmation_sent_at_previous_change(); end

  def confirmation_sent_at_previously_changed?(**options); end

  def confirmation_sent_at_previously_was(); end

  def confirmation_sent_at_was(); end

  def confirmation_sent_at_will_change!(); end

  def confirmation_token(); end

  def confirmation_token=(value); end

  def confirmation_token?(); end

  def confirmation_token_before_last_save(); end

  def confirmation_token_before_type_cast(); end

  def confirmation_token_came_from_user?(); end

  def confirmation_token_change(); end

  def confirmation_token_change_to_be_saved(); end

  def confirmation_token_changed?(**options); end

  def confirmation_token_for_database(); end

  def confirmation_token_in_database(); end

  def confirmation_token_previous_change(); end

  def confirmation_token_previously_changed?(**options); end

  def confirmation_token_previously_was(); end

  def confirmation_token_was(); end

  def confirmation_token_will_change!(); end

  def confirmed_at(); end

  def confirmed_at=(value); end

  def confirmed_at?(); end

  def confirmed_at_before_last_save(); end

  def confirmed_at_before_type_cast(); end

  def confirmed_at_came_from_user?(); end

  def confirmed_at_change(); end

  def confirmed_at_change_to_be_saved(); end

  def confirmed_at_changed?(**options); end

  def confirmed_at_for_database(); end

  def confirmed_at_in_database(); end

  def confirmed_at_previous_change(); end

  def confirmed_at_previously_changed?(**options); end

  def confirmed_at_previously_was(); end

  def confirmed_at_was(); end

  def confirmed_at_will_change!(); end

  def created_at(); end

  def created_at=(value); end

  def created_at?(); end

  def created_at_before_last_save(); end

  def created_at_before_type_cast(); end

  def created_at_came_from_user?(); end

  def created_at_change(); end

  def created_at_change_to_be_saved(); end

  def created_at_changed?(**options); end

  def created_at_for_database(); end

  def created_at_in_database(); end

  def created_at_previous_change(); end

  def created_at_previously_changed?(**options); end

  def created_at_previously_was(); end

  def created_at_was(); end

  def created_at_will_change!(); end

  def current_sign_in_at(); end

  def current_sign_in_at=(value); end

  def current_sign_in_at?(); end

  def current_sign_in_at_before_last_save(); end

  def current_sign_in_at_before_type_cast(); end

  def current_sign_in_at_came_from_user?(); end

  def current_sign_in_at_change(); end

  def current_sign_in_at_change_to_be_saved(); end

  def current_sign_in_at_changed?(**options); end

  def current_sign_in_at_for_database(); end

  def current_sign_in_at_in_database(); end

  def current_sign_in_at_previous_change(); end

  def current_sign_in_at_previously_changed?(**options); end

  def current_sign_in_at_previously_was(); end

  def current_sign_in_at_was(); end

  def current_sign_in_at_will_change!(); end

  def current_sign_in_ip(); end

  def current_sign_in_ip=(value); end

  def current_sign_in_ip?(); end

  def current_sign_in_ip_before_last_save(); end

  def current_sign_in_ip_before_type_cast(); end

  def current_sign_in_ip_came_from_user?(); end

  def current_sign_in_ip_change(); end

  def current_sign_in_ip_change_to_be_saved(); end

  def current_sign_in_ip_changed?(**options); end

  def current_sign_in_ip_for_database(); end

  def current_sign_in_ip_in_database(); end

  def current_sign_in_ip_previous_change(); end

  def current_sign_in_ip_previously_changed?(**options); end

  def current_sign_in_ip_previously_was(); end

  def current_sign_in_ip_was(); end

  def current_sign_in_ip_will_change!(); end

  def discourse_id(); end

  def discourse_id=(value); end

  def discourse_id?(); end

  def discourse_id_before_last_save(); end

  def discourse_id_before_type_cast(); end

  def discourse_id_came_from_user?(); end

  def discourse_id_change(); end

  def discourse_id_change_to_be_saved(); end

  def discourse_id_changed?(**options); end

  def discourse_id_for_database(); end

  def discourse_id_in_database(); end

  def discourse_id_previous_change(); end

  def discourse_id_previously_changed?(**options); end

  def discourse_id_previously_was(); end

  def discourse_id_was(); end

  def discourse_id_will_change!(); end

  def email(); end

  def email=(value); end

  def email?(); end

  def email_before_last_save(); end

  def email_before_type_cast(); end

  def email_came_from_user?(); end

  def email_change(); end

  def email_change_to_be_saved(); end

  def email_changed?(**options); end

  def email_for_database(); end

  def email_in_database(); end

  def email_previous_change(); end

  def email_previously_changed?(**options); end

  def email_previously_was(); end

  def email_was(); end

  def email_will_change!(); end

  def encrypted_password(); end

  def encrypted_password=(value); end

  def encrypted_password?(); end

  def encrypted_password_before_last_save(); end

  def encrypted_password_before_type_cast(); end

  def encrypted_password_came_from_user?(); end

  def encrypted_password_change(); end

  def encrypted_password_change_to_be_saved(); end

  def encrypted_password_changed?(**options); end

  def encrypted_password_for_database(); end

  def encrypted_password_in_database(); end

  def encrypted_password_previous_change(); end

  def encrypted_password_previously_changed?(**options); end

  def encrypted_password_previously_was(); end

  def encrypted_password_was(); end

  def encrypted_password_will_change!(); end

  def failed_attempts(); end

  def failed_attempts=(value); end

  def failed_attempts?(); end

  def failed_attempts_before_last_save(); end

  def failed_attempts_before_type_cast(); end

  def failed_attempts_came_from_user?(); end

  def failed_attempts_change(); end

  def failed_attempts_change_to_be_saved(); end

  def failed_attempts_changed?(**options); end

  def failed_attempts_for_database(); end

  def failed_attempts_in_database(); end

  def failed_attempts_previous_change(); end

  def failed_attempts_previously_changed?(**options); end

  def failed_attempts_previously_was(); end

  def failed_attempts_was(); end

  def failed_attempts_will_change!(); end

  def id_before_last_save(); end

  def id_came_from_user?(); end

  def id_change(); end

  def id_change_to_be_saved(); end

  def id_changed?(**options); end

  def id_previous_change(); end

  def id_previously_changed?(**options); end

  def id_previously_was(); end

  def id_will_change!(); end

  def last_sign_in_at(); end

  def last_sign_in_at=(value); end

  def last_sign_in_at?(); end

  def last_sign_in_at_before_last_save(); end

  def last_sign_in_at_before_type_cast(); end

  def last_sign_in_at_came_from_user?(); end

  def last_sign_in_at_change(); end

  def last_sign_in_at_change_to_be_saved(); end

  def last_sign_in_at_changed?(**options); end

  def last_sign_in_at_for_database(); end

  def last_sign_in_at_in_database(); end

  def last_sign_in_at_previous_change(); end

  def last_sign_in_at_previously_changed?(**options); end

  def last_sign_in_at_previously_was(); end

  def last_sign_in_at_was(); end

  def last_sign_in_at_will_change!(); end

  def last_sign_in_ip(); end

  def last_sign_in_ip=(value); end

  def last_sign_in_ip?(); end

  def last_sign_in_ip_before_last_save(); end

  def last_sign_in_ip_before_type_cast(); end

  def last_sign_in_ip_came_from_user?(); end

  def last_sign_in_ip_change(); end

  def last_sign_in_ip_change_to_be_saved(); end

  def last_sign_in_ip_changed?(**options); end

  def last_sign_in_ip_for_database(); end

  def last_sign_in_ip_in_database(); end

  def last_sign_in_ip_previous_change(); end

  def last_sign_in_ip_previously_changed?(**options); end

  def last_sign_in_ip_previously_was(); end

  def last_sign_in_ip_was(); end

  def last_sign_in_ip_will_change!(); end

  def locked_at(); end

  def locked_at=(value); end

  def locked_at?(); end

  def locked_at_before_last_save(); end

  def locked_at_before_type_cast(); end

  def locked_at_came_from_user?(); end

  def locked_at_change(); end

  def locked_at_change_to_be_saved(); end

  def locked_at_changed?(**options); end

  def locked_at_for_database(); end

  def locked_at_in_database(); end

  def locked_at_previous_change(); end

  def locked_at_previously_changed?(**options); end

  def locked_at_previously_was(); end

  def locked_at_was(); end

  def locked_at_will_change!(); end

  def name(); end

  def name=(value); end

  def name?(); end

  def name_before_last_save(); end

  def name_before_type_cast(); end

  def name_came_from_user?(); end

  def name_change(); end

  def name_change_to_be_saved(); end

  def name_changed?(**options); end

  def name_for_database(); end

  def name_in_database(); end

  def name_previous_change(); end

  def name_previously_changed?(**options); end

  def name_previously_was(); end

  def name_was(); end

  def name_will_change!(); end

  def remember_created_at(); end

  def remember_created_at=(value); end

  def remember_created_at?(); end

  def remember_created_at_before_last_save(); end

  def remember_created_at_before_type_cast(); end

  def remember_created_at_came_from_user?(); end

  def remember_created_at_change(); end

  def remember_created_at_change_to_be_saved(); end

  def remember_created_at_changed?(**options); end

  def remember_created_at_for_database(); end

  def remember_created_at_in_database(); end

  def remember_created_at_previous_change(); end

  def remember_created_at_previously_changed?(**options); end

  def remember_created_at_previously_was(); end

  def remember_created_at_was(); end

  def remember_created_at_will_change!(); end

  def reset_password_sent_at(); end

  def reset_password_sent_at=(value); end

  def reset_password_sent_at?(); end

  def reset_password_sent_at_before_last_save(); end

  def reset_password_sent_at_before_type_cast(); end

  def reset_password_sent_at_came_from_user?(); end

  def reset_password_sent_at_change(); end

  def reset_password_sent_at_change_to_be_saved(); end

  def reset_password_sent_at_changed?(**options); end

  def reset_password_sent_at_for_database(); end

  def reset_password_sent_at_in_database(); end

  def reset_password_sent_at_previous_change(); end

  def reset_password_sent_at_previously_changed?(**options); end

  def reset_password_sent_at_previously_was(); end

  def reset_password_sent_at_was(); end

  def reset_password_sent_at_will_change!(); end

  def reset_password_token(); end

  def reset_password_token=(value); end

  def reset_password_token?(); end

  def reset_password_token_before_last_save(); end

  def reset_password_token_before_type_cast(); end

  def reset_password_token_came_from_user?(); end

  def reset_password_token_change(); end

  def reset_password_token_change_to_be_saved(); end

  def reset_password_token_changed?(**options); end

  def reset_password_token_for_database(); end

  def reset_password_token_in_database(); end

  def reset_password_token_previous_change(); end

  def reset_password_token_previously_changed?(**options); end

  def reset_password_token_previously_was(); end

  def reset_password_token_was(); end

  def reset_password_token_will_change!(); end

  def restore_admin!(); end

  def restore_confirmation_sent_at!(); end

  def restore_confirmation_token!(); end

  def restore_confirmed_at!(); end

  def restore_created_at!(); end

  def restore_current_sign_in_at!(); end

  def restore_current_sign_in_ip!(); end

  def restore_discourse_id!(); end

  def restore_email!(); end

  def restore_encrypted_password!(); end

  def restore_failed_attempts!(); end

  def restore_id!(); end

  def restore_last_sign_in_at!(); end

  def restore_last_sign_in_ip!(); end

  def restore_locked_at!(); end

  def restore_name!(); end

  def restore_remember_created_at!(); end

  def restore_reset_password_sent_at!(); end

  def restore_reset_password_token!(); end

  def restore_sign_in_count!(); end

  def restore_slug!(); end

  def restore_status!(); end

  def restore_unconfirmed_email!(); end

  def restore_unlock_token!(); end

  def restore_updated_at!(); end

  def restore_username!(); end

  def saved_change_to_admin(); end

  def saved_change_to_admin?(**options); end

  def saved_change_to_confirmation_sent_at(); end

  def saved_change_to_confirmation_sent_at?(**options); end

  def saved_change_to_confirmation_token(); end

  def saved_change_to_confirmation_token?(**options); end

  def saved_change_to_confirmed_at(); end

  def saved_change_to_confirmed_at?(**options); end

  def saved_change_to_created_at(); end

  def saved_change_to_created_at?(**options); end

  def saved_change_to_current_sign_in_at(); end

  def saved_change_to_current_sign_in_at?(**options); end

  def saved_change_to_current_sign_in_ip(); end

  def saved_change_to_current_sign_in_ip?(**options); end

  def saved_change_to_discourse_id(); end

  def saved_change_to_discourse_id?(**options); end

  def saved_change_to_email(); end

  def saved_change_to_email?(**options); end

  def saved_change_to_encrypted_password(); end

  def saved_change_to_encrypted_password?(**options); end

  def saved_change_to_failed_attempts(); end

  def saved_change_to_failed_attempts?(**options); end

  def saved_change_to_id(); end

  def saved_change_to_id?(**options); end

  def saved_change_to_last_sign_in_at(); end

  def saved_change_to_last_sign_in_at?(**options); end

  def saved_change_to_last_sign_in_ip(); end

  def saved_change_to_last_sign_in_ip?(**options); end

  def saved_change_to_locked_at(); end

  def saved_change_to_locked_at?(**options); end

  def saved_change_to_name(); end

  def saved_change_to_name?(**options); end

  def saved_change_to_remember_created_at(); end

  def saved_change_to_remember_created_at?(**options); end

  def saved_change_to_reset_password_sent_at(); end

  def saved_change_to_reset_password_sent_at?(**options); end

  def saved_change_to_reset_password_token(); end

  def saved_change_to_reset_password_token?(**options); end

  def saved_change_to_sign_in_count(); end

  def saved_change_to_sign_in_count?(**options); end

  def saved_change_to_slug(); end

  def saved_change_to_slug?(**options); end

  def saved_change_to_status(); end

  def saved_change_to_status?(**options); end

  def saved_change_to_unconfirmed_email(); end

  def saved_change_to_unconfirmed_email?(**options); end

  def saved_change_to_unlock_token(); end

  def saved_change_to_unlock_token?(**options); end

  def saved_change_to_updated_at(); end

  def saved_change_to_updated_at?(**options); end

  def saved_change_to_username(); end

  def saved_change_to_username?(**options); end

  def sign_in_count(); end

  def sign_in_count=(value); end

  def sign_in_count?(); end

  def sign_in_count_before_last_save(); end

  def sign_in_count_before_type_cast(); end

  def sign_in_count_came_from_user?(); end

  def sign_in_count_change(); end

  def sign_in_count_change_to_be_saved(); end

  def sign_in_count_changed?(**options); end

  def sign_in_count_for_database(); end

  def sign_in_count_in_database(); end

  def sign_in_count_previous_change(); end

  def sign_in_count_previously_changed?(**options); end

  def sign_in_count_previously_was(); end

  def sign_in_count_was(); end

  def sign_in_count_will_change!(); end

  def slug(); end

  def slug=(value); end

  def slug?(); end

  def slug_before_last_save(); end

  def slug_before_type_cast(); end

  def slug_came_from_user?(); end

  def slug_change(); end

  def slug_change_to_be_saved(); end

  def slug_changed?(**options); end

  def slug_for_database(); end

  def slug_in_database(); end

  def slug_previous_change(); end

  def slug_previously_changed?(**options); end

  def slug_previously_was(); end

  def slug_was(); end

  def slug_will_change!(); end

  def status(); end

  def status=(value); end

  def status?(); end

  def status_before_last_save(); end

  def status_before_type_cast(); end

  def status_came_from_user?(); end

  def status_change(); end

  def status_change_to_be_saved(); end

  def status_changed?(**options); end

  def status_for_database(); end

  def status_in_database(); end

  def status_previous_change(); end

  def status_previously_changed?(**options); end

  def status_previously_was(); end

  def status_was(); end

  def status_will_change!(); end

  def unconfirmed_email(); end

  def unconfirmed_email=(value); end

  def unconfirmed_email?(); end

  def unconfirmed_email_before_last_save(); end

  def unconfirmed_email_before_type_cast(); end

  def unconfirmed_email_came_from_user?(); end

  def unconfirmed_email_change(); end

  def unconfirmed_email_change_to_be_saved(); end

  def unconfirmed_email_changed?(**options); end

  def unconfirmed_email_for_database(); end

  def unconfirmed_email_in_database(); end

  def unconfirmed_email_previous_change(); end

  def unconfirmed_email_previously_changed?(**options); end

  def unconfirmed_email_previously_was(); end

  def unconfirmed_email_was(); end

  def unconfirmed_email_will_change!(); end

  def unlock_token(); end

  def unlock_token=(value); end

  def unlock_token?(); end

  def unlock_token_before_last_save(); end

  def unlock_token_before_type_cast(); end

  def unlock_token_came_from_user?(); end

  def unlock_token_change(); end

  def unlock_token_change_to_be_saved(); end

  def unlock_token_changed?(**options); end

  def unlock_token_for_database(); end

  def unlock_token_in_database(); end

  def unlock_token_previous_change(); end

  def unlock_token_previously_changed?(**options); end

  def unlock_token_previously_was(); end

  def unlock_token_was(); end

  def unlock_token_will_change!(); end

  def updated_at(); end

  def updated_at=(value); end

  def updated_at?(); end

  def updated_at_before_last_save(); end

  def updated_at_before_type_cast(); end

  def updated_at_came_from_user?(); end

  def updated_at_change(); end

  def updated_at_change_to_be_saved(); end

  def updated_at_changed?(**options); end

  def updated_at_for_database(); end

  def updated_at_in_database(); end

  def updated_at_previous_change(); end

  def updated_at_previously_changed?(**options); end

  def updated_at_previously_was(); end

  def updated_at_was(); end

  def updated_at_will_change!(); end

  def username(); end

  def username=(value); end

  def username?(); end

  def username_before_last_save(); end

  def username_before_type_cast(); end

  def username_came_from_user?(); end

  def username_change(); end

  def username_change_to_be_saved(); end

  def username_changed?(**options); end

  def username_for_database(); end

  def username_in_database(); end

  def username_previous_change(); end

  def username_previously_changed?(**options); end

  def username_previously_was(); end

  def username_was(); end

  def username_will_change!(); end

  def will_save_change_to_admin?(**options); end

  def will_save_change_to_confirmation_sent_at?(**options); end

  def will_save_change_to_confirmation_token?(**options); end

  def will_save_change_to_confirmed_at?(**options); end

  def will_save_change_to_created_at?(**options); end

  def will_save_change_to_current_sign_in_at?(**options); end

  def will_save_change_to_current_sign_in_ip?(**options); end

  def will_save_change_to_discourse_id?(**options); end

  def will_save_change_to_email?(**options); end

  def will_save_change_to_encrypted_password?(**options); end

  def will_save_change_to_failed_attempts?(**options); end

  def will_save_change_to_id?(**options); end

  def will_save_change_to_last_sign_in_at?(**options); end

  def will_save_change_to_last_sign_in_ip?(**options); end

  def will_save_change_to_locked_at?(**options); end

  def will_save_change_to_name?(**options); end

  def will_save_change_to_remember_created_at?(**options); end

  def will_save_change_to_reset_password_sent_at?(**options); end

  def will_save_change_to_reset_password_token?(**options); end

  def will_save_change_to_sign_in_count?(**options); end

  def will_save_change_to_slug?(**options); end

  def will_save_change_to_status?(**options); end

  def will_save_change_to_unconfirmed_email?(**options); end

  def will_save_change_to_unlock_token?(**options); end

  def will_save_change_to_updated_at?(**options); end

  def will_save_change_to_username?(**options); end
end

module User::GeneratedAttributeMethods
  extend ::Mutex_m
end

module User::GeneratedRelationMethods
  def friendly(*arg, **arg1, &arg2); end

  def friendly_id_config(*arg, **arg1, &arg2); end

  def name(*arg, **arg1, &arg2); end

  def ordered(*arg, **arg1, &arg2); end
end

module User::GeneratedRelationMethods
  extend ::Mutex_m
end

class User::Status
  Active = ::T.let(nil, ::T.untyped)
  Banned = ::T.let(nil, ::T.untyped)
  Deleted = ::T.let(nil, ::T.untyped)
  Pending = ::T.let(nil, ::T.untyped)
end

class User::Status
  extend ::T::Helpers
end

class User
  extend ::FriendlyId
  extend ::FriendlyId::Base
  extend ::Devise::Models::Authenticatable::ClassMethods
  extend ::Devise::Models::DatabaseAuthenticatable::ClassMethods
  extend ::Devise::Models::Rememberable::ClassMethods
  extend ::Devise::Models::Recoverable::ClassMethods
  extend ::Devise::Models::Registerable::ClassMethods
  extend ::Devise::Models::Validatable::ClassMethods
  extend ::Devise::Models::Confirmable::ClassMethods
  extend ::Devise::Models::Lockable::ClassMethods
  extend ::Devise::Models::Timeoutable::ClassMethods
  def self.devise_modules(); end

  def self.devise_modules=(value); end

  def self.devise_modules?(); end
end

class Vector
  def [](i); end

  def []=(i, v); end

  def collect!(&block); end

  def covector(); end

  def elements(); end

  def initialize(array); end

  def map!(&block); end
end

module ViewComponent
  DEPRECATION_HORIZON = ::T.let(nil, ::T.untyped)
  Deprecation = ::T.let(nil, ::T.untyped)
end

class ViewComponent::Base
  include ::ActiveSupport::Configurable
  include ::ViewComponent::ContentAreas
  include ::ViewComponent::Previewable
  include ::ViewComponent::SlotableV2
  include ::ViewComponent::Translatable
  include ::ViewComponent::WithContentHelper
  def __vc_original_view_context(); end

  def __vc_original_view_context=(__vc_original_view_context); end

  def _output_postamble(); end

  def before_render(); end

  def before_render_check(); end

  def component_parent_class(); end

  def config(*arg, **arg1, &arg2); end

  def content_areas(); end

  def content_areas=(content_areas); end

  def content_areas?(); end

  def default_preview_layout(); end

  def form_authenticity_token(*arg, **arg1, &arg2); end

  def format(); end

  def generate(); end

  def helpers(); end

  def i18n_backend(); end

  def initialize(*arg); end

  def perform_render(); end

  def preview_controller(); end

  def preview_path(); end

  def preview_paths(); end

  def preview_route(); end

  def protect_against_forgery?(*arg, **arg1, &arg2); end

  def registered_slots(); end

  def registered_slots=(registered_slots); end

  def registered_slots?(); end

  def render(options=T.unsafe(nil), args=T.unsafe(nil), &block); end

  def render?(); end

  def render_in(view_context, &block); end

  def render_monkey_patch_enabled(); end

  def render_parent(); end

  def render_template_for(variant=T.unsafe(nil)); end

  def show_previews(); end

  def show_previews_source(); end

  def test_controller(); end

  def test_controller=(val); end

  def view_cache_dependencies(); end

  def view_component_path(); end

  def virtual_path(); end

  def with_variant(*args, **arg, &block); end
  RESERVED_PARAMETER = ::T.let(nil, ::T.untyped)
end

class ViewComponent::Base
  def self._after_compile(); end

  def self._deprecated_generate_mattr_accessor(name); end

  def self._sidecar_files(extensions); end

  def self.collection_counter_parameter(); end

  def self.collection_iteration_parameter(); end

  def self.collection_parameter(); end

  def self.compile(raise_errors: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.compiled?(); end

  def self.compiler(); end

  def self.component_parent_class(); end

  def self.component_parent_class=(val); end

  def self.content_areas(); end

  def self.content_areas=(value); end

  def self.content_areas?(); end

  def self.counter_argument_present?(); end

  def self.default_preview_layout(); end

  def self.default_preview_layout=(val); end

  def self.format(); end

  def self.generate(); end

  def self.generate=(val); end

  def self.generate_distinct_locale_files(); end

  def self.generate_distinct_locale_files=(value); end

  def self.generate_locale(); end

  def self.generate_locale=(value); end

  def self.generate_sidecar(); end

  def self.generate_sidecar=(value); end

  def self.generate_stimulus_controller(); end

  def self.generate_stimulus_controller=(value); end

  def self.i18n_backend(); end

  def self.i18n_backend=(value); end

  def self.identifier(); end

  def self.iteration_argument_present?(); end

  def self.preview_controller(); end

  def self.preview_controller=(val); end

  def self.preview_path(); end

  def self.preview_path=(val); end

  def self.preview_paths(); end

  def self.preview_paths=(val); end

  def self.preview_route(); end

  def self.preview_route=(val); end

  def self.registered_slots(); end

  def self.registered_slots=(value); end

  def self.registered_slots?(); end

  def self.render_monkey_patch_enabled(); end

  def self.render_monkey_patch_enabled=(val); end

  def self.short_identifier(); end

  def self.show_previews(); end

  def self.show_previews=(val); end

  def self.show_previews_source(); end

  def self.show_previews_source=(val); end

  def self.source_location(); end

  def self.source_location=(source_location); end

  def self.test_controller(); end

  def self.test_controller=(val); end

  def self.type(); end

  def self.validate_collection_parameter!(validate_default: T.unsafe(nil)); end

  def self.validate_initialization_parameters!(); end

  def self.view_component_path(); end

  def self.view_component_path=(val); end

  def self.virtual_path(); end

  def self.virtual_path=(virtual_path); end

  def self.with_collection(collection, **args); end

  def self.with_collection_parameter(parameter); end
end

class ViewComponent::Collection
  include ::Enumerable
  def component(); end

  def components(); end

  def each(&block); end

  def format(*arg, **arg1, &arg2); end

  def initialize(component, object, **options); end

  def render_in(view_context, &block); end

  def size(*arg, **arg1, &arg2); end
end

class ViewComponent::Collection
end

module ViewComponent::CompileCache
end

module ViewComponent::CompileCache
  def self.cache(); end

  def self.cache=(val); end

  def self.compiled?(klass); end

  def self.invalidate!(); end

  def self.invalidate_class!(klass); end

  def self.register(klass); end
end

class ViewComponent::Compiler
  def __vc_compiler_lock(); end

  def compile(raise_errors: T.unsafe(nil), force: T.unsafe(nil)); end

  def compiled?(); end

  def development?(); end

  def initialize(component_class); end

  def mode(); end

  def mode=(mode); end

  def mode?(); end

  def reset_render_template_for(); end

  def with_lock(&block); end
  DEVELOPMENT_MODE = ::T.let(nil, ::T.untyped)
  PRODUCTION_MODE = ::T.let(nil, ::T.untyped)
end

class ViewComponent::Compiler
  def self.mode(); end

  def self.mode=(value); end

  def self.mode?(); end
end

class ViewComponent::ComponentError
end

class ViewComponent::ComponentError
end

module ViewComponent::ContentAreas
  def with(area, content=T.unsafe(nil), &block); end
end

module ViewComponent::ContentAreas
  extend ::ActiveSupport::Concern
end

class ViewComponent::Engine
end

class ViewComponent::Engine
end

module ViewComponent::GlobalOutputBuffer
  def output_buffer=(other_buffer); end

  def perform_render(); end

  def render_in(view_context, &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ViewComponent::GlobalOutputBuffer::ActionViewMods
  def output_buffer=(other_buffer); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ViewComponent::GlobalOutputBuffer::ActionViewMods
end

module ViewComponent::GlobalOutputBuffer
end

module ViewComponent::Instrumentation
  def render_in(view_context, &block); end
end

module ViewComponent::Instrumentation
  def self.included(mod); end
end

class ViewComponent::OutputBufferStack
  def append=(arg); end

  def buffer_stack(); end

  def current(); end

  def html_safe?(*arg, **arg1, &arg2); end

  def initialize(initial_buffer=T.unsafe(nil)); end

  def length(); end

  def method_missing(method, *args, **arg, &block); end

  def pop(); end

  def presence(*arg, **arg1, &arg2); end

  def present?(*arg, **arg1, &arg2); end

  def push(buffer=T.unsafe(nil)); end

  def replace(buffer); end

  def safe_append=(arg); end

  def safe_concat(arg); end
end

class ViewComponent::OutputBufferStack
  def self.make_frame(*args); end
end

module ViewComponent::PolymorphicSlots
end

module ViewComponent::PolymorphicSlots::ClassMethods
  def register_polymorphic_slot(slot_name, types, collection:); end

  def renders_many(slot_name, callable=T.unsafe(nil)); end

  def renders_one(slot_name, callable=T.unsafe(nil)); end
end

module ViewComponent::PolymorphicSlots::ClassMethods
end

module ViewComponent::PolymorphicSlots::InstanceMethods
  def set_polymorphic_slot(slot_name, poly_type=T.unsafe(nil), *args, **arg, &block); end
end

module ViewComponent::PolymorphicSlots::InstanceMethods
end

module ViewComponent::PolymorphicSlots
  def self.included(base); end
end

class ViewComponent::Preview
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def render(component, **args, &block); end

  def render_component(component, **args, &block); end

  def render_with_template(template: T.unsafe(nil), locals: T.unsafe(nil)); end
end

class ViewComponent::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.examples(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.layout(layout_name); end

  def self.load_previews(); end

  def self.preview_example_template_path(example); end

  def self.preview_name(); end

  def self.preview_source(example); end

  def self.render_args(example, params: T.unsafe(nil)); end
end

module ViewComponent::PreviewActions
  def index(); end

  def previews(); end
end

module ViewComponent::PreviewActions
  extend ::ActiveSupport::Concern
end

class ViewComponent::PreviewTemplateError
end

class ViewComponent::PreviewTemplateError
end

module ViewComponent::Previewable
end

module ViewComponent::Previewable
  extend ::ActiveSupport::Concern
end

class ViewComponent::Slot
  def content(); end

  def content=(content); end
end

class ViewComponent::Slot
end

class ViewComponent::SlotV2
  include ::ViewComponent::WithContentHelper
  def __vc_component_instance=(__vc_component_instance); end

  def __vc_content=(__vc_content); end

  def __vc_content_block=(__vc_content_block); end

  def initialize(parent); end

  def method_missing(symbol, *args, **arg, &block); end
end

class ViewComponent::SlotV2
end

module ViewComponent::Slotable
  def slot(slot_name, **args, &block); end
end

module ViewComponent::Slotable::ClassMethods
  def inherited(child); end

  def with_slot(*slot_names, collection: T.unsafe(nil), class_name: T.unsafe(nil)); end
end

module ViewComponent::Slotable::ClassMethods
end

module ViewComponent::Slotable
  extend ::ActiveSupport::Concern
end

module ViewComponent::SlotableV2
  def get_slot(slot_name); end

  def set_slot(slot_name, slot_definition=T.unsafe(nil), *args, **arg, &block); end
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

module ViewComponent::SlotableV2
  extend ::ActiveSupport::Concern
end

class ViewComponent::TemplateError
  def initialize(errors); end
end

class ViewComponent::TemplateError
end

class ViewComponent::TestCase
  include ::ViewComponent::TestHelpers
  include ::Capybara::Minitest::Assertions
end

class ViewComponent::TestCase
end

module ViewComponent::TestHelpers
  include ::Capybara::Minitest::Assertions
  def build_controller(klass); end

  def controller(); end

  def page(); end

  def refute_component_rendered(); end

  def render_in_view_context(&block); end

  def render_inline(component, **args, &block); end

  def rendered_component(); end

  def rendered_content(); end

  def request(); end

  def with_controller_class(klass); end

  def with_request_url(path); end

  def with_variant(variant); end
end

module ViewComponent::TestHelpers
end

module ViewComponent::Translatable
  def html_safe_translation(translation); end

  def i18n_scope(); end

  def t(key=T.unsafe(nil), **options); end

  def translate(key=T.unsafe(nil), **options); end
  HTML_SAFE_TRANSLATION_KEY = ::T.let(nil, ::T.untyped)
end

module ViewComponent::Translatable
  extend ::ActiveSupport::Concern
end

module ViewComponent::WithContentHelper
  def with_content(value); end
end

module ViewComponent::WithContentHelper
end

module ViewComponent
  extend ::ActiveSupport::Autoload
end

class ViewComponentsController
  include ::ViewComponent::PreviewActions
end

class ViewComponentsController
end

class Warden::Proxy
  ENV_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_WARDEN_ERRORS = ::T.let(nil, ::T.untyped)
end

class Warden::SessionSerializer
  def user_deserialize(args); end

  def user_serialize(record); end
end

module Warden::Test::Helpers
  def login_as(user, opts=T.unsafe(nil)); end

  def logout(*scopes); end
end

module Warden::Test::Helpers
  def self.included(_base); end
end

module Warden::Test::Mock
  def warden(); end
end

class Warden::Test::Mock::Session
  def app(); end

  def app=(app); end

  def call(e); end

  def initialize(app, _configs=T.unsafe(nil)); end
end

class Warden::Test::Mock::Session
end

module Warden::Test::Mock
  def self.included(_base); end
end

module Warden::Test::WardenHelpers
  def _on_next_request(); end

  def asset_paths(); end

  def asset_paths=(*vals); end

  def on_next_request(&blk); end

  def test_reset!(); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
  def extract(input=T.unsafe(nil)); end

  def initialize(binding); end
  GLOBAL_OBJECTS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def exc(); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
  def self.find_binding(mappers, exception_object_id); end

  def self.follow(exc); end
end

class WebConsole::Injector
  def initialize(body, headers); end

  def inject(content); end
end

class WebConsole::Injector
end

module WebConsole::Interceptor
  def self.call(request, exception); end
end

class WebConsole::Middleware
  def call(env); end

  def initialize(app); end

  def mount_point(); end

  def mount_point=(val); end

  def whiny_requests(); end

  def whiny_requests=(val); end
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Middleware
  def self.mount_point(); end

  def self.mount_point=(val); end

  def self.whiny_requests(); end

  def self.whiny_requests=(val); end
end

class WebConsole::Permissions
  def include?(network); end

  def initialize(networks=T.unsafe(nil)); end
  ALWAYS_PERMITTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Request
  def permissions(); end

  def permissions=(val); end

  def permitted?(); end

  def strict_remote_ip(); end
end

class WebConsole::Request::GetSecureIp
  def initialize(req, proxies); end
end

class WebConsole::Request
  def self.permissions(); end

  def self.permissions=(val); end
end

class WebConsole::Session
  def context(objpath); end

  def eval(input); end

  def id(); end

  def initialize(exception_mappers); end

  def inmemory_storage(); end

  def switch_binding_to(index, exception_object_id); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(val); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(val); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def only_on_regular_page(*args); end

  def render(*arg); end

  def render_inlined_string(template); end

  def render_javascript(template); end

  def t(key, options=T.unsafe(nil)); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def permitted?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class WebConsole::WhinyRequest
end

class WebSocket::Driver
  def add_extension(extension); end

  def binary(message); end

  def close(reason=T.unsafe(nil), code=T.unsafe(nil)); end

  def initialize(socket, options=T.unsafe(nil)); end

  def ping(*args); end

  def pong(*args); end

  def protocol(); end

  def ready_state(); end

  def set_header(name, value); end

  def start(); end

  def state(); end

  def text(message); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  STATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def headers(); end

  def proxy(origin, options=T.unsafe(nil)); end

  def status(); end
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def self.generate_key(); end
end

class WebSocket::Driver::CloseEvent
  def code(); end

  def code=(_); end

  def reason(); end

  def reason=(_); end
end

class WebSocket::Driver::CloseEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::ConnectEvent
end

class WebSocket::Driver::ConnectEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Draft75
  def frame(buffer, type=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def parse(chunk); end

  def version(); end
end

class WebSocket::Driver::Draft75
end

class WebSocket::Driver::Draft76
  BODY_SIZE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Draft76
end

module WebSocket::Driver::EventEmitter
  def add_listener(event, callable=T.unsafe(nil), &block); end

  def emit(event, *args); end

  def initialize(); end

  def listener_count(event); end

  def listeners(event); end

  def on(event, callable=T.unsafe(nil), &block); end

  def remove_all_listeners(event=T.unsafe(nil)); end

  def remove_listener(event, callable=T.unsafe(nil), &block); end
end

class WebSocket::Driver::Headers
  def [](name); end

  def []=(name, value); end

  def clear(); end

  def initialize(received=T.unsafe(nil)); end

  def to_h(); end
  ALLOWED_DUPLICATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Headers
end

class WebSocket::Driver::Hybi
  def frame(buffer, type=T.unsafe(nil), code=T.unsafe(nil)); end

  def parse(chunk); end

  def ping(message=T.unsafe(nil), &callback); end

  def pong(message=T.unsafe(nil)); end

  def version(); end
  BYTE = ::T.let(nil, ::T.untyped)
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
  ERROR_CODES = ::T.let(nil, ::T.untyped)
  FIN = ::T.let(nil, ::T.untyped)
  GUID = ::T.let(nil, ::T.untyped)
  LENGTH = ::T.let(nil, ::T.untyped)
  MASK = ::T.let(nil, ::T.untyped)
  MAX_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
  MIN_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  OPCODE = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OPCODE_CODES = ::T.let(nil, ::T.untyped)
  OPENING_OPCODES = ::T.let(nil, ::T.untyped)
  PACK_FORMATS = ::T.let(nil, ::T.untyped)
  RSV1 = ::T.let(nil, ::T.untyped)
  RSV2 = ::T.let(nil, ::T.untyped)
  RSV3 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Hybi::Frame
  def final(); end

  def final=(final); end

  def length(); end

  def length=(length); end

  def length_bytes(); end

  def length_bytes=(length_bytes); end

  def masked(); end

  def masked=(masked); end

  def masking_key(); end

  def masking_key=(masking_key); end

  def opcode(); end

  def opcode=(opcode); end

  def payload(); end

  def payload=(payload); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Frame
end

class WebSocket::Driver::Hybi::Message
  def <<(frame); end

  def data(); end

  def data=(data); end

  def opcode(); end

  def opcode=(opcode); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Message
end

class WebSocket::Driver::Hybi
  def self.generate_accept(key); end
end

class WebSocket::Driver::MessageEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::MessageEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::OpenEvent
end

class WebSocket::Driver::OpenEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PingEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PingEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PongEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PongEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Proxy
  include ::WebSocket::Driver::EventEmitter
  def headers(); end

  def initialize(client, origin, options); end

  def parse(chunk); end

  def set_header(name, value); end

  def start(); end

  def status(); end
  PORTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Proxy
end

class WebSocket::Driver::Server
  def add_extension(*args, &block); end

  def binary(*args, &block); end

  def close(*args, &block); end

  def env(); end

  def frame(*args, &block); end

  def parse(chunk); end

  def ping(*args, &block); end

  def set_header(*args, &block); end

  def start(*args, &block); end

  def text(*args, &block); end

  def url(); end

  def version(); end

  def write(buffer); end
  EVENTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Server
end

class WebSocket::Driver::StreamReader
  def each_byte(); end

  def put(chunk); end

  def read(length); end
  MINIMUM_AUTOMATIC_PRUNE_OFFSET = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::StreamReader
end

class WebSocket::Driver
  def self.client(socket, options=T.unsafe(nil)); end

  def self.encode(data, encoding=T.unsafe(nil)); end

  def self.rack(socket, options=T.unsafe(nil)); end

  def self.server(socket, options=T.unsafe(nil)); end

  def self.validate_options(options, valid_keys); end

  def self.websocket?(env); end
end

class WebSocket::Extensions
  def activate(header); end

  def add(ext); end

  def close(); end

  def generate_offer(); end

  def generate_response(header); end

  def process_incoming_message(message); end

  def process_outgoing_message(message); end

  def valid_frame_rsv(frame); end

  def valid_frame_rsv?(frame); end
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser
  EXT = ::T.let(nil, ::T.untyped)
  EXT_LIST = ::T.let(nil, ::T.untyped)
  NOTOKEN = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  QUOTED = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser
  def self.parse_header(header); end

  def self.serialize_params(name, params); end
end

module WebSocket::HTTP
end

module WebSocket::HTTP::Headers
  def complete?(); end

  def error?(); end

  def headers(); end

  def initialize(); end

  def parse(chunk); end
  CR = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
end

module WebSocket::HTTP::Headers
end

class WebSocket::HTTP::Request
  include ::WebSocket::HTTP::Headers
  def env(); end
  REQUEST_LINE = ::T.let(nil, ::T.untyped)
  REQUEST_TARGET = ::T.let(nil, ::T.untyped)
  RESERVED_HEADERS = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Request
end

class WebSocket::HTTP::Response
  include ::WebSocket::HTTP::Headers
  def [](name); end

  def body(); end

  def code(); end
  STATUS_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Response
end

module WebSocket::HTTP
  def self.normalize_header(name); end
end

module WebSocket::Mask
end

module WebSocket::Mask
  def self.mask(arg, arg1); end
end

module Webdrivers
  DEFAULT_CACHE_TIME = ::T.let(nil, ::T.untyped)
  DEFAULT_INSTALL_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Webdrivers::ChromeFinder
  def self.location(); end

  def self.version(); end
end

class Webdrivers::Chromedriver
  def self.base_url(); end

  def self.browser_version(); end

  def self.chrome_version(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::Common
  def self.driver_path(); end

  def self.remove(); end

  def self.required_version(); end

  def self.required_version=(required_version); end

  def self.update(); end
end

class Webdrivers::EdgeFinder
  def self.location(); end

  def self.version(); end
end

class Webdrivers::Geckodriver
  def self.base_url(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::IEdriver
  def self.base_url(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::Logger
  def initialize(); end
end

class Webdrivers::Network
  def self.get(url, limit=T.unsafe(nil)); end

  def self.get_response(url, limit=T.unsafe(nil)); end

  def self.get_url(url, limit=T.unsafe(nil)); end

  def self.http(); end

  def self.using_proxy(); end
end

class Webdrivers::System
  def self.apple_m1_architecture?(); end

  def self.bitsize(); end

  def self.cache_version(file_name, version); end

  def self.cached_version(file_name); end

  def self.call(process, arg=T.unsafe(nil)); end

  def self.decompress_file(tempfile, file_name, target); end

  def self.delete(file); end

  def self.download(url, target); end

  def self.download_file(url, target); end

  def self.exists?(file); end

  def self.install_dir(); end

  def self.platform(); end

  def self.to_win32_path(path); end

  def self.to_wsl_path(path); end

  def self.untarbz2_file(filename); end

  def self.untargz_file(source, target); end

  def self.unzip_file(filename, driver_name); end

  def self.valid_cache?(file_name); end

  def self.wsl_v1?(); end
end

module Webdrivers
  def self.cache_time(); end

  def self.cache_time=(cache_time); end

  def self.configure(); end

  def self.install_dir(); end

  def self.install_dir=(install_dir); end

  def self.logger(); end

  def self.net_http_ssl_fix(); end

  def self.proxy_addr(); end

  def self.proxy_addr=(proxy_addr); end

  def self.proxy_pass(); end

  def self.proxy_pass=(proxy_pass); end

  def self.proxy_port(); end

  def self.proxy_port=(proxy_port); end

  def self.proxy_user(); end

  def self.proxy_user=(proxy_user); end
end

module XPath::DSL
  def !(*args); end

  def !=(rhs); end

  def %(rhs); end

  def &(rhs); end

  def *(rhs); end

  def +(*expressions); end

  def /(rhs); end

  def <(rhs); end

  def <=(rhs); end

  def ==(rhs); end

  def >(rhs); end

  def >=(rhs); end

  def [](expression); end

  def ancestor(*element_names); end

  def ancestor_or_self(*element_names); end

  def and(rhs); end

  def anywhere(*expressions); end

  def attr(expression); end

  def attribute(*element_names); end

  def axis(name, *element_names); end

  def binary_operator(name, rhs); end

  def boolean(*args); end

  def ceiling(*args); end

  def child(*expressions); end

  def concat(*args); end

  def contains(*args); end

  def contains_word(word); end

  def count(*args); end

  def css(selector); end

  def current(); end

  def descendant(*expressions); end

  def descendant_or_self(*element_names); end

  def divide(rhs); end

  def ends_with(suffix); end

  def equals(rhs); end

  def false(*args); end

  def floor(*args); end

  def following(*element_names); end

  def following_sibling(*element_names); end

  def function(name, *arguments); end

  def gt(rhs); end

  def gte(rhs); end

  def id(*args); end

  def inverse(*args); end

  def is(expression); end

  def join(*expressions); end

  def lang(*args); end

  def last(); end

  def local_name(*args); end

  def lowercase(); end

  def lt(rhs); end

  def lte(rhs); end

  def method(name, *arguments); end

  def minus(rhs); end

  def mod(rhs); end

  def multiply(rhs); end

  def n(*args); end

  def namespace(*element_names); end

  def namespace_uri(*args); end

  def next_sibling(*expressions); end

  def normalize(*args); end

  def normalize_space(*args); end

  def not(*args); end

  def not_equals(rhs); end

  def number(*args); end

  def one_of(*expressions); end

  def or(rhs); end

  def parent(*element_names); end

  def plus(rhs); end

  def position(); end

  def preceding(*element_names); end

  def preceding_sibling(*element_names); end

  def previous_sibling(*expressions); end

  def qname(); end

  def round(*args); end

  def self(*element_names); end

  def self_axis(*element_names); end

  def starts_with(*args); end

  def string(*args); end

  def string_length(*args); end

  def substring(*args); end

  def substring_after(*args); end

  def substring_before(*args); end

  def sum(*args); end

  def text(); end

  def translate(*args); end

  def true(*args); end

  def union(*expressions); end

  def uppercase(); end

  def where(expression); end

  def |(rhs); end

  def ~(*args); end
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

class XPath::Expression
  def arguments(); end

  def arguments=(arguments); end

  def expression(); end

  def expression=(expression); end

  def initialize(expression, *arguments); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Literal
  def initialize(value); end

  def value(); end
end

class XPath::Renderer
  def anywhere(element_names); end

  def attribute(current, name); end

  def axis(current, name, element_names); end

  def binary_operator(name, left, right); end

  def child(current, element_names); end

  def convert_argument(argument); end

  def css(current, selector); end

  def descendant(current, element_names); end

  def function(name, *arguments); end

  def initialize(type); end

  def is(one, two); end

  def join(*expressions); end

  def literal(node); end

  def render(node); end

  def string_literal(string); end

  def text(current); end

  def this_node(); end

  def union(*expressions); end

  def variable(name); end

  def where(on, condition); end
end

class XPath::Renderer
  def self.render(node, type); end
end

class XPath::Union
  def arguments(); end

  def each(&block); end

  def expression(); end

  def expressions(); end

  def initialize(*expressions); end

  def method_missing(*args); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

module XPath
  def self.generate(); end
end

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Command
  def common_options(opts); end

  def description(); end

  def load_script(file); end

  def parse_options(opts, args); end

  def unrecognized_option(err); end
end

class YARD::CLI::Command
  def self.run(*args); end
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::Yardoc
  def all_objects(); end

  def apis(); end

  def apis=(apis); end

  def assets(); end

  def assets=(assets); end

  def excluded(); end

  def excluded=(excluded); end

  def fail_on_warning(); end

  def fail_on_warning=(fail_on_warning); end

  def files(); end

  def files=(files); end

  def generate(); end

  def generate=(generate); end

  def has_markup(); end

  def has_markup=(has_markup); end

  def hidden_apis(); end

  def hidden_apis=(hidden_apis); end

  def hidden_tags(); end

  def hidden_tags=(hidden_tags); end

  def list(); end

  def list=(list); end

  def options(); end

  def run(*args); end

  def save_yardoc(); end

  def save_yardoc=(save_yardoc); end

  def statistics(); end

  def statistics=(statistics); end

  def use_cache(); end

  def use_cache=(use_cache); end

  def visibilities(); end

  def visibilities=(visibilities); end
end

class YARD::CLI::YardocOptions
  def file(); end

  def file=(file); end

  def files(); end

  def files=(files); end

  def item(); end

  def item=(item); end

  def locale(); end

  def locale=(locale); end

  def objects(); end

  def objects=(objects); end

  def onefile(); end

  def onefile=(onefile); end

  def readme(); end

  def readme=(readme); end

  def title(); end

  def title=(title); end
end

class YARD::CLI::YardoptsCommand
  def options_file(); end

  def options_file=(options_file); end

  def parse_arguments(*args); end

  def use_document_file(); end

  def use_document_file=(use_document_file); end

  def use_yardopts_file(); end

  def use_yardopts_file=(use_yardopts_file); end

  def yardopts_options(opts); end
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::CodeObjectList
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::MethodObject
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

module YARD::CodeObjects::NamespaceMapper
  def clear_separators(); end

  def default_separator(value=T.unsafe(nil)); end

  def register_separator(sep, *valid_types); end

  def separators(); end

  def separators_for_type(type); end

  def separators_match(); end

  def types_for_separator(sep); end

  def unregister_separator_by_type(type); end
end

module YARD::CodeObjects::NamespaceMapper
  def self.default_separator(); end

  def self.default_separator=(default_separator); end

  def self.invalidate(); end

  def self.map(); end

  def self.map_match(); end

  def self.on_invalidate(&block); end

  def self.rev_map(); end
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::DocstringParser
  def create_directive(tag_name, tag_buf); end

  def create_ref_tag(tag_name, name, object_name); end

  def create_tag(tag_name, tag_buf=T.unsafe(nil)); end

  def directives(); end

  def directives=(directives); end

  def handler(); end

  def handler=(handler); end

  def initialize(library=T.unsafe(nil)); end

  def library(); end

  def library=(library); end

  def object(); end

  def object=(object); end

  def parse(content, object=T.unsafe(nil), handler=T.unsafe(nil)); end

  def parse_content(content); end

  def post_process(); end

  def raw_text(); end

  def raw_text=(raw_text); end

  def reference(); end

  def reference=(reference); end

  def state(); end

  def state=(state); end

  def tag_is_directive?(tag_name); end

  def tags(); end

  def tags=(tags); end

  def text(); end

  def text=(text); end

  def to_docstring(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  def self.after_parse(&block); end

  def self.after_parse_callbacks(); end
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

class YARD::Handlers::Base
  def abort!(); end

  def call_params(); end

  def caller_method(); end

  def ensure_loaded!(object, max_retries=T.unsafe(nil)); end

  def extra_state(); end

  def globals(); end

  def initialize(source_parser, stmt); end

  def namespace(); end

  def namespace=(v); end

  def owner(); end

  def owner=(v); end

  def parse_block(*arg); end

  def parser(); end

  def process(); end

  def push_state(opts=T.unsafe(nil)); end

  def register(*objects); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end

  def register_dynamic(object); end

  def register_ensure_loaded(object); end

  def register_file_info(object, file=T.unsafe(nil), line=T.unsafe(nil), comments=T.unsafe(nil)); end

  def register_group(object, group=T.unsafe(nil)); end

  def register_module_function(object); end

  def register_source(object, source=T.unsafe(nil), type=T.unsafe(nil)); end

  def register_transitive_tags(object); end

  def register_visibility(object, visibility=T.unsafe(nil)); end

  def scope(); end

  def scope=(v); end

  def statement(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::Handlers::Base
  def self.clear_subclasses(); end

  def self.handles(*matches); end

  def self.handles?(statement); end

  def self.in_file(filename); end

  def self.inherited(subclass); end

  def self.matches_file?(filename); end

  def self.namespace_only(); end

  def self.namespace_only?(); end

  def self.process(&block); end
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
  ERROR_CLASS_NAMES = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

class YARD::Handlers::NamespaceMissingError
  def initialize(object); end

  def object(); end

  def object=(object); end
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::Base
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  def name(); end
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
  def make_module_function(instance_method, namespace); end
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

class YARD::Logger
  def <<(msg=T.unsafe(nil)); end

  def backtrace(exc, level_meth=T.unsafe(nil)); end

  def capture(msg, nontty_log=T.unsafe(nil)); end

  def clear_progress(); end

  def debug(*args); end

  def enter_level(new_level=T.unsafe(nil)); end

  def initialize(pipe, *args); end

  def io(); end

  def io=(pipe); end

  def print(msg=T.unsafe(nil)); end

  def progress(msg, nontty_log=T.unsafe(nil)); end

  def puts(msg=T.unsafe(nil)); end

  def show_backtraces(); end

  def show_backtraces=(show_backtraces); end

  def show_progress(); end

  def show_progress=(show_progress); end

  def warn(*args); end

  def warn_no_continuations(); end

  def warned(); end

  def warned=(warned); end
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

class YARD::Logger
  def self.instance(pipe=T.unsafe(nil)); end
end

class YARD::Options
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&blk); end

  def merge(opts); end

  def method_missing(meth, *args, &block); end

  def reset_defaults(); end

  def to_hash(); end

  def update(opts); end
end

class YARD::Options
  def self.default_attr(key, default); end
end

class YARD::Parser::Base
  def enumerator(); end

  def initialize(source, filename); end

  def parse(); end

  def tokenize(); end
end

class YARD::Parser::Base
  def self.parse(source, filename=T.unsafe(nil)); end
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  extend ::Enumerable
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def inside_directive?(); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Directive
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def param_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_tag(text); end

  def yieldreturn_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::MethodDirective
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

class YARD::Tags::OverloadTag
  def docstring(); end

  def has_tag?(name); end

  def initialize(tag_name, text); end

  def is_a?(other); end

  def kind_of?(other); end

  def method_missing(*args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def object=(value); end

  def parameters(); end

  def signature(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end
end

class YARD::Tags::OverloadTag
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ParseDirective
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::Tag
  def explain_types(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def object(); end

  def object=(object); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def text(); end

  def text=(text); end

  def type(); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::Tag
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

class YARD::Tags::VisibilityDirective
end

class YARD::Tags::VisibilityDirective
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP = RDoc::Markup

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(arg); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Templates::TemplateOptions
  def __globals(); end

  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def embed_mixins_match?(mixin); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def index(); end

  def index=(index); end

  def markup(); end

  def markup=(markup); end

  def markup_provider(); end

  def markup_provider=(markup_provider); end

  def no_highlight(); end

  def no_highlight=(value); end

  def object(); end

  def object=(object); end

  def owner(); end

  def owner=(owner); end

  def page_title(); end

  def page_title=(page_title); end

  def serialize(); end

  def serialize=(serialize); end

  def serializer(); end

  def serializer=(serializer); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module YARD
  def self.load_plugins(); end

  def self.parse(*args); end

  def self.parse_string(*args); end

  def self.ruby18?(); end

  def self.ruby19?(); end

  def self.ruby2?(); end

  def self.ruby31?(); end

  def self.ruby3?(); end

  def self.windows?(); end
end

module YARDSorbet
  VERSION = ::T.let(nil, ::T.untyped)
end

module YARDSorbet::Directives
  def self.add_directives(*args, **arg, &blk); end

  def self.extract_directives(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::AbstractDSLHandler
  def process(*args, **arg, &blk); end
  CLASS_TAG_TEXT = ::T.let(nil, ::T.untyped)
  TAG_TEXT = ::T.let(nil, ::T.untyped)
end

class YARDSorbet::Handlers::EnumsHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::IncludeHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::MixesInClassMethodsHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::MixesInClassMethodsHandler
  def self.mixed_in_class_methods(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::SigHandler
  def process(*args, **arg, &blk); end
end

module YARDSorbet::Handlers::StructClassHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::StructPropHandler
  def process(*args, **arg, &blk); end
end

module YARDSorbet::NodeUtils
  SKIP_METHOD_CONTENTS = ::T.let(nil, ::T.untyped)
end

module YARDSorbet::NodeUtils
  def self.bfs_traverse(*args, **arg, &blk); end

  def self.get_method_node(*args, **arg, &blk); end

  def self.sibling_node(*args, **arg, &blk); end
end

module YARDSorbet::SigToYARD
  def self.convert(*args, **arg, &blk); end
end

class YARDSorbet::TStructProp
  def default(); end

  def doc(); end

  def prop_name(); end

  def source(); end

  def types(); end
end

class YARDSorbet::TStructProp
  def self.inherited(s); end
end

module YARDSorbet::TagUtils
  def self.find_tag(*args, **arg, &blk); end

  def self.upsert_tag(*args, **arg, &blk); end
end

module Zeitwerk
  VERSION = ::T.let(nil, ::T.untyped)
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
  def self.cpaths(); end

  def self.mutex(); end

  def self.register(cpath, loader); end

  def self.tracer(); end

  def self.unregister_loader(loader); end
end

class Zeitwerk::GemInflector
  def camelize(basename, abspath); end

  def initialize(root_file); end
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end

  def inflect(inflections); end
end

class Zeitwerk::Loader
  def autoloaded_dirs(); end

  def autoloads(); end

  def eager_load(force: T.unsafe(nil)); end

  def lazy_subdirs(); end

  def mutex(); end

  def mutex2(); end

  def reload(); end

  def setup(); end

  def to_unload(); end

  def unload(); end

  def unloadable_cpath?(cpath); end

  def unloadable_cpaths(); end

  def unregister(); end
end

module Zeitwerk::Loader::Callbacks
  def on_dir_autoloaded(dir); end

  def on_file_autoloaded(file); end

  def on_namespace_loaded(namespace); end
end

module Zeitwerk::Loader::Config
  def collapse(*glob_patterns); end

  def collapse_dirs(); end

  def collapse_glob_patterns(); end

  def dirs(); end

  def do_not_eager_load(*paths); end

  def eager_load_exclusions(); end

  def enable_reloading(); end

  def ignore(*glob_patterns); end

  def ignored_glob_patterns(); end

  def ignored_paths(); end

  def ignores?(abspath); end

  def inflector(); end

  def inflector=(inflector); end

  def initialize(); end

  def log!(); end

  def logger(); end

  def logger=(logger); end

  def on_load(cpath=T.unsafe(nil), &block); end

  def on_load_callbacks(); end

  def on_setup(&block); end

  def on_setup_callbacks(); end

  def on_unload(cpath=T.unsafe(nil), &block); end

  def on_unload_callbacks(); end

  def push_dir(path, namespace: T.unsafe(nil)); end

  def reloading_enabled?(); end

  def root_dirs(); end

  def tag(); end

  def tag=(tag); end
end

class Zeitwerk::Loader
  def self.all_dirs(); end

  def self.default_logger(); end

  def self.default_logger=(default_logger); end

  def self.eager_load_all(); end

  def self.for_gem(); end

  def self.mutex(); end

  def self.mutex=(mutex); end
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

module Zeitwerk::Registry
  def self.autoloads(); end

  def self.inception?(cpath); end

  def self.inceptions(); end

  def self.loader_for(path); end

  def self.loader_for_gem(root_file); end

  def self.loaders(); end

  def self.loaders_managing_gems(); end

  def self.on_unload(loader); end

  def self.register_autoload(loader, abspath); end

  def self.register_inception(cpath, abspath, loader); end

  def self.register_loader(loader); end

  def self.unregister_autoload(abspath); end

  def self.unregister_loader(loader); end
end

module Zeitwerk
  def self.with_loader(); end
end

module Zip
  def case_insensitive_match(); end

  def case_insensitive_match=(case_insensitive_match); end

  def continue_on_exists_proc(); end

  def continue_on_exists_proc=(continue_on_exists_proc); end

  def default_compression(); end

  def default_compression=(default_compression); end

  def force_entry_names_encoding(); end

  def force_entry_names_encoding=(force_entry_names_encoding); end

  def on_exists_proc(); end

  def on_exists_proc=(on_exists_proc); end

  def reset!(); end

  def setup(); end

  def sort_entries(); end

  def sort_entries=(sort_entries); end

  def unicode_names(); end

  def unicode_names=(unicode_names); end

  def validate_entry_sizes(); end

  def validate_entry_sizes=(validate_entry_sizes); end

  def warn_invalid_date(); end

  def warn_invalid_date=(warn_invalid_date); end

  def write_zip64_support(); end

  def write_zip64_support=(write_zip64_support); end
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHODS = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_AES = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_BZIP2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE_64 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_CMPSC = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_LZ77 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_TERSE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IMPLODE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_JPEG = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_LZMA = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PKWARE_DCLI = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PPMD = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_1 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_3 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_4 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_SHRINK = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_STORE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_WAVPACK = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  include ::Enumerable
  def ==(other); end

  def comment(); end

  def each(&a_proc); end

  def entries(); end

  def get_64_e_o_c_d(buf); end

  def get_e_o_c_d(buf); end

  def initialize(entries=T.unsafe(nil), comment=T.unsafe(nil)); end

  def read_64_e_o_c_d(buf); end

  def read_central_directory_entries(io); end

  def read_e_o_c_d(buf); end

  def read_from_stream(io); end

  def size(); end

  def start_buf(io); end

  def write_to_stream(io); end

  def zip64_file?(buf); end
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  def self.read_from_stream(io); end
end

class Zip::Compressor
  def finish(); end
end

class Zip::Compressor
end

class Zip::DOSTime
  def dos_equals(other); end

  def to_binary_dos_date(); end

  def to_binary_dos_time(); end
end

class Zip::DOSTime
  def self.from_time(time); end

  def self.parse_binary_dos_format(bin_dos_date, bin_dos_time); end
end

class Zip::DecompressionError
end

class Zip::DecompressionError
end

class Zip::Decompressor
  def decompressed_size(); end

  def initialize(input_stream, decompressed_size=T.unsafe(nil)); end

  def input_stream(); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
  def self.decompressor_classes(); end

  def self.find_by_compression_method(compression_method); end

  def self.register(compression_method, decompressor_class); end
end

class Zip::DecryptedIo
  def initialize(io, decrypter); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::DecryptedIo
end

class Zip::Decrypter
end

class Zip::Decrypter
end

class Zip::Deflater
  def <<(data); end

  def crc(); end

  def initialize(output_stream, level=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def size(); end
end

class Zip::Deflater
end

class Zip::Encrypter
end

class Zip::Encrypter
end

class Zip::Entry
  def ==(other); end

  def calculate_local_header_size(); end

  def cdir_header_size(); end

  def check_c_dir_entry_comment_size(); end

  def check_c_dir_entry_signature(); end

  def check_c_dir_entry_static_header_length(buf); end

  def check_name(name); end

  def clean_up(); end

  def comment(); end

  def comment=(comment); end

  def comment_size(); end

  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def compression_method(); end

  def compression_method=(compression_method); end

  def crc(); end

  def crc=(crc); end

  def directory?(); end

  def dirty(); end

  def dirty=(dirty); end

  def encrypted?(); end

  def external_file_attributes(); end

  def external_file_attributes=(external_file_attributes); end

  def extra(); end

  def extra=(extra); end

  def extra_size(); end

  def extract(dest_path=T.unsafe(nil), &block); end

  def file?(); end

  def file_stat(path); end

  def file_type_is?(type); end

  def filepath(); end

  def follow_symlinks(); end

  def follow_symlinks=(follow_symlinks); end

  def fstype(); end

  def fstype=(fstype); end

  def ftype(); end

  def gather_fileinfo_from_srcpath(src_path); end

  def get_extra_attributes_from_path(path); end

  def get_input_stream(&block); end

  def get_raw_input_stream(&block); end

  def gp_flags(); end

  def gp_flags=(gp_flags); end

  def header_signature(); end

  def header_signature=(header_signature); end

  def incomplete?(); end

  def initialize(*args); end

  def internal_file_attributes(); end

  def internal_file_attributes=(internal_file_attributes); end

  def local_entry_offset(); end

  def local_header_offset(); end

  def local_header_offset=(local_header_offset); end

  def mtime(); end

  def name(); end

  def name=(name); end

  def name_is_directory?(); end

  def name_safe?(); end

  def name_size(); end

  def next_header_offset(); end

  def pack_c_dir_entry(); end

  def pack_local_entry(); end

  def parent_as_string(); end

  def read_c_dir_entry(io); end

  def read_c_dir_extra_field(io); end

  def read_local_entry(io); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def set_default_vars_values(); end

  def set_extra_attributes_on_path(dest_path); end

  def set_ftype_from_c_dir_entry(); end

  def set_unix_attributes_on_path(dest_path); end

  def size(); end

  def size=(size); end

  def symlink?(); end

  def time(); end

  def time=(value); end

  def unix_gid(); end

  def unix_gid=(unix_gid); end

  def unix_perms(); end

  def unix_perms=(unix_perms); end

  def unix_uid(); end

  def unix_uid=(unix_uid); end

  def unpack_c_dir_entry(buf); end

  def unpack_local_entry(buf); end

  def verify_local_header_size!(); end

  def write_c_dir_entry(io); end

  def write_local_entry(io, rewrite=T.unsafe(nil)); end

  def write_to_zip_output_stream(zip_output_stream); end

  def zipfile(); end

  def zipfile=(zipfile); end
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  def self.read_c_dir_entry(io); end

  def self.read_local_entry(io); end

  def self.read_zip_64_long(io); end

  def self.read_zip_long(io); end

  def self.read_zip_short(io); end
end

class Zip::EntrySet
  include ::Enumerable
  def <<(entry); end

  def ==(other); end

  def delete(entry); end

  def each(&blk); end

  def entries(); end

  def entry_order(); end

  def entry_order=(entry_order); end

  def entry_set(); end

  def entry_set=(entry_set); end

  def find_entry(entry); end

  def glob(pattern, flags=T.unsafe(nil)); end

  def include?(entry); end

  def initialize(an_enumerable=T.unsafe(nil)); end

  def length(); end

  def parent(entry); end

  def push(entry); end

  def size(); end

  def sorted_entries(); end
end

class Zip::EntrySet
end

class Zip::EntrySizeError
end

class Zip::EntrySizeError
end

class Zip::ExtraField
  def c_dir_size(); end

  def create(name); end

  def create_unknown_item(); end

  def extra_field_type_exist(binstr, id, len, index); end

  def extra_field_type_unknown(binstr, len, index); end

  def initialize(binstr=T.unsafe(nil)); end

  def local_size(); end

  def merge(binstr); end

  def ordered_values(); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Generic
  def ==(other); end

  def initial_parse(binstr); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
end

class Zip::ExtraField::Generic
  def self.register_map(); end
end

class Zip::ExtraField::IUnix
  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::IUnix
end

class Zip::ExtraField::NTFS
  def atime(); end

  def atime=(atime); end

  def ctime(); end

  def ctime=(ctime); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
end

class Zip::ExtraField::OldUnix
  def atime(); end

  def atime=(atime); end

  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
end

class Zip::ExtraField::UniversalTime
  def atime(); end

  def atime=(time); end

  def ctime(); end

  def ctime=(time); end

  def flag(); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(time); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  ATIME_MASK = ::T.let(nil, ::T.untyped)
  CTIME_MASK = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  MTIME_MASK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
end

class Zip::ExtraField::Zip64
  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def disk_start_number(); end

  def disk_start_number=(disk_start_number); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def original_size(); end

  def original_size=(original_size); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def parse(original_size, compressed_size, relative_header_offset=T.unsafe(nil), disk_start_number=T.unsafe(nil)); end

  def relative_header_offset(); end

  def relative_header_offset=(relative_header_offset); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
end

class Zip::ExtraField::Zip64Placeholder
  def initialize(_binstr=T.unsafe(nil)); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
end

class Zip::ExtraField
end

class Zip::File
  include ::Zip::FileSystem
  def add(entry, src_path, &continue_on_exists_proc); end

  def add_stored(entry, src_path, &continue_on_exists_proc); end

  def close(); end

  def comment=(comment); end

  def commit(); end

  def commit_required?(); end

  def extract(entry, dest_path, &block); end

  def find_entry(entry_name); end

  def get_entry(entry); end

  def get_input_stream(entry, &a_proc); end

  def get_output_stream(entry, permission_int=T.unsafe(nil), comment=T.unsafe(nil), extra=T.unsafe(nil), compressed_size=T.unsafe(nil), crc=T.unsafe(nil), compression_method=T.unsafe(nil), size=T.unsafe(nil), time=T.unsafe(nil), &a_proc); end

  def glob(*args, &block); end

  def initialize(path_or_io, create=T.unsafe(nil), buffer=T.unsafe(nil), options=T.unsafe(nil)); end

  def mkdir(entry_name, permission=T.unsafe(nil)); end

  def name(); end

  def read(entry); end

  def remove(entry); end

  def rename(entry, new_name, &continue_on_exists_proc); end

  def replace(entry, src_path); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def write_buffer(io=T.unsafe(nil)); end
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class Zip::File
  def self.add_buffer(); end

  def self.foreach(zip_file_name, &block); end

  def self.get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  def self.get_segment_count_for_split(zip_file_size, segment_size); end

  def self.get_segment_size_for_split(segment_size); end

  def self.open(file_name, create=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.open_buffer(io, options=T.unsafe(nil)); end

  def self.put_split_signature(szip_file, segment_size); end

  def self.save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  def self.split(zip_file_name, segment_size=T.unsafe(nil), delete_zip_file=T.unsafe(nil), partial_zip_file_name=T.unsafe(nil)); end
end

module Zip::FileSystem
  def dir(); end

  def file(); end

  def initialize(); end
end

class Zip::FileSystem::ZipFileNameMapper
  include ::Enumerable
  def each(&blk); end

  def expand_path(path); end

  def find_entry(filename); end

  def get_entry(filename); end

  def get_input_stream(filename, &a_proc); end

  def get_output_stream(filename, permissions=T.unsafe(nil), &a_proc); end

  def glob(pattern, *flags, &block); end

  def initialize(zip_file); end

  def mkdir(filename, permissions=T.unsafe(nil)); end

  def pwd(); end

  def pwd=(pwd); end

  def read(filename); end

  def remove(filename); end

  def rename(filename, new_name, &continue_on_exists_proc); end
end

class Zip::FileSystem::ZipFileNameMapper
end

class Zip::FileSystem::ZipFsDir
  def chdir(directory_name); end

  def chroot(*_args); end

  def delete(entry_name); end

  def entries(directory_name); end

  def file=(file); end

  def foreach(directory_name); end

  def getwd(); end

  def glob(*args, &block); end

  def initialize(mapped_zip); end

  def mkdir(entry_name, permissions=T.unsafe(nil)); end

  def new(directory_name); end

  def open(directory_name); end

  def pwd(); end

  def rmdir(entry_name); end

  def unlink(entry_name); end
end

class Zip::FileSystem::ZipFsDir
end

class Zip::FileSystem::ZipFsDirIterator
  include ::Enumerable
  def close(); end

  def each(&a_proc); end

  def initialize(filenames); end

  def read(); end

  def rewind(); end

  def seek(position); end

  def tell(); end
end

class Zip::FileSystem::ZipFsDirIterator
end

class Zip::FileSystem::ZipFsFile
  def atime(filename); end

  def basename(filename); end

  def blockdev?(_filename); end

  def chardev?(_filename); end

  def chmod(mode, *filenames); end

  def chown(owner, group, *filenames); end

  def ctime(filename); end

  def delete(*args); end

  def dir=(dir); end

  def directory?(filename); end

  def dirname(filename); end

  def executable?(filename); end

  def executable_real?(filename); end

  def exist?(filename); end

  def exists?(filename); end

  def expand_path(path); end

  def file?(filename); end

  def foreach(filename, sep=T.unsafe(nil), &a_proc); end

  def ftype(filename); end

  def grpowned?(filename); end

  def initialize(mapped_zip); end

  def join(*fragments); end

  def link(_filename, _symlink_name); end

  def lstat(filename); end

  def mtime(filename); end

  def new(filename, mode=T.unsafe(nil)); end

  def open(filename, mode=T.unsafe(nil), permissions=T.unsafe(nil), &block); end

  def owned?(filename); end

  def pipe(); end

  def pipe?(_filename); end

  def popen(*args, &a_proc); end

  def read(filename); end

  def readable?(filename); end

  def readable_real?(filename); end

  def readlines(filename); end

  def readlink(_filename); end

  def rename(file_to_rename, new_name); end

  def setgid?(filename); end

  def setuid?(filename); end

  def size(filename); end

  def size?(filename); end

  def socket?(_filename); end

  def split(filename); end

  def stat(filename); end

  def sticky?(filename); end

  def symlink(_filename, _symlink_name); end

  def symlink?(_filename); end

  def truncate(_filename, _len); end

  def umask(*args); end

  def unlink(*args); end

  def utime(modified_time, *filenames); end

  def writable?(filename); end

  def writable_real?(filename); end

  def zero?(filename); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def atime(); end

  def blksize(); end

  def blockdev?(); end

  def blocks(); end

  def chardev?(); end

  def ctime(); end

  def dev(); end

  def directory?(); end

  def executable?(); end

  def executable_real?(); end

  def file?(); end

  def ftype(); end

  def gid(); end

  def grpowned?(); end

  def initialize(zip_fs_file, entry_name); end

  def ino(); end

  def kind_of?(type); end

  def mode(); end

  def mtime(); end

  def nlink(); end

  def owned?(); end

  def pipe?(); end

  def rdev(); end

  def rdev_major(); end

  def rdev_minor(); end

  def readable?(); end

  def readable_real?(); end

  def setgid?(); end

  def setuid?(); end

  def size(); end

  def size?(); end

  def socket?(); end

  def sticky?(); end

  def symlink?(); end

  def uid(); end

  def writable?(); end

  def writable_real?(); end

  def zero?(); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def self.delegate_to_fs_file(*methods); end
end

class Zip::FileSystem::ZipFsFile
end

module Zip::FileSystem
end

class Zip::GPFBit3Error
end

class Zip::GPFBit3Error
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
  def each(a_sep_string=T.unsafe(nil), &blk); end

  def each_line(a_sep_string=T.unsafe(nil)); end

  def eof(); end

  def eof?(); end

  def flush(); end

  def gets(a_sep_string=T.unsafe(nil), number_of_bytes=T.unsafe(nil)); end

  def initialize(); end

  def lineno(); end

  def lineno=(lineno); end

  def pos(); end

  def read(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end

  def readline(a_sep_string=T.unsafe(nil)); end

  def readlines(a_sep_string=T.unsafe(nil)); end

  def ungetc(byte); end
end

module Zip::IOExtras::AbstractInputStream
end

module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def print(*params); end

  def printf(a_format_string, *params); end

  def putc(an_object); end

  def puts(*params); end

  def write(data); end
end

module Zip::IOExtras::AbstractOutputStream
end

module Zip::IOExtras::FakeIO
  def kind_of?(object); end
end

module Zip::IOExtras::FakeIO
end

module Zip::IOExtras
  def self.copy_stream(ostream, istream); end

  def self.copy_stream_n(ostream, istream, nbytes); end
end

class Zip::Inflater
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::Inflater
end

class Zip::InputStream
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  def close(); end

  def get_decompressor(); end

  def get_decrypted_io(); end

  def get_io(io_or_file, offset=T.unsafe(nil)); end

  def get_next_entry(); end

  def initialize(context, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def input_finished?(); end

  def open_entry(); end

  def produce_input(); end

  def rewind(); end

  def sysread(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::InputStream
  def self.open(filename_or_io, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def self.open_buffer(filename_or_io, offset=T.unsafe(nil)); end
end

class Zip::NullCompressor
  include ::Singleton
  def <<(_data); end

  def compressed_size(); end

  def size(); end
end

class Zip::NullCompressor
  extend ::Singleton::SingletonClassMethods
end

module Zip::NullDecompressor
end

module Zip::NullDecompressor
  def self.eof(); end

  def self.read(_length=T.unsafe(nil), _outbuf=T.unsafe(nil)); end
end

class Zip::NullDecrypter
  include ::Zip::NullEncryption
  def decrypt(data); end

  def reset!(_header); end
end

class Zip::NullDecrypter
end

class Zip::NullEncrypter
  include ::Zip::NullEncryption
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  def encrypt(data); end

  def header(_mtime); end

  def reset!(); end
end

class Zip::NullEncrypter
end

module Zip::NullEncryption
  def gp_flags(); end

  def header_bytesize(); end
end

module Zip::NullEncryption
end

module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
end

module Zip::NullInputStream
end

class Zip::OutputStream
  include ::Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def <<(data); end

  def close(); end

  def close_buffer(); end

  def comment(); end

  def comment=(comment); end

  def copy_raw_entry(entry); end

  def finish(); end

  def initialize(file_name, stream=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def put_next_entry(entry_name, comment=T.unsafe(nil), extra=T.unsafe(nil), compression_method=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Zip::OutputStream
  def self.open(file_name, encrypter=T.unsafe(nil)); end

  def self.write_buffer(io=T.unsafe(nil), encrypter=T.unsafe(nil)); end
end

class Zip::PassThruCompressor
  def <<(data); end

  def crc(); end

  def initialize(output_stream); end

  def size(); end
end

class Zip::PassThruCompressor
end

class Zip::PassThruDecompressor
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::PassThruDecompressor
end

class Zip::StreamableDirectory
  def initialize(zipfile, entry, src_path=T.unsafe(nil), permission=T.unsafe(nil)); end
end

class Zip::StreamableDirectory
end

class Zip::StreamableStream
  def clean_up(); end

  def get_input_stream(); end

  def get_output_stream(); end

  def initialize(entry); end

  def write_to_zip_output_stream(output_stream); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Zip::StreamableStream
end

class Zip::TraditionalDecrypter
  include ::Zip::TraditionalEncryption
  def decrypt(data); end

  def reset!(header); end
end

class Zip::TraditionalDecrypter
end

class Zip::TraditionalEncrypter
  include ::Zip::TraditionalEncryption
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  def encrypt(data); end

  def header(mtime); end

  def reset!(); end
end

class Zip::TraditionalEncrypter
end

module Zip::TraditionalEncryption
  def decrypt_byte(); end

  def gp_flags(); end

  def header_bytesize(); end

  def initialize(password); end

  def reset_keys!(); end

  def update_keys(num); end
end

module Zip::TraditionalEncryption
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

module Zip
  extend ::Zip
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
