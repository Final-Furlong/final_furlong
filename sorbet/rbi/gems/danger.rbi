# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/danger/all/danger.rbi
#
# danger-8.6.1

module Danger
  def self.danger_outdated?; end
  def self.gem_path; end
end
class Danger::Dangerfile
  def core_dsl_attributes; end
  def defined_in_file; end
  def defined_in_file=(arg0); end
  def env; end
  def env=(arg0); end
  def eval_file(contents, path); end
  def external_dsl_attributes; end
  def fail(*args, **kargs, &blk); end
  def failed?; end
  def init_plugins; end
  def initialize(env_manager, cork_board = nil); end
  def method_missing(method_sym, *arguments, **keyword_arguments, &_block); end
  def method_values_for_plugin_hashes(plugin_hashes); end
  def parse(path, contents = nil); end
  def plugins; end
  def plugins=(arg0); end
  def post_exception(ex, danger_id, new_comment); end
  def post_results(danger_id, new_comment, remove_previous_comments); end
  def print_known_info; end
  def print_list(title, rows); end
  def print_results; end
  def refresh_plugins; end
  def run(base_branch, head_branch, dangerfile_path, danger_id, new_comment, remove_previous_comments, report_results = nil); end
  def self.core_plugin_classes; end
  def self.essential_plugin_classes; end
  def setup_for_running(base_branch, head_branch); end
  def to_s; end
  def ui; end
  def ui=(arg0); end
  def verbose; end
  def verbose=(arg0); end
  def warn(*args, **kargs, &blk); end
  def wrap_text(text, width = nil); end
  include Danger::Dangerfile::DSL
end
module Danger::Dangerfile::DSL
  def env; end
  def initialize; end
  def load_default_plugins; end
end
class Danger::DSLError < StandardError
  def backtrace; end
  def contents; end
  def description; end
  def dsl_path; end
  def initialize(description, dsl_path, backtrace, contents = nil); end
  def message; end
  def parse; end
  def parse_line_number_from_description; end
  def to_markdown; end
  def upgrade_message(latest_version); end
end
class Danger::MessageGroup
  def <<(message); end
  def file; end
  def initialize(file: nil, line: nil); end
  def line; end
  def markdowns; end
  def merge(other); end
  def messages; end
  def same_line?(other); end
  def stats; end
end
module Danger::Helpers
end
module Danger::Helpers::MessageGroupsArrayHelper
  def counts; end
  def fake_errors_array; end
  def fake_warnings_array; end
end
class Danger::Helpers::MessageGroupsArrayHelper::FakeArray < Struct
  def count; end
  def count=(_); end
  def empty?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Danger::MessageAggregator
  def aggregate; end
  def initialize(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil); end
  def self.aggregate(*args); end
end
class Danger::BaseMessage
  def cmp_nils(a, b); end
  def compare_by_file_and_line(other); end
  def eql?(other); end
  def file; end
  def file=(arg0); end
  def initialize(type:, message:, file: nil, line: nil); end
  def inline?; end
  def line; end
  def line=(arg0); end
  def message; end
  def message=(arg0); end
  def type; end
  def type=(arg0); end
end
class Danger::Violation < Danger::BaseMessage
  def <=>(other); end
  def ==(other); end
  def hash; end
  def initialize(message, sticky, file = nil, line = nil, type: nil); end
  def sticky; end
  def sticky=(arg0); end
  def to_s; end
end
class Danger::Markdown < Danger::BaseMessage
  def <=>(other); end
  def ==(other); end
  def hash; end
  def initialize(message, file = nil, line = nil); end
  def to_s; end
end
class Danger::Plugin
  def initialize(dangerfile); end
  def method_missing(method_sym, *arguments, **keyword_arguments, &block); end
  def pretty_print_instance_variables; end
  def self.all_plugins; end
  def self.clear_external_plugins; end
  def self.inherited(plugin); end
  def self.instance_name; end
end
class Danger::DangerfileMessagingPlugin < Danger::Plugin
  def fail(*failures, **options); end
  def failure(*failures, **options); end
  def initialize(dangerfile); end
  def markdown(*markdowns, **options); end
  def message(*messages, **options); end
  def self.instance_name; end
  def should_ignore_violation(message); end
  def status_report; end
  def violation_report; end
  def warn(*warnings, **options); end
end
class Danger::DangerfileDangerPlugin < Danger::Plugin
  def download(path_or_url); end
  def import_dangerfile(opts); end
  def import_dangerfile_from_gem(name); end
  def import_dangerfile_from_github(slug, branch = nil, path = nil); end
  def import_dangerfile_from_gitlab(slug_or_project_id, branch = nil, path = nil); end
  def import_dangerfile_from_path(path); end
  def import_dangerfile_from_url(url); end
  def import_local(path); end
  def import_plugin(path_or_url); end
  def import_url(url); end
  def scm_provider; end
  def self.instance_name; end
  def validate_file_contains_plugin!(file); end
end
module Danger::Helpers::ArraySubclass
  def <=>(other); end
  def __array__; end
  def __array__=(arg0); end
  def dummy; end
  def initialize(array); end
  def kind_of?(compare_class); end
  def method_missing(name, *args, &block); end
  def respond_to_method(name, *args, &block); end
  def respond_to_missing?(name, include_all); end
  def to_a; end
  def to_ary; end
  include Comparable
end
class Danger::FileList
  def include?(pattern); end
  include Danger::Helpers::ArraySubclass
end
class Danger::DangerfileGitPlugin < Danger::Plugin
  def added_files; end
  def commits; end
  def deleted_files; end
  def deletions; end
  def diff; end
  def diff_for_file(file); end
  def info_for_file(file); end
  def initialize(dangerfile); end
  def insertions; end
  def lines_of_code; end
  def modified_files; end
  def renamed_files; end
  def self.instance_name; end
  def tags; end
end
class Danger::DangerfileGitHubPlugin < Danger::Plugin
  def api; end
  def base_commit; end
  def branch_for_base; end
  def branch_for_head; end
  def create_link(href, text); end
  def dismiss_out_of_range_messages(dismiss = nil); end
  def head_commit; end
  def html_link(paths, full_path: nil); end
  def initialize(dangerfile); end
  def mr_author; end
  def mr_body; end
  def mr_json; end
  def mr_labels; end
  def mr_title; end
  def pr_author; end
  def pr_body; end
  def pr_diff; end
  def pr_draft?; end
  def pr_json; end
  def pr_labels; end
  def pr_title; end
  def review; end
  def self.instance_name; end
  def self.new(dangerfile); end
end
class Danger::DangerfileGitLabPlugin < Danger::Plugin
  def api; end
  def base_commit; end
  def branch_for_base; end
  def branch_for_head; end
  def branch_for_merge; end
  def create_link(href, text); end
  def dismiss_out_of_range_messages(dismiss = nil); end
  def head_commit; end
  def html_link(paths, full_path: nil); end
  def initialize(dangerfile); end
  def mr_author; end
  def mr_body; end
  def mr_changes; end
  def mr_closes_issues; end
  def mr_diff; end
  def mr_json; end
  def mr_labels; end
  def mr_title; end
  def pr_author; end
  def pr_body; end
  def pr_diff; end
  def pr_json; end
  def pr_labels; end
  def pr_title; end
  def repository_web_url; end
  def self.instance_name; end
  def self.new(dangerfile); end
end
class Danger::DangerfileBitbucketServerPlugin < Danger::Plugin
  def base_commit; end
  def branch_for_base; end
  def branch_for_head; end
  def create_link(paths, full_path); end
  def create_markdown_link(href, text); end
  def head_commit; end
  def html_link(paths, full_path: nil); end
  def initialize(dangerfile); end
  def markdown_link(paths, full_path: nil); end
  def pr_author; end
  def pr_body; end
  def pr_description; end
  def pr_json; end
  def pr_link; end
  def pr_title; end
  def self.instance_name; end
  def self.new(dangerfile); end
  def update_pr_build_status(status, build_job_link, description); end
end
class Danger::DangerfileBitbucketCloudPlugin < Danger::Plugin
  def base_commit; end
  def branch_for_base; end
  def branch_for_head; end
  def head_commit; end
  def initialize(dangerfile); end
  def pr_author; end
  def pr_body; end
  def pr_description; end
  def pr_json; end
  def pr_link; end
  def pr_title; end
  def self.instance_name; end
  def self.new(dangerfile); end
end
class Danger::DangerfileVSTSPlugin < Danger::Plugin
  def base_commit; end
  def branch_for_base; end
  def branch_for_head; end
  def branch_name(key); end
  def create_markdown_link(href, text); end
  def head_commit; end
  def initialize(dangerfile); end
  def markdown_link(paths, full_path: nil); end
  def pr_author; end
  def pr_body; end
  def pr_description; end
  def pr_json; end
  def pr_link; end
  def pr_title; end
  def self.instance_name; end
  def self.new(dangerfile); end
end
class Danger::DangerfileLocalOnlyPlugin < Danger::Plugin
  def initialize(dangerfile); end
  def self.instance_name; end
  def self.new(dangerfile); end
end
class Danger::CI
  def initialize(_env); end
  def pull_request_id; end
  def pull_request_id=(arg0); end
  def repo_slug; end
  def repo_slug=(arg0); end
  def repo_url; end
  def repo_url=(arg0); end
  def self.available_ci_sources; end
  def self.inherited(child_class); end
  def self.validates_as_ci?(_env); end
  def self.validates_as_pr?(_env); end
  def supported_request_sources; end
  def supported_request_sources=(arg0); end
  def supports?(request_source); end
end
module Danger::RequestSources
end
class Danger::RequestSources::RequestSource
  def ci_source; end
  def ci_source=(arg0); end
  def fetch_details; end
  def file_url(_organisation: nil, _repository: nil, _branch: nil, _path: nil); end
  def host; end
  def host=(arg0); end
  def ignored_violations; end
  def ignored_violations=(arg0); end
  def initialize(_ci_source, _environment); end
  def inspect; end
  def organisation; end
  def scm; end
  def scm=(arg0); end
  def self.available_request_sources; end
  def self.available_source_names_and_envs; end
  def self.env_vars; end
  def self.inherited(child_class); end
  def self.optional_env_vars; end
  def self.source_name; end
  def setup_danger_branches; end
  def update_build_status(status); end
  def update_pull_request!(_warnings: nil, _errors: nil, _messages: nil, _markdowns: nil); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
end
class Danger::EnvironmentManager
  def ci_source; end
  def ci_source=(arg0); end
  def clean_up; end
  def danger_id; end
  def danger_id=(arg0); end
  def ensure_danger_branches_are_setup; end
  def extract_title_and_subtitle_from_source(repo_url); end
  def fill_environment_vars; end
  def get_repo_source(repo_url); end
  def initialize(env, ui = nil, danger_id = nil); end
  def meta_info_for_base; end
  def meta_info_for_head; end
  def pr?; end
  def raise_error_for_no_request_source(env, ui); end
  def request_source; end
  def request_source=(arg0); end
  def scm; end
  def scm=(arg0); end
  def self.danger_base_branch; end
  def self.danger_head_branch; end
  def self.local_ci_source(env); end
  def self.pr?(env); end
  def travis_note; end
  def ui; end
  def ui=(arg0); end
  def ui_display_no_request_source_error_message(ui, env, title, subtitle); end
end
class Danger::Interviewer
  def ask_with_answers(question, possible_answers); end
  def green_bang; end
  def header(title); end
  def initialize(cork_board); end
  def link(url); end
  def no_delay; end
  def no_delay=(arg0); end
  def no_waiting; end
  def no_waiting=(arg0); end
  def pause(time); end
  def red_bang; end
  def run_command(command, output_command = nil); end
  def say(output); end
  def show_prompt; end
  def ui; end
  def ui=(arg0); end
  def wait_for_return; end
  def yellow_bang; end
end
class Danger::DangerfileGenerator
  def self.create_dangerfile(_path, _ui); end
end
module Danger::Helpers::CommentsParsingHelper
  def danger_table?(table); end
  def parse_comment(comment); end
  def parse_message_from_row(row); end
  def parse_tables_from_comment(comment); end
  def table_kind_from_title(title); end
  def violations_from_table(table); end
end
class Danger::EmojiMapper
  def from_type(type); end
  def initialize(template); end
  def map(emoji); end
  def template; end
end
class FindMaxNumViolations
  def call; end
  def initialize(violations); end
  def violations; end
end
module Danger::Helpers::CommentsHelper
  def apply_template(tables: nil, markdowns: nil, danger_id: nil, template: nil, request_source: nil); end
  def generate_comment(warnings: nil, errors: nil, messages: nil, markdowns: nil, previous_violations: nil, danger_id: nil, template: nil); end
  def generate_description(warnings: nil, errors: nil, template: nil); end
  def generate_inline_comment_body(emoji, message, danger_id: nil, resolved: nil, template: nil); end
  def generate_inline_markdown_body(markdown, danger_id: nil, template: nil); end
  def generate_message_group_comment(message_group:, danger_id: nil, resolved: nil, template: nil); end
  def markdown_link_to_message(message, hide_link); end
  def markdown_parser(text); end
  def messages_are_equivalent(m1, m2); end
  def pluralize(string, count); end
  def process_markdown(violation, hide_link = nil); end
  def random_compliment; end
  def table(name, emoji, violations, all_previous_violations, template: nil); end
  def truncate(string); end
  include Danger::Helpers::CommentsParsingHelper
end
class Danger::Comment
  def body; end
  def generated_by_danger?(danger_id); end
  def id; end
  def initialize(id, body, inline = nil); end
  def inline?; end
  def self.from_github(comment); end
  def self.from_gitlab(comment); end
end
module Danger::RequestSources::GitHubSource
end
class Danger::RequestSources::GitHubSource::ReviewResolver
  def self.same_body?(body1, body2); end
  def self.should_submit?(review, body); end
end
class Danger::RequestSources::GitHubSource::Review
  def body; end
  def fail(message, sticky = nil, file = nil, line = nil); end
  def generate_body(danger_id: nil); end
  def generate_event(violations); end
  def generate_general_violations; end
  def generated_by_danger?(danger_id = nil); end
  def id; end
  def initialize(client, ci_source, review_json = nil); end
  def markdown(message, file = nil, line = nil); end
  def message(message, sticky = nil, file = nil, line = nil); end
  def review_json; end
  def start; end
  def status; end
  def submit; end
  def warn(message, sticky = nil, file = nil, line = nil); end
  include Danger::Helpers::CommentsHelper
end
class Danger::RequestSources::GitHubSource::ReviewUnsupported
  def body; end
  def fail(message, sticky = nil, file = nil, line = nil); end
  def id; end
  def initialize; end
  def markdown(message, file = nil, line = nil); end
  def message(message, sticky = nil, file = nil, line = nil); end
  def review_json; end
  def start; end
  def status; end
  def submit; end
  def warn(message, sticky = nil, file = nil, line = nil); end
end
class GetIgnoredViolation
  def body; end
  def call; end
  def initialize(body); end
end
class Danger::RequestSources::GitHub < Danger::RequestSources::RequestSource
  def api_url; end
  def api_url=(arg0); end
  def client; end
  def delete_old_comments!(except: nil, danger_id: nil); end
  def dismiss_out_of_range_messages; end
  def dismiss_out_of_range_messages=(arg0); end
  def dismiss_out_of_range_messages_for(kind); end
  def fetch_details; end
  def fetch_issue_details(pr_json); end
  def file_url(organisation: nil, repository: nil, branch: nil, path: nil); end
  def find_position_in_diff(diff_lines, message, kind); end
  def get_pr_from_branch(repo_name, branch_name, owner); end
  def host; end
  def host=(arg0); end
  def ignored_violations_from_pr; end
  def initialize(ci_source, environment); end
  def inline_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def issue_comments; end
  def issue_json; end
  def issue_json=(arg0); end
  def markdown_link_to_message(message, hide_link); end
  def merge_violations(*violation_groups); end
  def messages_are_equivalent(m1, m2); end
  def organisation; end
  def parse_message_from_row(row); end
  def pr_diff; end
  def pr_json; end
  def pr_json=(arg0); end
  def regular_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def review; end
  def scm; end
  def self.env_vars; end
  def self.optional_env_vars; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: nil, errors: nil, messages: nil, markdowns: nil, previous_violations: nil, danger_id: nil); end
  def submit_inline_comments_for_kind!(kind, messages, diff_lines, danger_comments, previous_violations, danger_id: nil); end
  def submit_pull_request_status!(warnings: nil, errors: nil, details_url: nil, danger_id: nil); end
  def support_tokenless_auth; end
  def support_tokenless_auth=(arg0); end
  def update_pull_request!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def use_local_git; end
  def use_local_git=(arg0); end
  def valid_access_token?; end
  def valid_bearer_token?; end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  def verify_ssl; end
  def verify_ssl=(arg0); end
  include Danger::Helpers::CommentsHelper
end
class Danger::RepoInfo
  def id; end
  def initialize(slug, id); end
  def slug; end
end
class Danger::FindRepoInfoFromURL
  def call; end
  def initialize(url); end
  def url; end
end
class Danger::FindRepoInfoFromLogs
  def call; end
  def github_host; end
  def initialize(github_host, remote_logs); end
  def regexp; end
  def remote; end
  def remote_logs; end
end
class Danger::NoRepoInfo
  def id; end
  def slug; end
end
class Danger::LocalPullRequest
  def initialize(log_line); end
  def pull_request_id; end
  def sha; end
  def valid?; end
end
class Danger::RemotePullRequest
  def base; end
  def head; end
  def initialize(pull_request_id, head, base); end
  def pull_request_id; end
  def sha; end
  def valid?; end
end
class Danger::NoPullRequest
  def valid?; end
end
class Danger::PullRequestFinder
  def api_url; end
  def both_present?; end
  def call(env: nil); end
  def client(env); end
  def find_pull_request(env); end
  def find_remote_pull_request(env); end
  def find_scm_provider(remote_url); end
  def generate_remote_pull_request(remote_pull_request); end
  def git_logs; end
  def initialize(specific_pull_request_id, repo_slug = nil, remote: nil, git_logs: nil, remote_url: nil); end
  def most_recent_merged_pull_request; end
  def most_recent_squash_and_merged_pull_request; end
  def only_merged_pull_request_present?; end
  def only_squash_and_merged_pull_request_present?; end
  def pick_the_most_recent_one_from_two_matches; end
  def pull_request_ref; end
  def raise_pull_request_not_found!(pull_request); end
  def remote; end
  def remote_url; end
  def repo_slug; end
  def specific_pull_request_id; end
  def to_boolean(maybe_string); end
end
class Danger::Commits
  def base; end
  def base_head; end
  def head; end
  def initialize(base_head); end
end
class Danger::LocalGitRepo < Danger::CI
  def base_commit; end
  def base_commit=(arg0); end
  def commits; end
  def find_pull_request(env); end
  def find_remote_info(env); end
  def found_pull_request; end
  def git; end
  def given_pull_request_url?(env); end
  def head_commit; end
  def head_commit=(arg0); end
  def initialize(env = nil); end
  def missing_remote_error_message; end
  def raise_error_for_missing_remote; end
  def remote_info; end
  def run_git(command); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(_env); end
  def sha; end
  def supported_request_sources; end
end
class Danger::Init < Danger::Runner
  def circle_token; end
  def considered_an_oss_repo?; end
  def current_repo_slug; end
  def darwin?; end
  def info; end
  def initialize(argv); end
  def note_about_clicking_links; end
  def run; end
  def self.options; end
  def setup_access_token; end
  def setup_danger_ci; end
  def setup_dangerfile; end
  def setup_github_account; end
  def show_todo_state; end
  def thanks; end
  def travis_token; end
  def ui; end
  def ui=(arg0); end
  def unsure_ci; end
  def unsure_token; end
  def uses_circle; end
  def uses_travis; end
end
class Danger::HTTPCache
  def delete(key); end
  def entry_has_expired(entry, ttl); end
  def expires_in; end
  def initialize(cache_file = nil, options = nil); end
  def read(key); end
  def write(key, value); end
end
class Danger::LocalSetup
  def cork; end
  def dm; end
  def initialize(dangerfile, cork); end
  def setup(verbose: nil); end
end
class Danger::PrySetup
  def cork; end
  def initialize(cork); end
  def setup_pry(dangerfile_path, command); end
  def validate_pry_available(command); end
end
class Danger::Local < Danger::Runner
  def configure_octokit(cache_dir); end
  def initialize(argv); end
  def run; end
  def self.options; end
  def validate!; end
end
class Danger::DryRun < Danger::Runner
  def initialize(argv); end
  def run; end
  def self.options; end
  def validate!; end
end
class Danger::Staging < Danger::Runner
  def initialize(argv); end
  def run; end
  def self.options; end
  def validate!; end
end
class Danger::Systems < Danger::Runner
end
class Danger::CIDocs < Danger::Systems
  def run; end
end
class Danger::PR < Danger::Runner
  def configure_octokit(cache_dir); end
  def initialize(argv); end
  def run; end
  def self.options; end
  def validate!; end
end
class Danger::PluginParser
  def attribute_parser(gem_path, attribute); end
  def classes_in_file; end
  def initialize(paths, verbose = nil); end
  def method_params(method); end
  def method_parser(gem_path, meth); end
  def method_return_string(meth); end
  def parse; end
  def plugins_from_classes(classes); end
  def registry; end
  def registry=(arg0); end
  def setup_yard(verbose); end
  def to_h(classes); end
  def to_json; end
  def to_json_string; end
end
class Danger::GemsResolver
  def all_gems_metadata; end
  def call; end
  def create_gemfile_from_gem_names; end
  def dir; end
  def gem_metadata(gem); end
  def gem_names; end
  def gems; end
  def initialize(gem_names); end
  def paths; end
  def real_gems; end
end
class Danger::PluginFileResolver
  def initialize(references); end
  def refs; end
  def resolve; end
end
class Danger::PluginLinter
  def apply_rules(json, type, rules); end
  def class_rules; end
  def errors; end
  def errors=(arg0); end
  def failed?; end
  def initialize(json); end
  def json; end
  def json=(arg0); end
  def link(ref); end
  def lint; end
  def method_rules; end
  def print_summary(ui); end
  def warnings; end
  def warnings=(arg0); end
end
class Danger::PluginLinter::Rule
  def description; end
  def description=(arg0); end
  def function; end
  def function=(arg0); end
  def initialize(modifier, ref, title, description, function); end
  def metadata; end
  def metadata=(arg0); end
  def modifier; end
  def modifier=(arg0); end
  def object_applied_to; end
  def ref; end
  def ref=(arg0); end
  def title; end
  def title=(arg0); end
  def type; end
  def type=(arg0); end
end
class Danger::PluginLint < CLAide::Command::Plugins
  def cork; end
  def cork=(arg0); end
  def initialize(argv); end
  def run; end
  def self.options; end
end
class Danger::PluginJSON < CLAide::Command::Plugins
  def cork; end
  def cork=(arg0); end
  def initialize(argv); end
  def run; end
end
class Danger::PluginReadme < CLAide::Command::Plugins
  def cork; end
  def cork=(arg0); end
  def initialize(argv); end
  def json; end
  def json=(arg0); end
  def markdown; end
  def markdown=(arg0); end
  def run; end
end
class Danger::DangerfileCommand < Danger::Runner
  def self.options; end
end
class Danger::DangerfileInit < Danger::DangerfileCommand
  def run; end
end
class Danger::DangerfileGem < Danger::DangerfileCommand
  def initialize(argv); end
  def run; end
  def self.description; end
  def validate!; end
end
class Danger::Runner < CLAide::Command
  def adjust_colored2_output(argv); end
  def cork; end
  def cork=(arg0); end
  def initialize(argv); end
  def run; end
  def self.options; end
  def validate!; end
end
class String
  def danger_pluralize(count); end
  def danger_truncate(limit); end
  def danger_underscore; end
end
class Danger::Executor
  def base_branch(user_specified_base_branch); end
  def commit_request(ci_name); end
  def head_branch(user_specified_head_branch); end
  def initialize(system_env); end
  def run(env: nil, dm: nil, cork: nil, base: nil, head: nil, dangerfile_path: nil, danger_id: nil, new_comment: nil, fail_on_errors: nil, fail_if_no_pr: nil, remove_previous_comments: nil); end
  def system_env; end
  def validate!(cork, fail_if_no_pr: nil); end
  def validate_ci!; end
  def validate_pr!(cork, fail_if_no_pr); end
end
class Danger::Appcenter < Danger::CI
  def initialize(env); end
  def self.owner_for_github(env); end
  def self.pr_from_env(env); end
  def self.repo_identifier_for_github(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::AppVeyor < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::AzurePipelines < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Bamboo < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::BitbucketPipelines < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::RequestSources::GitLab < Danger::RequestSources::RequestSource
  def base_commit; end
  def client; end
  def commits_json; end
  def commits_json=(arg0); end
  def delete_old_comments!(except: nil, danger_id: nil); end
  def dismiss_out_of_range_messages; end
  def dismiss_out_of_range_messages=(arg0); end
  def dismiss_out_of_range_messages_for(kind); end
  def endpoint; end
  def endpoint=(arg0); end
  def fetch_details; end
  def file_url(organisation: nil, repository: nil, branch: nil, path: nil); end
  def find_old_position_in_diff(changes, message); end
  def generate_addition_lines(diff); end
  def host; end
  def host=(arg0); end
  def ignored_violations_from_pr; end
  def initialize(ci_source, environment); end
  def inline_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def is_out_of_range(changes, message); end
  def markdown_link_to_message(message, _); end
  def merge_violations(*violation_groups); end
  def mr_changed_paths; end
  def mr_changes; end
  def mr_closes_issues; end
  def mr_comments; end
  def mr_diff; end
  def mr_discussions; end
  def mr_json; end
  def mr_json=(arg0); end
  def organisation; end
  def regular_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def scm; end
  def self.env_vars; end
  def self.optional_env_vars; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: nil, errors: nil, messages: nil, markdowns: nil, previous_violations: nil, danger_id: nil); end
  def submit_inline_comments_for_kind!(kind, messages, diff_lines, danger_comments, previous_violations, danger_id: nil); end
  def supports_inline_comments; end
  def update_pull_request!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def update_pull_request_with_inline_comments!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def update_pull_request_without_inline_comments!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  include Danger::Helpers::CommentsHelper
end
class Danger::Bitrise < Danger::CI
  def initialize(env); end
  def repo_slug_asgiturl(url); end
  def repo_slug_from(url); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Buddybuild < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Buildkite < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::CircleAPI
  def client; end
  def fetch_build(repo_slug, build_number, token); end
  def fetch_pull_request_url(repo_slug, build_number, token); end
  def pull_request?(env); end
  def pull_request_url(env); end
end
class Danger::CircleCI < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Cirrus < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::CodeBuild < Danger::CI
  def initialize(env); end
  def self.extract_pr_url(env); end
  def self.extract_repo_slug(env); end
  def self.extract_repo_url(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Codefresh < Danger::CI
  def initialize(env); end
  def self.slug_from(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Codemagic < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Codeship < Danger::CI
  def initialize(env); end
  def self.owner_for_github(env); end
  def self.pr_from_env(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::RequestSources::LocalOnly < Danger::RequestSources::RequestSource
  def commits_json; end
  def commits_json=(arg0); end
  def fetch_details; end
  def initialize(ci_source, _environment); end
  def mr_json; end
  def mr_json=(arg0); end
  def organisation; end
  def scm; end
  def self.env_vars; end
  def setup_danger_branches; end
  def update_pull_request!(_hash_needed); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  include Danger::Helpers::CommentsHelper
end
class Danger::Concourse < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::DotCi < Danger::CI
  def initialize(env); end
  def self.pull_request_id(env); end
  def self.repo_url(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Drone < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_ci_post_06?(env); end
  def self.validates_as_ci_pre_06?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::GitHubActions < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::GitLabCI < Danger::CI
  def initialize(env); end
  def self.determine_pull_or_merge_request_id(env); end
  def self.slug_from(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::RequestSources::BitbucketServerAPI
  def build_status_body(status, build_job_link, description); end
  def credentials_given?; end
  def delete(uri); end
  def delete_comment(id, version); end
  def fetch_json(uri); end
  def fetch_last_comments; end
  def fetch_pr_json; end
  def host; end
  def host=(arg0); end
  def http(uri); end
  def initialize(project, slug, pull_request_id, environment); end
  def inspect; end
  def key; end
  def key=(arg0); end
  def post(uri, body); end
  def post_comment(text); end
  def pr_api_endpoint; end
  def pr_api_endpoint=(arg0); end
  def project; end
  def project=(arg0); end
  def pull_request(*arg0); end
  def update_pr_build_status(status, changeset, build_job_link, description); end
  def use_ssl; end
  def verify_ssl; end
  def verify_ssl=(arg0); end
end
class Danger::RequestSources::CodeInsightsAPI
  def annotation_endpoint_at_commit(commit); end
  def delete_report(commit); end
  def host; end
  def host=(arg0); end
  def initialize(project, slug, environment); end
  def inspect; end
  def logo_url; end
  def logo_url=(arg0); end
  def password; end
  def password=(arg0); end
  def post_annotations(commit, inline_warnings, inline_errors, inline_messages); end
  def put_report(commit, inline_errors_count); end
  def ready?; end
  def report_description; end
  def report_description=(arg0); end
  def report_endpoint_at_commit(commit); end
  def report_key; end
  def report_key=(arg0); end
  def report_title; end
  def report_title=(arg0); end
  def send_report(commit, inline_warnings, inline_errors, inline_messages); end
  def use_ssl; end
  def username; end
  def username=(arg0); end
  def violation_hash_with_severity(violation, severity); end
end
class Danger::RequestSources::BitbucketServer < Danger::RequestSources::RequestSource
  def delete_old_comments(danger_id: nil); end
  def fetch_details; end
  def host; end
  def initialize(ci_source, environment); end
  def inline_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def main_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def organisation; end
  def pr_json; end
  def pr_json=(arg0); end
  def scm; end
  def self.env_vars; end
  def self.optional_env_vars; end
  def setup_danger_branches; end
  def update_pr_build_status(status, build_job_link, description); end
  def update_pull_request!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  include Danger::Helpers::CommentsHelper
end
class Danger::RequestSources::BitbucketCloudAPI
  def access_token; end
  def access_token=(arg0); end
  def base_url(version); end
  def credentials_given?; end
  def credentials_not_available; end
  def delete(uri); end
  def delete_comment(id); end
  def error_fetching_json(url, status_code); end
  def fetch_access_token(environment); end
  def fetch_comments; end
  def fetch_json(uri); end
  def fetch_pr_from_branch(branch_name); end
  def fetch_pr_json; end
  def host; end
  def host=(arg0); end
  def initialize(repo_slug, pull_request_id, branch_name, environment); end
  def initialize_my_uuid(uuid); end
  def inspect; end
  def my_uuid; end
  def post(uri, body); end
  def post_comment(text, file: nil, line: nil); end
  def pr_api_endpoint; end
  def project; end
  def project=(arg0); end
  def prs_api_url(branch_name); end
  def pull_request(*arg0); end
  def pull_request_id; end
  def pull_request_id=(arg0); end
  def slug; end
  def slug=(arg0); end
end
class Danger::RequestSources::BitbucketCloud < Danger::RequestSources::RequestSource
  def delete_old_comments(danger_id: nil); end
  def fetch_details; end
  def host; end
  def initialize(ci_source, environment); end
  def organisation; end
  def pr_json; end
  def pr_json=(arg0); end
  def scm; end
  def self.env_vars; end
  def self.optional_env_vars; end
  def setup_danger_branches; end
  def update_inline_comments_for_kind!(kind, messages, danger_id: nil); end
  def update_pr_by_line!(message_groups:, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def update_pull_request!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  include Danger::Helpers::CommentsHelper
end
class Danger::Jenkins < Danger::CI
  def initialize(env); end
  def project_url; end
  def project_url=(arg0); end
  def self.pull_request_id(env); end
  def self.repo_slug(repo_url); end
  def self.repo_url(env); end
  def self.slug_bitbucket(repo_url); end
  def self.slug_fallback(repo_url); end
  def self.slug_http(repo_url); end
  def self.slug_ssh(repo_url); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Jenkins::EnvNotFound < StandardError
  def initialize; end
end
class Danger::LocalOnlyGitRepo < Danger::CI
  def base_commit; end
  def base_commit=(arg0); end
  def git; end
  def head_commit; end
  def head_commit=(arg0); end
  def initialize(env = nil); end
  def run_git(command); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(_env); end
  def supported_request_sources; end
end
class Danger::Screwdriver < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Semaphore < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Surf < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::TeamCity < Danger::CI
  def bitbucket_pr_from_env(env); end
  def extract_bitbucket_server_variables!(env); end
  def extract_bitbucket_variables!(env); end
  def extract_github_variables!(env); end
  def extract_gitlab_variables!(env); end
  def initialize(env); end
  def self.validates_as_bitbucket_cloud_pr?(env); end
  def self.validates_as_bitbucket_server_pr?(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_github_pr?(env); end
  def self.validates_as_gitlab_pr?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::Travis < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::RequestSources::VSTSAPI
  def credentials_given?; end
  def fetch_json(uri); end
  def fetch_last_comments; end
  def fetch_pr_json; end
  def host; end
  def host=(arg0); end
  def initialize(_project, slug, pull_request_id, environment); end
  def inspect; end
  def min_api_version_for_comments; end
  def min_api_version_for_comments=(arg0); end
  def patch(uri, body); end
  def post(uri, body); end
  def post_comment(text); end
  def post_inline_comment(text, file, line); end
  def pr_api_endpoint; end
  def pr_api_endpoint=(arg0); end
  def supports_comments?; end
  def update_comment(thread, id, new_comment); end
  def use_ssl; end
end
class Danger::RequestSources::VSTS < Danger::RequestSources::RequestSource
  def client; end
  def fetch_details; end
  def host; end
  def initialize(ci_source, environment); end
  def inline_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def merge_violations(*violation_groups); end
  def messages_are_equivalent(m1, m2); end
  def organisation; end
  def post_new_comment(comment); end
  def pr_json; end
  def pr_json=(arg0); end
  def regular_violations_group(warnings: nil, errors: nil, messages: nil, markdowns: nil); end
  def scm; end
  def self.env_vars; end
  def self.optional_env_vars; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: nil, errors: nil, messages: nil, markdowns: nil, previous_violations: nil, danger_id: nil); end
  def submit_inline_comments_for_kind!(kind, messages, danger_threads, previous_violations, danger_id: nil); end
  def update_old_comment(new_comment, danger_id: nil); end
  def update_pull_request!(warnings: nil, errors: nil, messages: nil, markdowns: nil, danger_id: nil, new_comment: nil, remove_previous_comments: nil); end
  def validates_as_api_source?; end
  def validates_as_ci?; end
  include Danger::Helpers::CommentsHelper
end
class Danger::VSTS < Danger::CI
  def initialize(env); end
  def self.github_slug(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def self.vsts_slug(env); end
  def supported_request_sources; end
end
class Danger::XcodeCloud < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::XcodeServer < Danger::CI
  def initialize(env); end
  def self.validates_as_ci?(env); end
  def self.validates_as_pr?(env); end
  def supported_request_sources; end
end
class Danger::GitRepo
  def commit_exists?(sha1); end
  def commit_is_ref?(commit); end
  def commit_not_exists?(sha1); end
  def commits_in_branch_count(from, to); end
  def default_env; end
  def diff; end
  def diff=(arg0); end
  def diff_for_folder(folder, from: nil, to: nil, lookup_top_level: nil); end
  def ensure_commitish_exists!(commitish); end
  def ensure_commitish_exists_on_branch!(branch, commitish); end
  def exec(string); end
  def find_merge_base(repo, from, to); end
  def find_merge_base_with_incremental_fetch(repo, from, to); end
  def folder; end
  def folder=(arg0); end
  def git_fetch_branch_to_depth(branch, depth); end
  def git_in_depth_fetch; end
  def head_commit; end
  def log; end
  def log=(arg0); end
  def origins; end
  def possible_merge_base(repo, from, to); end
  def raise_if_we_cannot_find_the_commit(commitish); end
  def renamed_files; end
  def tags; end
end
module Git
end
class Git::Base
  def merge_base(commit1, commit2, *other_commits); end
end
