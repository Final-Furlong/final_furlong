# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kwalify` gem.
# Please instead update this file by running `bin/tapioca gem kwalify`.

module Kwalify
  extend ::Kwalify::Types
  extend ::Kwalify::ErrorHelper

  class << self
    # obsolete
    def meta_validator; end

    def msg(key); end
    def word(key); end
  end
end

class Kwalify::AssertionError < ::Kwalify::KwalifyError
  # @return [AssertionError] a new instance of AssertionError
  def initialize(msg); end
end

class Kwalify::BaseError < ::Kwalify::KwalifyError
  # @return [BaseError] a new instance of BaseError
  def initialize(message = T.unsafe(nil), path = T.unsafe(nil), value = T.unsafe(nil), rule = T.unsafe(nil), error_symbol = T.unsafe(nil)); end

  def <=>(ex); end
  def _to_s; end

  # Returns the value of attribute column.
  def column; end

  # Sets the attribute column
  #
  # @param value the value to set the attribute column to.
  def column=(_arg0); end

  # Returns the value of attribute error_symbol.
  def error_symbol; end

  # Sets the attribute error_symbol
  #
  # @param value the value to set the attribute error_symbol to.
  def error_symbol=(_arg0); end

  # Returns the value of attribute filename.
  def filename; end

  # Sets the attribute filename
  #
  # @param value the value to set the attribute filename to.
  def filename=(_arg0); end

  # Returns the value of attribute linenum.
  def linenum; end

  # Sets the attribute linenum
  #
  # @param value the value to set the attribute linenum to.
  def linenum=(_arg0); end

  def message; end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Returns the value of attribute rule.
  def rule; end

  # Sets the attribute rule
  #
  # @param value the value to set the attribute rule to.
  def rule=(_arg0); end

  def to_s; end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end
end

# base class for Yaml::Parser
class Kwalify::BaseParser
  def _getch; end
  def _set_column_and_linenum(s); end

  # Returns the value of attribute column.
  def column; end

  # @return [Boolean]
  def eos?; end

  # Returns the value of attribute filename.
  def filename; end

  def group(n); end

  # Returns the value of attribute linenum.
  def linenum; end

  # @return [Boolean]
  def match?(regexp); end

  def peep(n = T.unsafe(nil)); end
  def reset(input, filename = T.unsafe(nil), untabify = T.unsafe(nil)); end
  def scan(regexp); end
  def scan_string; end

  protected

  def _syntax_error(message, path = T.unsafe(nil), linenum = T.unsafe(nil), column = T.unsafe(nil)); end
end

Kwalify::BaseParser::CHAR_TABLE = T.let(T.unsafe(nil), Hash)
module Kwalify::Boolean; end

module Kwalify::ErrorHelper
  # module_function
  #
  # @raise [AssertionError]
  def assert_error(message = T.unsafe(nil)); end

  def schema_error(error_symbol, rule, path, val, args = T.unsafe(nil)); end

  private

  def _build_message(message_key, val, args); end
  def validate_error(error_symbol, rule, path, val, args = T.unsafe(nil)); end

  class << self
    def _build_message(message_key, val, args); end
    def validate_error(error_symbol, rule, path, val, args = T.unsafe(nil)); end
  end
end

module Kwalify::Json; end
class Kwalify::KwalifyError < ::StandardError; end
Kwalify::META_VALIDATOR = T.let(T.unsafe(nil), Kwalify::MetaValidator)

# ex.
#   meta_validator = Kwalify::MetaValidator.instance()
#   schema = File.load_file('schema.yaml')
#   errors = meta_validator.validate(schema)
#   if !errors.empty?
#     errors.each do |error|
#       puts "[#{error.path}] #{error.message}"
#     end
#   end
class Kwalify::MetaValidator < ::Kwalify::Validator
  # @return [MetaValidator] a new instance of MetaValidator
  def initialize(schema, &block); end

  def validate_hook(value, rule, path, errors); end

  class << self
    def instance; end
  end
end

Kwalify::MetaValidator::META_SCHEMA = T.let(T.unsafe(nil), String)

# alias of YamlParser class
class Kwalify::Parser < ::Kwalify::YamlParser
  # @return [Parser] a new instance of Parser
  def initialize(yaml_str); end
end

# base class of yaml parser
#
# ex.
#   str = ARGF.read()
#   parser = Kwalify::PlainYamlParser.new(str)
#   doc = parser.parse()
#   p doc
class Kwalify::PlainYamlParser
  # @return [PlainYamlParser] a new instance of PlainYamlParser
  def initialize(yaml_str); end

  # @return [Boolean]
  def has_next?; end

  def parse; end
  def parse_all; end

  protected

  def add_to_map(map, key, value, linenum); end
  def add_to_seq(seq, value, linenum); end
  def create_mapping(linenum = T.unsafe(nil)); end
  def create_scalar(value, linenum = T.unsafe(nil)); end
  def create_sequence(linenum = T.unsafe(nil)); end
  def current_line; end
  def current_linenum; end
  def merge_map(map, map2, linenum); end
  def set_default(map, value, linenum); end
  def set_map_with(map, key, value, linenum); end
  def set_seq_at(seq, i, value, linenum); end

  private

  def _getchar; end
  def _getline; end
  def assert(bool_expr); end
  def current_char; end
  def getchar; end
  def getchar_or_nl; end
  def getlabel; end
  def getline; end
  def parse_alias(column, value); end
  def parse_anchor(column, value); end
  def parse_block_text(column, value); end
  def parse_child(column); end
  def parse_flow(depth); end
  def parse_flow_map(depth); end
  def parse_flow_map_item(depth); end
  def parse_flow_scalar(depth); end
  def parse_flow_seq(depth); end
  def parse_flow_seq_item(depth); end

  # flowstyle     ::=  flow_seq | flow_map | flow_scalar | alias
  #
  # flow_seq      ::=  '[' [ flow_seq_item { ',' sp flow_seq_item } ] ']'
  # flow_seq_item ::=  flowstyle
  #
  # flow_map      ::=  '{' [ flow_map_item { ',' sp flow_map_item } ] '}'
  # flow_map_item ::=  flowstyle ':' sp flowstyle
  #
  # flow_scalar   ::=  string | number | boolean | symbol | date
  def parse_flowstyle(column, value); end

  def parse_mapping(column, value); end
  def parse_scalar(indent, value); end
  def parse_sequence(column, value); end
  def parse_tag(column, value); end
  def parse_value(column, value, value_start_column); end
  def register_alias(label); end
  def register_anchor(label, data); end
  def reset_sbuf(str); end
  def resolve_aliases(data); end

  # --
  # def syntax_error(error_symbol, linenum=@linenum)
  #  msg = Kwalify.msg(error_symbol) % [linenum]
  #  return Kwalify::YamlSyntaxError.new(msg, linenum,error_symbol)
  # end
  # ++
  def syntax_error(error_symbol, arg = T.unsafe(nil), linenum = T.unsafe(nil)); end

  def to_scalar(str); end

  # @return [Boolean]
  def white?(ch); end
end

class Kwalify::PlainYamlParser::Alias
  # @return [Alias] a new instance of Alias
  def initialize(label, linenum); end

  # Returns the value of attribute label.
  def label; end

  # Returns the value of attribute linenum.
  def linenum; end
end

Kwalify::RELEASE = T.let(T.unsafe(nil), String)

class Kwalify::Rule
  include ::Kwalify::ErrorHelper

  # @return [Rule] a new instance of Rule
  def initialize(hash = T.unsafe(nil), parent = T.unsafe(nil)); end

  def _init(hash, path = T.unsafe(nil), rule_table = T.unsafe(nil)); end
  def _uniqueness_check_table; end

  # Returns the value of attribute assert.
  def assert; end

  # Returns the value of attribute assert_proc.
  def assert_proc; end

  # Returns the value of attribute classname.
  def classname; end

  # Returns the value of attribute classobj.
  def classobj; end

  # Returns the value of attribute default.
  def default; end

  # Returns the value of attribute desc.
  def desc; end

  # Returns the value of attribute enum.
  def enum; end

  # Returns the value of attribute ident.
  def ident; end

  # Returns the value of attribute length.
  def length; end

  # Returns the value of attribute mapping.
  def mapping; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  # Returns the value of attribute pattern.
  def pattern; end

  # Returns the value of attribute range.
  def range; end

  # Returns the value of attribute regexp.
  def regexp; end

  # Returns the value of attribute required.
  def required; end

  # Returns the value of attribute sequence.
  def sequence; end

  # Returns the value of attribute type.
  def type; end

  # Returns the value of attribute type_class.
  def type_class; end

  # Returns the value of attribute unique.
  def unique; end

  protected

  def _inspect(str = T.unsafe(nil), level = T.unsafe(nil), done = T.unsafe(nil)); end
  def get_init_method(sym); end

  private

  def _check_confliction(hash, rule, path); end
  def _init_assert_value(val, rule, path); end
  def _init_class_value(val, rule, path); end
  def _init_default_value(val, rule, path); end
  def _init_desc_value(val, rule, path); end
  def _init_enum_value(val, rule, path); end
  def _init_ident_value(val, rule, path); end
  def _init_length_value(val, rule, path); end
  def _init_mapping_value(val, rule, path, rule_table); end
  def _init_name_value(val, rule, path); end
  def _init_pattern_value(val, rule, path); end
  def _init_range_value(val, rule, path); end
  def _init_required_value(val, rule, path); end
  def _init_sequence_value(val, rule, path, rule_table); end
  def _init_type_value(val, rule, path); end
  def _init_unique_value(val, rule, path); end
end

module Kwalify::Scalar; end

class Kwalify::SchemaError < ::Kwalify::BaseError
  # @return [SchemaError] a new instance of SchemaError
  def initialize(message = T.unsafe(nil), path = T.unsafe(nil), rule = T.unsafe(nil), value = T.unsafe(nil), error_symbol = T.unsafe(nil)); end
end

# syntax error for YAML and JSON
class Kwalify::SyntaxError < ::Kwalify::BaseError
  # KwalifyError
  #
  # @return [SyntaxError] a new instance of SyntaxError
  def initialize(msg, linenum = T.unsafe(nil), error_symbol = T.unsafe(nil)); end

  # attr_accessor :linenum, :error_symbol
  def message; end
end

module Kwalify::Text
  include ::Kwalify::Scalar
end

module Kwalify::Types
  private

  # --
  # def collection_class?(klass)
  #  return klass.is_a?(Array) || klass.is_a?(Hash)
  # end
  #
  # def scalar_class?(klass)
  #  return !klass.is_a?(Array) && !klass.is_a?(Hash) && klass != Object
  # end
  #
  # @return [Boolean]
  def collection?(val); end

  # @return [Boolean]
  def collection_type?(type); end

  # @return [Boolean]
  def scalar?(val); end

  # @return [Boolean]
  def scalar_type?(type); end

  class << self
    # --
    # def collection_class?(klass)
    #  return klass.is_a?(Array) || klass.is_a?(Hash)
    # end
    #
    # def scalar_class?(klass)
    #  return !klass.is_a?(Array) && !klass.is_a?(Hash) && klass != Object
    # end
    #
    # @return [Boolean]
    def collection?(val); end

    # @return [Boolean]
    def collection_type?(type); end

    def get_type_class(type); end

    # @return [Boolean]
    def scalar?(val); end

    # @return [Boolean]
    def scalar_type?(type); end

    def type_class(type); end
    def type_table; end
  end
end

# use "str" as default of @type
Kwalify::Types::DEFAULT_TYPE = T.let(T.unsafe(nil), String)

module Kwalify::Util
  private

  def _traverse_rule(rule, _done = T.unsafe(nil), &block); end
  def _traverse_schema(hash, _done = T.unsafe(nil), &block); end

  # create a hash table from list of hash with primary key.
  #
  # ex.
  #   hashlist = [
  #     { "name"=>"Foo", "gender"=>"M", "age"=>20, },
  #     { "name"=>"Bar", "gender"=>"F", "age"=>25, },
  #     { "name"=>"Baz", "gender"=>"M", "age"=>30, },
  #   ]
  #   hashtable = YamlHelper.create_hashtable(hashlist, "name")
  #   p hashtable
  #       # => { "Foo" => { "name"=>"Foo", "gender"=>"M", "age"=>20, },
  #       #      "Bar" => { "name"=>"Bar", "gender"=>"F", "age"=>25, },
  #       #      "Baz" => { "name"=>"Baz", "gender"=>"M", "age"=>30, }, }
  def create_hashtable(hashlist, primarykey, flag_duplicate_check = T.unsafe(nil)); end

  # get class object. if not found, NameError raised.
  def get_class(classname); end

  # get nested value directly.
  #
  # ex.
  #   val = YamlHelper.get_value(obj, ['aaa', 0, 'xxx'])
  #
  # This is equal to the following:
  #   begin
  #     val = obj['aaa'][0]['xxx']
  #   rescue NameError
  #     val = nil
  #   end
  def get_value(obj, path); end

  # traverse rule
  #
  # ex.
  #   schema = YAML.load_file('myschema.yaml')
  #   validator = Kwalify::Validator.new(schema)
  #   Kwalify::Util.traverse_rule(validator) do |rule|
  #     p rule if rule.classname
  #   end
  def traverse_rule(validator, &block); end

  # traverse schema
  #
  # ex.
  #   schema = YAML.load_file('myschema.yaml')
  #   Kwalify::Util.traverse_schema(schema) do |rulehash|
  #     ## add module prefix to class name
  #     if rulehash['class']
  #       rulehash['class'] = 'MyModule::' + rulehash['class']
  #     end
  #   end
  def traverse_schema(schema, &block); end

  # expand tab character to spaces
  #
  # ex.
  #   untabified_str = YamlHelper.untabify(tabbed_str)
  def untabify(str, width = T.unsafe(nil)); end

  class << self
    # @yield [rule]
    def _traverse_rule(rule, _done = T.unsafe(nil), &block); end

    # @yield [hash]
    def _traverse_schema(hash, _done = T.unsafe(nil), &block); end

    # create a hash table from list of hash with primary key.
    #
    # ex.
    #   hashlist = [
    #     { "name"=>"Foo", "gender"=>"M", "age"=>20, },
    #     { "name"=>"Bar", "gender"=>"F", "age"=>25, },
    #     { "name"=>"Baz", "gender"=>"M", "age"=>30, },
    #   ]
    #   hashtable = YamlHelper.create_hashtable(hashlist, "name")
    #   p hashtable
    #       # => { "Foo" => { "name"=>"Foo", "gender"=>"M", "age"=>20, },
    #       #      "Bar" => { "name"=>"Bar", "gender"=>"F", "age"=>25, },
    #       #      "Baz" => { "name"=>"Baz", "gender"=>"M", "age"=>30, }, }
    def create_hashtable(hashlist, primarykey, flag_duplicate_check = T.unsafe(nil)); end

    # get class object. if not found, NameError raised.
    def get_class(classname); end

    # get nested value directly.
    #
    # ex.
    #   val = YamlHelper.get_value(obj, ['aaa', 0, 'xxx'])
    #
    # This is equal to the following:
    #   begin
    #     val = obj['aaa'][0]['xxx']
    #   rescue NameError
    #     val = nil
    #   end
    def get_value(obj, path); end

    # traverse rule
    #
    # ex.
    #   schema = YAML.load_file('myschema.yaml')
    #   validator = Kwalify::Validator.new(schema)
    #   Kwalify::Util.traverse_rule(validator) do |rule|
    #     p rule if rule.classname
    #   end
    def traverse_rule(validator, &block); end

    # traverse schema
    #
    # ex.
    #   schema = YAML.load_file('myschema.yaml')
    #   Kwalify::Util.traverse_schema(schema) do |rulehash|
    #     ## add module prefix to class name
    #     if rulehash['class']
    #       rulehash['class'] = 'MyModule::' + rulehash['class']
    #     end
    #   end
    def traverse_schema(schema, &block); end

    # expand tab character to spaces
    #
    # ex.
    #   untabified_str = YamlHelper.untabify(tabbed_str)
    def untabify(str, width = T.unsafe(nil)); end
  end
end

# add hash-like methods
module Kwalify::Util::HashLike
  def [](key); end
  def []=(key, val); end

  # not necessary
  def each; end

  # --
  # def keys()
  #  instance_variables().collect { |name| name[1, name.length-1] }
  # end
  # ++
  #
  # @return [Boolean]
  def key?(key); end
end

class Kwalify::ValidationError < ::Kwalify::BaseError
  # @return [ValidationError] a new instance of ValidationError
  def initialize(message = T.unsafe(nil), path = T.unsafe(nil), rule = T.unsafe(nil), value = T.unsafe(nil), error_symbol = T.unsafe(nil)); end
end

# validate YAML document
#
# ex1. validate yaml document
#   schema = YAML.load_file('schema.yaml')
#   validator = Kwalify::Validator.new(schema)
#   document = YAML.load_file('document.yaml')
#   erros = validator.validate(document)
#   if errors && !errors.empty?
#     errors.each do |err|
#       puts "- [#{err.path}] #{err.message}"
#     end
#   end
#
# ex2. validate with parsing
#   schema = YAML.load_file('schema.yaml')
#   validator = Kwalify::Validator.new(schema)
#   parser = Kwalify::Yaml::Parser.new(validator)
#   document = parser.parse(File.read('document.yaml'))
#   errors = parser.errors
#   if errors && errors.empty?
#     errors.each do |e|
#       puts "#{e.linenum}:#{e.column} [#{e.path}] #{e.message}"
#     end
#   end
class Kwalify::Validator
  include ::Kwalify::ErrorHelper

  # @return [Validator] a new instance of Validator
  def initialize(hash_or_rule, &block); end

  def _inspect; end
  def _validate(value, rule, path, errors, done, uniq_table, recursive = T.unsafe(nil)); end
  def _validate_mapping_required_keys(hash, map_rule, path, errors); end
  def _validate_unique(value, rule, path, errors, uniq_table); end

  # Returns the value of attribute rule.
  def rule; end

  def validate(value); end

  protected

  def validate_hook(value, rule, path, errors); end

  private

  def _validate_assert(value, rule, path, errors); end
  def _validate_enum(value, rule, path, errors); end
  def _validate_length(value, rule, path, errors); end
  def _validate_mapping(hash, map_rule, path, errors, done, uniq_table, recursive = T.unsafe(nil)); end
  def _validate_pattern(value, rule, path, errors); end
  def _validate_range(value, rule, path, errors); end
  def _validate_scalar(value, rule, path, errors, done, uniq_table); end
  def _validate_sequence(list, seq_rule, path, errors, done, uniq_table, recursive = T.unsafe(nil)); end
end

module Kwalify::Yaml
  class << self
    # read yaml_str, parse it, and return yaml document.
    #
    # opts:
    # ::validator:        Kwalify::Validator object
    # ::preceding_aliass: allow preceding alias if true
    # ::data_binding:     enable data binding if true
    # ::untabify:         expand tab chars if true
    # ::filename:         filename
    def load(yaml_str, opts = T.unsafe(nil)); end

    # read file, parse it, and return yaml document.
    # see Kwalify::Yaml::Parser.load()
    def load_file(filename, opts = T.unsafe(nil)); end
  end
end

# YAML parser with validator
#
# ex.
#   schema = YAML.load_file('schema.yaml')
#   require 'kwalify'
#   validator = Kwalify::Validator.new(schema)
#   parser = Kwalify::Yaml::Parser.new(validator)  # validator is optional
#   #parser.preceding_alias = true  # optional
#   #parser.data_binding = true     # optional
#   ydoc = parser.parse_file('data.yaml')
#   errors = parser.errors
#   if errors && !errors.empty?
#     errors.each do |e|
#       puts "line=#{e.linenum}, path=#{e.path}, mesg=#{e.message}"
#     end
#   end
class Kwalify::Yaml::Parser < ::Kwalify::BaseParser
  # @return [Parser] a new instance of Parser
  def initialize(validator = T.unsafe(nil), properties = T.unsafe(nil)); end

  def _parse_map_value(map, map_rule, path, level, key, is_merged, uniq_table, _linenum, _column, _linenum2, _column2); end
  def _set_error_info(linenum = T.unsafe(nil), column = T.unsafe(nil), &block); end

  # *V
  def _validate_map_value(map, map_rule, rule, path, uniq_table, key, val, _linenum, _column); end

  # boolean
  def data_binding; end

  # boolean
  def data_binding=(_arg0); end

  # @return [Boolean]
  def document_start?; end

  # Returns the value of attribute errors.
  def errors; end

  # @return [Boolean]
  def has_next?; end

  def location(path); end

  # Class
  def mapping_class; end

  # Class
  def mapping_class=(_arg0); end

  def parse(input = T.unsafe(nil), opts = T.unsafe(nil)); end
  def parse_alias(rule, path, uniq_table, container); end
  def parse_anchor(rule, path, uniq_table, container); end
  def parse_block_map(map, map_rule, path, uniq_table); end
  def parse_block_scalar(rule, path, uniq_table); end
  def parse_block_seq(seq, seq_rule, path, uniq_table); end
  def parse_block_text(column, rule, path, uniq_table); end
  def parse_block_value(level, rule, path, uniq_table, container); end
  def parse_documents(input, opts = T.unsafe(nil), &block); end
  def parse_file(filename, opts = T.unsafe(nil)); end
  def parse_flow_map(map, map_rule, path, uniq_table); end
  def parse_flow_scalar(rule, path, uniq_table); end
  def parse_flow_seq(seq, seq_rule, path, uniq_table); end
  def parse_flow_value(rule, path, uniq_table, container); end
  def parse_next; end
  def parse_stream(input, opts = T.unsafe(nil), &block); end

  # boolean
  def preceding_alias; end

  # boolean
  def preceding_alias=(_arg0); end

  def reset_parser; end
  def reset_scanner(input, filename = T.unsafe(nil), untabify = T.unsafe(nil)); end
  def resolve_preceding_aliases(val); end

  # Class
  def sequence_class; end

  # Class
  def sequence_class=(_arg0); end

  def set_errors_linenum(errors); end
  def skip_spaces_and_comments; end

  # @return [Boolean]
  def stream_end?; end

  def to_scalar(str); end

  # Validator
  def validator; end

  # Validator
  def validator=(_arg0); end

  protected

  def _getclass(classname); end
  def add_to_seq(rule, seq, val, linenum, column); end
  def create_mapping(rule, linenum, column); end
  def create_scalar(rule, value, linenum, column); end
  def create_sequence(rule, linenum, column); end
  def put_to_map(rule, map, key, val, linenum, column); end

  private

  def _error(klass, message, path, linenum, column); end
  def to_mapkey(str); end
end

Kwalify::Yaml::Parser::MAPKEY_PATTERN = T.let(T.unsafe(nil), Regexp)
Kwalify::Yaml::Parser::PRECEDING_ALIAS_PLACEHOLDER = T.let(T.unsafe(nil), Object)

# (OBSOLETE) yaml parser
#
# this class has been obsoleted. use Kwalify::Yaml::Parser instead.
#
# ex.
#  # load document with YamlParser
#  str = ARGF.read()
#  parser = Kwalify::YamlParser.new(str)
#  document = parser.parse()
#
#  # validate document
#  schema = YAML.load(File.read('schema.yaml'))
#  validator = Kwalify::Validator.new(schema)
#  errors = validator.validate(document)
#
#  # print validation result
#  if errors && !errors.empty?
#    parser.set_errors_linenum(errors)
#    errors.sort.each do |error|
#      print "line %d: path %s: %s" % [error.linenum, error.path, error.message]
#    end
#  end
class Kwalify::YamlParser < ::Kwalify::PlainYamlParser
  # @return [YamlParser] a new instance of YamlParser
  def initialize(*args); end

  def parse; end
  def path_linenum(path); end
  def set_error_linenums(errors); end
  def set_errors_linenum(errors); end

  protected

  def add_to_map(map, key, value, linenum); end
  def add_to_seq(seq, value, linenum); end
  def create_mapping(linenum = T.unsafe(nil)); end
  def create_scalar(value, linenum = T.unsafe(nil)); end
  def create_sequence(linenum = T.unsafe(nil)); end
  def merge_map(map, collection, linenum); end
  def set_default(map, value, linenum); end
  def set_map_with(map, key, value, linenum); end
  def set_seq_at(seq, i, value, linenum); end
end

# (obsolete) use Kwalify::SyntaxError instead
class Kwalify::YamlSyntaxError < ::Kwalify::SyntaxError; end
