# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `temple` gem.
# Please instead update this file by running `bin/tapioca gem temple`.

module Temple; end

# ERB example implementation
#
# Example usage:
#   Temple::ERB::Template.new { "<%= 'Hello, world!' %>" }.render
module Temple::ERB; end

# Example ERB engine implementation
#
# @api public
class Temple::ERB::Engine < ::Temple::Engine; end

# Example ERB parser
#
# @api public
class Temple::ERB::Parser < ::Temple::Parser
  # @api public
  def call(input); end
end

# @api public
Temple::ERB::Parser::ERB_PATTERN = T.let(T.unsafe(nil), Regexp)

# ERB Template class
class Temple::ERB::Template < ::Temple::Templates::Tilt; end

# ERB trimming like in erubis
# Deletes spaces around '<% %>' and leave spaces around '<%= %>'.
#
# @api public
class Temple::ERB::Trimming < ::Temple::Filter
  # @api public
  def on_multi(*exps); end
end

# An engine is simply a chain of compilers (that often includes a parser,
# some filters and a generator).
#
#   class MyEngine < Temple::Engine
#     # First run MyParser, passing the :strict option
#     use MyParser, :strict
#
#     # Then a custom filter
#     use MyFilter
#
#     # Then some general optimizations filters
#     filter :MultiFlattener
#     filter :StaticMerger
#     filter :DynamicInliner
#
#     # Finally the generator
#     generator :ArrayBuffer, :buffer
#   end
#
#   class SpecialEngine < MyEngine
#     append MyCodeOptimizer
#     before :ArrayBuffer, Temple::Filters::Validator
#     replace :ArrayBuffer, Temple::Generators::RailsOutputBuffer
#   end
#
#   engine = MyEngine.new(strict: "For MyParser")
#   engine.call(something)
#
# @api public
class Temple::Engine
  include ::Temple::Mixins::Options
  include ::Temple::Mixins::EngineDSL
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
  extend ::Temple::Mixins::EngineDSL

  # @api public
  # @return [Engine] a new instance of Engine
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def call(input); end

  # @api public
  def chain; end

  protected

  # @api public
  def call_chain; end

  # @api public
  def chain_modified!; end

  class << self
    # @api public
    def chain; end
  end
end

# Temple base filter
#
# @api public
class Temple::Filter
  include ::Temple::Utils
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::CoreDispatcher
  include ::Temple::Mixins::EscapeDispatcher
  include ::Temple::Mixins::ControlFlowDispatcher
  include ::Temple::Mixins::Dispatcher
  include ::Temple::Mixins::Options
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

# Exception raised if something bad happens in a Temple filter
#
# @api public
class Temple::FilterError < ::RuntimeError; end

module Temple::Filters; end

# @api public
class Temple::Filters::CodeMerger < ::Temple::Filter
  # @api public
  def on_multi(*exps); end
end

# Control flow filter which processes [:if, condition, yes-exp, no-exp]
# and [:block, code, content] expressions.
# This is useful for ruby code generation with lots of conditionals.
#
# @api public
class Temple::Filters::ControlFlow < ::Temple::Filter
  # @api public
  def on_block(code, exp); end

  # @api public
  def on_case(arg, *cases); end

  # @api public
  def on_cond(*cases); end

  # @api public
  def on_if(condition, yes, no = T.unsafe(nil)); end
end

# Inlines several static/dynamic into a single dynamic.
#
# @api public
class Temple::Filters::DynamicInliner < ::Temple::Filter
  # @api public
  def on_multi(*exps); end
end

# Try to encode input string
#
# @api public
class Temple::Filters::Encoding < ::Temple::Parser
  # @api public
  def call(s); end
end

# Erase expressions with a certain type
#
# @api public
class Temple::Filters::Eraser < ::Temple::Filter
  # @api public
  def compile(exp); end

  protected

  # @api public
  # @return [Boolean]
  def do?(list, exp); end
end

# Escape dynamic or static expressions.
# This filter must be used after Temple::HTML::* and before the generators.
# It can be enclosed with Temple::Filters::DynamicInliner filters to
# reduce calls to Temple::Utils#escape_html.
#
# @api public
class Temple::Filters::Escapable < ::Temple::Filter
  # @api public
  # @return [Escapable] a new instance of Escapable
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def on_dynamic(value); end

  # @api public
  def on_escape(flag, exp); end

  # @api public
  def on_static(value); end
end

# Flattens nested multi expressions
#
# @api public
class Temple::Filters::MultiFlattener < ::Temple::Filter
  # @api public
  def on_multi(*exps); end
end

# Remove BOM from input string
#
# @api public
class Temple::Filters::RemoveBOM < ::Temple::Parser
  # @api public
  def call(s); end
end

# Convert [:dynamic, code] to [:static, text] if code is static Ruby expression.
class Temple::Filters::StaticAnalyzer < ::Temple::Filter
  def call(exp); end
  def on_dynamic(code); end
end

# Merges several statics into a single static.  Example:
#
#   [:multi,
#     [:static, "Hello "],
#     [:static, "World!"]]
#
# Compiles to:
#
#   [:static, "Hello World!"]
#
# @api public
class Temple::Filters::StaticMerger < ::Temple::Filter
  # @api public
  def on_multi(*exps); end
end

# Compile [:dynamic, "foo#{bar}"] to [:multi, [:static, 'foo'], [:dynamic, 'bar']]
class Temple::Filters::StringSplitter < ::Temple::Filter
  def on_dynamic(code); end

  private

  # @return [Boolean]
  def string_literal?(code); end

  class << self
    # `code` param must be valid string literal
    def compile(code); end

    private

    def compile_tokens!(exps, tokens); end
    def shift_balanced_embexpr(tokens); end
    def strip_quotes!(tokens); end
  end
end

class Temple::Filters::StringSplitter::SyntaxChecker < ::Ripper
  private

  # @raise [ParseError]
  def on_parse_error(*_arg0); end

  class << self
    # @return [Boolean]
    def syntax_error?(code); end
  end
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError < ::StandardError; end

# Validates temple expression with given grammar
#
# @api public
class Temple::Filters::Validator < ::Temple::Filter
  # @api public
  def compile(exp); end
end

# Abstract generator base class
# Generators should inherit this class and
# compile the Core Abstraction to ruby code.
#
# @api public
class Temple::Generator
  include ::Temple::Utils
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::Options
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions

  # @api public
  def call(exp); end

  # @api public
  def create_buffer; end

  # @api public
  # @raise [InvalidExpression]
  def on(*exp); end

  # @api public
  def on_capture(name, exp); end

  # @api public
  def on_code(code); end

  # @api public
  def on_dynamic(code); end

  # @api public
  def on_multi(*exp); end

  # @api public
  def on_newline; end

  # @api public
  def on_static(text); end

  # @api public
  def postamble; end

  # @api public
  def preamble; end

  # @api public
  def restore_buffer; end

  # @api public
  def return_buffer; end

  # @api public
  def save_buffer; end

  protected

  # @api public
  def buffer; end

  # @api public
  def capture_generator; end

  # @api public
  def concat(str); end
end

module Temple::Generators; end

# Implements an array buffer.
#
#   _buf = []
#   _buf << "static"
#   _buf << dynamic
#   _buf
#
# @api public
class Temple::Generators::Array < ::Temple::Generator
  # @api public
  def create_buffer; end

  # @api public
  def return_buffer; end
end

# Just like Array, but calls #join on the array.
#
#   _buf = []
#   _buf << "static"
#   _buf << dynamic
#   _buf.join("")
#
# @api public
class Temple::Generators::ArrayBuffer < ::Temple::Generators::Array
  # @api public
  def call(exp); end

  # @api public
  def return_buffer; end
end

# Implements an ERB generator.
#
# @api public
class Temple::Generators::ERB < ::Temple::Generator
  # @api public
  def call(exp); end

  # @api public
  def on_capture(name, exp); end

  # @api public
  def on_code(code); end

  # @api public
  def on_dynamic(code); end

  # @api public
  def on_multi(*exp); end

  # @api public
  def on_static(text); end
end

# Implements a rails output buffer.
#
#   @output_buffer = ActiveSupport::SafeBuffer
#   @output_buffer.safe_concat "static"
#   @output_buffer.safe_concat dynamic.to_s
#   @output_buffer
#
# @api public
class Temple::Generators::RailsOutputBuffer < ::Temple::Generators::StringBuffer
  # @api public
  def call(exp); end

  # @api public
  def concat(str); end

  # @api public
  def create_buffer; end
end

# Implements a string buffer.
#
#   _buf = ''
#   _buf << "static"
#   _buf << dynamic.to_s
#   _buf
#
# @api public
class Temple::Generators::StringBuffer < ::Temple::Generators::ArrayBuffer
  # @api public
  def create_buffer; end

  # @api public
  def on_dynamic(code); end

  # @api public
  def return_buffer; end
end

# Temple expression grammar which can be used to validate Temple expressions.
#
# Example:
#   Temple::Grammar.match? [:static, 'Valid Temple Expression']
#   Temple::Grammar.validate! [:multi, 'Invalid Temple Expression']
#
# See {file:EXPRESSIONS.md Expression documentation}.
#
# @api public
module Temple::Grammar
  extend ::Temple::Mixins::GrammarDSL
end

Temple::Grammar::Bool = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::Case = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::Condition = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::EmptyExp = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::Expression = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::HTMLAttr = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
Temple::Grammar::HTMLIdentifier = T.let(T.unsafe(nil), Temple::Mixins::GrammarDSL::Root)
module Temple::HTML; end

# This filter merges html attributes (e.g. used for id and class)
#
# @api public
class Temple::HTML::AttributeMerger < ::Temple::HTML::Filter
  # @api public
  def on_html_attrs(*attrs); end
end

# This filter removes empty attributes
#
# @api public
class Temple::HTML::AttributeRemover < ::Temple::HTML::Filter
  # @api public
  # @raise [ArgumentError]
  # @return [AttributeRemover] a new instance of AttributeRemover
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def on_html_attr(name, value); end

  # @api public
  def on_html_attrs(*attrs); end
end

# This filter sorts html attributes.
#
# @api public
class Temple::HTML::AttributeSorter < ::Temple::HTML::Filter
  # @api public
  def call(exp); end

  # @api public
  def on_html_attrs(*attrs); end
end

# @api private
module Temple::HTML::Dispatcher
  # @api private
  def on_html_attr(name, content); end

  # @api private
  def on_html_attrs(*attrs); end

  # @api private
  def on_html_comment(content); end

  # @api private
  def on_html_condcomment(condition, content); end

  # @api private
  def on_html_js(content); end

  # @api private
  def on_html_tag(name, attrs, content = T.unsafe(nil)); end
end

# @api public
class Temple::HTML::Fast < ::Temple::HTML::Filter
  # @api public
  # @return [Fast] a new instance of Fast
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def on_html_attr(name, value); end

  # @api public
  def on_html_attrs(*attrs); end

  # @api public
  def on_html_comment(content); end

  # @api public
  def on_html_condcomment(condition, content); end

  # @api public
  def on_html_doctype(type); end

  # @api public
  def on_html_js(content); end

  # @api public
  def on_html_tag(name, attrs, content = T.unsafe(nil)); end
end

# @api public
Temple::HTML::Fast::DOCTYPES = T.let(T.unsafe(nil), Hash)

# See http://www.w3.org/html/wg/drafts/html/master/single-page.html#void-elements
#
# @api public
Temple::HTML::Fast::HTML_VOID_ELEMENTS = T.let(T.unsafe(nil), Array)

# @api public
class Temple::HTML::Filter < ::Temple::Filter
  include ::Temple::HTML::Dispatcher

  # @api public
  # @return [Boolean]
  def contains_nonempty_static?(exp); end
end

# @api public
class Temple::HTML::Pretty < ::Temple::HTML::Fast
  # @api public
  # @return [Pretty] a new instance of Pretty
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def call(exp); end

  # @api public
  def on_dynamic(code); end

  # @api public
  def on_html_comment(content); end

  # @api public
  def on_html_doctype(type); end

  # @api public
  def on_html_tag(name, attrs, content = T.unsafe(nil)); end

  # @api public
  def on_static(content); end

  protected

  # @api public
  def indent; end

  # @api public
  def preamble; end

  # Return indentation before tag
  #
  # @api public
  def tag_indent(name); end
end

# Immutable map class which supports map merging
#
# @api public
class Temple::ImmutableMap
  include ::Enumerable

  # @api public
  # @return [ImmutableMap] a new instance of ImmutableMap
  def initialize(*map); end

  # @api public
  def [](key); end

  # @api public
  def each; end

  # @api public
  # @return [Boolean]
  def include?(key); end

  # @api public
  def keys; end

  # @api public
  def to_hash; end

  # @api public
  def values; end
end

# Exception raised if invalid temple expression is found
#
# @api public
class Temple::InvalidExpression < ::RuntimeError; end

module Temple::Mixins; end

# @api public
module Temple::Mixins::ClassOptions
  # @api public
  def default_options; end

  # @api public
  def define_deprecated_options(*opts); end

  # @api public
  def define_options(*opts); end

  # @api public
  def disable_option_validator!; end

  # @api public
  def options; end

  # @api public
  def set_default_options(opts); end

  # @api public
  def set_options(opts); end
end

# @api private
module Temple::Mixins::CompiledDispatcher
  # @api private
  def call(exp); end

  # @api private
  def compile(exp); end

  private

  # @api private
  def dispatched_methods; end

  # @api private
  def dispatcher(exp); end

  # @api private
  def replace_dispatcher(exp); end
end

# @api private
class Temple::Mixins::CompiledDispatcher::DispatchNode < ::Hash
  # @api private
  # @return [DispatchNode] a new instance of DispatchNode
  def initialize; end

  # @api private
  def compile(level = T.unsafe(nil), call_parent = T.unsafe(nil)); end

  # @api private
  def method; end

  # @api private
  def method=(_arg0); end
end

# @api private
module Temple::Mixins::ControlFlowDispatcher
  # @api private
  def on_block(code, content); end

  # @api private
  def on_case(arg, *cases); end

  # @api private
  def on_cond(*cases); end

  # @api private
  def on_if(condition, *cases); end
end

# @api private
module Temple::Mixins::CoreDispatcher
  # @api private
  def on_capture(name, exp); end

  # @api private
  def on_multi(*exps); end
end

# Implements a compatible call-method
# based on the including classe's methods.
#
# It uses every method starting with
# "on" and uses the rest of the method
# name as prefix of the expression it
# will receive. So, if a dispatcher
# has a method named "on_x", this method
# will be called with arg0,..,argN
# whenever an expression like [:x, arg0,..,argN ]
# is encountered.
#
# This works with longer prefixes, too.
# For example a method named "on_y_z"
# will be called whenever an expression
# like [:y, :z, .. ] is found. Furthermore,
# if additionally a method named "on_y"
# is present, it will be called when an
# expression starts with :y but then does
# not contain with :z. This way a
# dispatcher can implement namespaces.
#
# @api public
# @example
#   class MyAwesomeDispatch
#   include Temple::Mixins::Dispatcher
#   def on_awesome(thing) # keep awesome things
#   return [:awesome, thing]
#   end
#   def on_boring(thing) # make boring things awesome
#   return [:awesome, thing+" with bacon"]
#   end
#   def on(type,*args) # unknown stuff is boring too
#   return [:awesome, 'just bacon']
#   end
#   end
#   filter = MyAwesomeDispatch.new
#   # Boring things are converted:
#   filter.call([:boring, 'egg']) #=> [:awesome, 'egg with bacon']
#   # Unknown things too:
#   filter.call([:foo]) #=> [:awesome, 'just bacon']
#   # Known but not boring things won't be touched:
#   filter.call([:awesome, 'chuck norris']) #=>[:awesome, 'chuck norris']
# @note Processing does not reach into unknown
#   expression types by default.
module Temple::Mixins::Dispatcher
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::CoreDispatcher
  include ::Temple::Mixins::EscapeDispatcher
  include ::Temple::Mixins::ControlFlowDispatcher
end

# @api private
module Temple::Mixins::EngineDSL
  # @api private
  def after(name, *args, &block); end

  # @api private
  def append(*args, &block); end

  # @api private
  def before(name, *args, &block); end

  # @api private
  def chain_modified!; end

  def filter(name, *options); end
  def generator(name, *options); end
  def html(name, *options); end

  # @api private
  def prepend(*args, &block); end

  # @api private
  def remove(name); end

  # @api private
  def replace(name, *args, &block); end

  # @api private
  def use(*args, &block); end

  private

  # @api private
  def chain_class_constructor(filter, local_options); end

  # @api private
  def chain_element(args, block); end

  # @api private
  def chain_name(name); end

  # @api private
  # @raise [ArgumentError]
  def chain_proc_constructor(name, filter); end
end

# @api private
module Temple::Mixins::EscapeDispatcher
  # @api private
  def on_escape(flag, exp); end
end

# @api private
module Temple::Mixins::GrammarDSL
  # @api private
  # @return [Boolean]
  def ===(exp); end

  # @api private
  # @return [Boolean]
  def =~(exp); end

  # @api private
  def Rule(rule); end

  # @api private
  def Value(value); end

  # @api private
  def const_missing(name); end

  # @api private
  def extended(mod); end

  # @api private
  # @return [Boolean]
  def match?(exp); end

  # @api private
  def validate!(exp); end
end

# @api private
class Temple::Mixins::GrammarDSL::Element < ::Temple::Mixins::GrammarDSL::Or
  # @api private
  # @return [Element] a new instance of Element
  def initialize(grammar, rule); end

  # @api private
  def after_copy(source); end

  # @api private
  def match(exp, unmatched); end
end

# @api private
class Temple::Mixins::GrammarDSL::Or < ::Temple::Mixins::GrammarDSL::Rule
  # @api private
  # @return [Or] a new instance of Or
  def initialize(grammar, *children); end

  # @api private
  def <<(rule); end

  # @api private
  def after_copy(source); end

  # @api private
  def match(exp, unmatched); end

  # @api private
  def |(rule); end
end

# @api private
class Temple::Mixins::GrammarDSL::Root < ::Temple::Mixins::GrammarDSL::Or
  # @api private
  # @return [Root] a new instance of Root
  def initialize(grammar, name); end

  # @api private
  def after_copy(source); end

  # @api private
  def copy_to(grammar); end

  # @api private
  def match(exp, unmatched); end

  # @api private
  def validate!(exp); end
end

# @api private
class Temple::Mixins::GrammarDSL::Rule
  # @api private
  # @return [Rule] a new instance of Rule
  def initialize(grammar); end

  # @api private
  # @return [Boolean]
  def ===(exp); end

  # @api private
  # @return [Boolean]
  def =~(exp); end

  # @api private
  def copy_to(grammar); end

  # @api private
  # @return [Boolean]
  def match?(exp); end

  # @api private
  def |(rule); end
end

# @api private
class Temple::Mixins::GrammarDSL::Value < ::Temple::Mixins::GrammarDSL::Rule
  # @api private
  # @return [Value] a new instance of Value
  def initialize(grammar, value); end

  # @api private
  def match(exp, unmatched); end
end

# @api public
module Temple::Mixins::Options
  mixes_in_class_methods ::Temple::Mixins::ClassOptions
  mixes_in_class_methods ::Temple::Mixins::ThreadOptions

  # @api public
  def initialize(opts = T.unsafe(nil)); end

  # @api public
  def options; end

  class << self
    # @api public
    # @private
    def included(base); end
  end
end

# @api private
module Temple::Mixins::Template
  include ::Temple::Mixins::ClassOptions

  # @api private
  def compile(code, options); end

  # @api private
  def create(engine, options); end

  # @api private
  # @raise [NotImplementedError]
  def register_as(*names); end
end

module Temple::Mixins::ThreadOptions
  def thread_options; end
  def with_options(options); end

  protected

  def thread_options_key; end
end

# Mutable map class which supports map merging
#
# @api public
class Temple::MutableMap < ::Temple::ImmutableMap
  # @api public
  # @return [MutableMap] a new instance of MutableMap
  def initialize(*map); end

  # @api public
  def []=(key, value); end

  # @api public
  def update(map); end
end

class Temple::OptionMap < ::Temple::MutableMap
  # @return [OptionMap] a new instance of OptionMap
  def initialize(*map, &block); end

  def []=(key, value); end
  def add_deprecated_keys(*keys); end
  def add_valid_keys(*keys); end

  # @return [Boolean]
  def deprecated_key?(key); end

  def update(map); end

  # @return [Boolean]
  def valid_key?(key); end

  def valid_keys; end
  def validate_key!(key); end
  def validate_map!(map); end
end

# Temple base parser
#
# @api public
class Temple::Parser
  include ::Temple::Utils
  include ::Temple::Mixins::Options
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

module Temple::StaticAnalyzer
  class << self
    # @return [Boolean]
    def available?; end

    # @return [Boolean]
    def static?(code); end

    # @return [Boolean]
    def syntax_error?(code); end
  end
end

Temple::StaticAnalyzer::DYNAMIC_TOKENS = T.let(T.unsafe(nil), Array)
Temple::StaticAnalyzer::STATIC_KEYWORDS = T.let(T.unsafe(nil), Array)
Temple::StaticAnalyzer::STATIC_OPERATORS = T.let(T.unsafe(nil), Array)
Temple::StaticAnalyzer::STATIC_TOKENS = T.let(T.unsafe(nil), Array)

class Temple::StaticAnalyzer::SyntaxChecker < ::Ripper
  private

  # @raise [ParseError]
  def on_parse_error(*_arg0); end
end

class Temple::StaticAnalyzer::SyntaxChecker::ParseError < ::StandardError; end

# @api public
module Temple::Templates
  class << self
    # @api public
    def method_missing(name, engine, options = T.unsafe(nil)); end
  end
end

class Temple::Templates::Rails
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::Template

  def call(template, source = T.unsafe(nil)); end

  # @return [Boolean]
  def supports_streaming?; end

  class << self
    def register_as(*names); end
  end
end

class Temple::Templates::Tilt < ::Tilt::Template
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::Template

  # A string containing the (Ruby) source code for the template.
  #
  # @param locals [Hash] Local variables
  # @return [String] Compiled template ruby code
  def precompiled_template(locals = T.unsafe(nil)); end

  # Prepare Temple template
  #
  # Called immediately after template data is loaded.
  #
  # @return [void]
  def prepare; end

  class << self
    def default_mime_type; end
    def default_mime_type=(mime_type); end
    def register_as(*names); end
  end
end

# @api public
module Temple::Utils
  extend ::Temple::Utils

  # Check if expression is empty
  #
  # @api public
  # @param exp [Array] Temple expression
  # @return [Boolean] true if expression is empty
  def empty_exp?(exp); end

  # Returns an escaped copy of `html`.
  #
  # @api public
  # @param html [String] The string to escape
  # @return [String] The escaped string
  def escape_html(html); end

  # Returns an escaped copy of `html`.
  # Strings which are declared as html_safe are not escaped.
  #
  # @api public
  # @param html [String] The string to escape
  # @return [String] The escaped string
  def escape_html_safe(html); end

  # @api public
  def indent_dynamic(text, indent_next, indent, pre_tags = T.unsafe(nil)); end

  # Generate unique variable name
  #
  # @api public
  # @param prefix [String] Variable name prefix
  # @return [String] Variable name
  def unique_name(prefix = T.unsafe(nil)); end
end

Temple::VERSION = T.let(T.unsafe(nil), String)
