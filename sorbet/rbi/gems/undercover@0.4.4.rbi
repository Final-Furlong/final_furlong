# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `undercover` gem.
# Please instead update this file by running `bin/tapioca gem undercover`.

module Undercover; end

module Undercover::CLI
  class << self
    def changeset(opts); end
    def run(args); end
    def run_report(opts); end
    def syntax_version(version); end
  end
end

# TODO: Report calls >parser< for each file instead of
# traversing the whole project at first!
Undercover::CLI::WARNINGS_TO_S = T.let(T.unsafe(nil), Hash)

# Base class for different kinds of input
class Undercover::Changeset
  include ::Enumerable
  extend ::Forwardable

  # @return [Changeset] a new instance of Changeset
  def initialize(dir, compare_base = T.unsafe(nil)); end

  def <=>(*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def each_changed_line; end
  def file_paths; end

  # Returns the value of attribute files.
  def files; end

  def last_modified; end
  def update; end

  # TODO: refactor to a standalone validator (depending on changeset AND lcov)
  # TODO: add specs
  def validate(lcov_report_path); end

  private

  # Returns the value of attribute compare_base.
  def compare_base; end

  def compare_base_obj; end

  # Diffs `head` or `head` + `compare_base` (if exists),
  # as it makes sense to run Undercover with the most recent file versions
  def full_diff; end

  def head; end

  # Returns the value of attribute repo.
  def repo; end
end

Undercover::Changeset::T_ZERO = T.let(T.unsafe(nil), Time)

class Undercover::Formatter
  # @return [Formatter] a new instance of Formatter
  def initialize(results); end

  def to_s; end

  private

  def formatted_warnings; end
  def pad_size; end
  def success; end
  def warnings_header; end
end

class Undercover::LcovParseError < ::StandardError; end

class Undercover::LcovParser
  # @return [LcovParser] a new instance of LcovParser
  def initialize(lcov_io); end

  def coverage(filepath); end

  # Returns the value of attribute io.
  def io; end

  def parse; end

  # Returns the value of attribute source_files.
  def source_files; end

  private

  def parse_line(line); end

  class << self
    def parse(lcov_report_path); end
  end
end

class Undercover::Options
  # @return [Options] a new instance of Options
  def initialize; end

  # Returns the value of attribute compare.
  def compare; end

  # Sets the attribute compare
  #
  # @param value the value to set the attribute compare to.
  def compare=(_arg0); end

  # Returns the value of attribute git_dir.
  def git_dir; end

  # Sets the attribute git_dir
  #
  # @param value the value to set the attribute git_dir to.
  def git_dir=(_arg0); end

  # Returns the value of attribute lcov.
  def lcov; end

  # Sets the attribute lcov
  #
  # @param value the value to set the attribute lcov to.
  def lcov=(_arg0); end

  def parse(args); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Returns the value of attribute syntax_version.
  def syntax_version; end

  # Sets the attribute syntax_version
  #
  # @param value the value to set the attribute syntax_version to.
  def syntax_version=(_arg0); end

  private

  def args_from_options_file(path); end
  def build_opts(args); end
  def compare_option(parser); end
  def git_dir_option(parser); end
  def guess_lcov_path; end
  def lcov_path_option(parser); end
  def project_options; end
  def project_options_file; end
  def project_path_option(parser); end
  def ruby_syntax_option(parser); end
end

Undercover::Options::OUTPUT_FORMATTERS = T.let(T.unsafe(nil), Array)
Undercover::Options::OUTPUT_STDOUT = T.let(T.unsafe(nil), Symbol)
Undercover::Options::RUN_MODE = T.let(T.unsafe(nil), Array)
Undercover::Options::RUN_MODE_DIFF_STRICT = T.let(T.unsafe(nil), Symbol)

class Undercover::Report
  extend ::Forwardable

  # Initializes a new Undercover::Report
  #
  # @param changeset [Undercover::Changeset]
  # @param opts [Undercover::Options]
  # @return [Report] a new instance of Report
  def initialize(changeset, opts); end

  def all_results; end
  def build; end
  def build_warnings; end

  # Returns the value of attribute changeset.
  def changeset; end

  # Returns the value of attribute code_dir.
  def code_dir; end

  def flagged_results; end
  def inspect; end

  # Returns the value of attribute lcov.
  def lcov; end

  # Returns the value of attribute results.
  def results; end

  def to_s; end
  def validate(*args, **_arg1, &block); end

  private

  def load_and_parse_file(filepath); end

  # Returns the value of attribute loaded_files.
  def loaded_files; end
end

class Undercover::Result
  extend ::Forwardable

  # @return [Result] a new instance of Result
  def initialize(node, file_cov, file_path); end

  # Returns the value of attribute coverage.
  def coverage; end

  # Method `coverage_f` returns the total coverage of this Undercover::Result
  # as a % value, taking into account missing branches. Line coverage will be counted
  # as 0 if any branch is untested.
  def coverage_f; end

  # Returns the value of attribute file_path.
  def file_path; end

  def file_path_with_lines; end
  def first_line(*args, **_arg1, &block); end
  def flag; end

  # @return [Boolean]
  def flagged?; end

  def inspect; end
  def last_line(*args, **_arg1, &block); end
  def name(*args, **_arg1, &block); end

  # Returns the value of attribute node.
  def node; end

  # TODO: move to formatter interface instead!
  def pretty_print; end

  # TODO: create a formatter interface instead and add some tests.
  # TODO: re-enable rubocops
  #
  # Zips coverage data (that doesn't include any non-code lines) with
  # full source for given code fragment (this includes non-code lines!)
  def pretty_print_lines; end

  def to_s; end

  # @return [Boolean]
  def uncovered?(line_no); end

  private

  def count_covered_branches(line_number); end
end

Undercover::VERSION = T.let(T.unsafe(nil), String)
