# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/claide/all/claide.rbi
#
# claide-1.1.0

module CLAide
end
class CLAide::ANSI
  def self.code_for_key(key, map); end
  def self.disabled; end
  def self.disabled=(arg0); end
  extend CLAide::ANSI::Cursor
  extend CLAide::ANSI::Graphics
end
module CLAide::ANSI::Cursor
  def self.erase_display; end
  def self.erase_line; end
  def self.move_cursor(lines, columns = nil); end
  def self.restore_cursor_position; end
  def self.save_cursor_position; end
  def self.set_cursor_position(line = nil, column = nil); end
end
module CLAide::ANSI::Graphics
  def self.background_color(key); end
  def self.background_color_256(color); end
  def self.foreground_color(key); end
  def self.foreground_color_256(color); end
  def self.graphics_mode(codes); end
  def self.text_attribute(key); end
end
class CLAide::ANSI::StringEscaper < String
  def apply(*keys); end
  def black; end
  def blink; end
  def blue; end
  def bold; end
  def cyan; end
  def green; end
  def hidden; end
  def initialize(string); end
  def magenta; end
  def on_black; end
  def on_blue; end
  def on_cyan; end
  def on_green; end
  def on_magenta; end
  def on_red; end
  def on_white; end
  def on_yellow; end
  def red; end
  def reverse; end
  def underline; end
  def white; end
  def wrap_in_ansi_sequence(open, close); end
  def yellow; end
end
class String
  def ansi; end
end
class CLAide::Argument
  def ==(other); end
  def initialize(names, required, repeatable = nil); end
  def names; end
  def repeatable; end
  def repeatable=(arg0); end
  def repeatable?; end
  def required; end
  def required=(arg0); end
  def required?; end
end
class CLAide::ARGV
  def all_options(name); end
  def arguments!; end
  def arguments; end
  def delete_entry(requested_type, requested_key, default, delete_all = nil); end
  def empty?; end
  def entries; end
  def flag?(name, default = nil); end
  def initialize(argv); end
  def option(name, default = nil); end
  def options; end
  def remainder!; end
  def remainder; end
  def self.coerce(argv); end
  def shift_argument; end
end
module CLAide::ARGV::Parser
  def self.argument_type(argument); end
  def self.parse(argv); end
  def self.parse_argument(type, argument); end
  def self.parse_flag(argument); end
end
class CLAide::Command
  def ansi_output; end
  def ansi_output=(arg0); end
  def ansi_output?; end
  def banner!; end
  def handle_root_options(argv); end
  def help!(error_message = nil); end
  def help?; end
  def help_arg; end
  def help_arg=(arg0); end
  def initialize(argv); end
  def invoked_as_default; end
  def invoked_as_default=(arg0); end
  def invoked_as_default?; end
  def invoked_command_class; end
  def print_version; end
  def run; end
  def self.abstract_command; end
  def self.abstract_command=(arg0); end
  def self.abstract_command?; end
  def self.ansi_output; end
  def self.ansi_output=(arg0); end
  def self.ansi_output?; end
  def self.arguments; end
  def self.arguments=(arguments); end
  def self.arguments_array=(arguments); end
  def self.arguments_string=(arguments); end
  def self.banner!; end
  def self.banner(banner_class = nil); end
  def self.command; end
  def self.command=(arg0); end
  def self.default_subcommand; end
  def self.default_subcommand=(arg0); end
  def self.description; end
  def self.description=(arg0); end
  def self.find_subcommand(name); end
  def self.full_command; end
  def self.handle_exception(command, exception); end
  def self.help!(error_message = nil, help_class = nil); end
  def self.ignore_in_command_lookup; end
  def self.ignore_in_command_lookup=(flag); end
  def self.ignore_in_command_lookup?; end
  def self.inherited(subcommand); end
  def self.invoke(*args); end
  def self.load_default_subcommand(argv); end
  def self.option(name, description); end
  def self.options; end
  def self.parse(argv); end
  def self.plugin_prefix=(prefix); end
  def self.plugin_prefixes; end
  def self.plugin_prefixes=(arg0); end
  def self.report_error(exception); end
  def self.root_command?; end
  def self.run(argv = nil); end
  def self.subcommands; end
  def self.subcommands_for_command_lookup; end
  def self.summary; end
  def self.summary=(arg0); end
  def self.version; end
  def self.version=(arg0); end
  def validate!; end
  def verbose; end
  def verbose=(arg0); end
  def verbose?; end
end
class CLAide::Command::Banner
  def command; end
  def command=(arg0); end
  def compute_max_name_width; end
  def entry_description(name, description, name_width); end
  def formatted_banner; end
  def formatted_options_description; end
  def formatted_subcommand_summaries; end
  def formatted_usage_description; end
  def initialize(command); end
  def prettify_message(command, message); end
  def prettify_option_name(name); end
  def prettify_signature(command, subcommand, argument); end
  def prettify_subcommand(name); end
  def prettify_title(title); end
  def signature; end
  def signature_arguments; end
  def signature_sub_command; end
  def subcommands_for_banner; end
end
module CLAide::Command::Banner::TextWrapper
  def self.calculate_terminal_width; end
  def self.strip_heredoc(string); end
  def self.terminal_width; end
  def self.word_wrap(line, line_width); end
  def self.wrap_formatted_text(string, indent = nil, max_width = nil); end
  def self.wrap_with_indent(string, indent = nil, max_width = nil); end
end
class CLAide::Command::PluginManager
  def self.full_require_paths_for(gemspec); end
  def self.installed_specifications_for_prefix(plugin_prefix); end
  def self.load_plugins(plugin_prefix); end
  def self.loaded_plugins; end
  def self.plugin_gems_for_prefix(prefix); end
  def self.plugins_involved_in_exception(exception); end
  def self.safe_require(paths); end
  def self.specifications; end
end
class CLAide::Command::ArgumentSuggester
  def initialize(argument, command_class); end
  def possibilities; end
  def self.levenshtein_distance(a, b); end
  def self.prettify_suggestion(suggestion, argument_type); end
  def suggested_argument; end
  def suggestion; end
end
module CLAide::InformativeError
  def exit_status; end
  def exit_status=(arg0); end
end
class CLAide::Help < StandardError
  def banner; end
  def error_message; end
  def formatted_error_message; end
  def initialize(banner, error_message = nil); end
  def message; end
  def prettify_error_message(message); end
  include CLAide::InformativeError
end
