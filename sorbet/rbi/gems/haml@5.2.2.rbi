# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `haml` gem.
# Please instead update this file by running `bin/tapioca gem haml`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)
::UI = T.let(T.unsafe(nil), Cork::Board)

# The module that contains everything Haml-related:
#
# * {Haml::Parser} is Haml's parser.
# * {Haml::Compiler} is Haml's compiler.
# * {Haml::Engine} is the class used to render Haml within Ruby code.
# * {Haml::Options} is where Haml's runtime options are defined.
# * {Haml::Error} is raised when Haml encounters an error.
#
# Also see the {file:REFERENCE.md full Haml reference}.
module Haml
  class << self
    def init_rails(*args); end
  end
end

module Haml::AttributeBuilder
  class << self
    def build(class_id, obj_ref, is_html, attr_wrapper, escape_attrs, hyphenate_data_attrs, *attributes_hashes); end
    def build_attributes(is_html, attr_wrapper, escape_attrs, hyphenate_data_attrs, attributes = T.unsafe(nil)); end

    # @return [String, nil]
    def filter_and_join(value, separator); end

    # Merges two attribute hashes.
    # This is the same as `to.merge!(from)`,
    # except that it merges id, class, and data attributes.
    #
    # ids are concatenated with `"_"`,
    # and classes are concatenated with `" "`.
    # data hashes are simply merged.
    #
    # Destructively modifies `to`.
    #
    # @param to [{String => String,Hash}] The attribute hash to merge into
    # @param from [{String => Object}] The attribute hash to merge from
    # @return [{String => String,Hash}] `to`, after being merged
    def merge_attributes!(to, from); end

    # Merge multiple values to one attribute value. No destructive operation.
    #
    # @param key [String]
    # @param values [Array<Object>]
    # @return [String, Hash]
    def merge_values(key, *values); end

    def verify_attribute_names!(attribute_names); end

    private

    def build_data_keys(data_hash, hyphenate, attr_name = T.unsafe(nil)); end
    def flatten_data_attributes(data, key, join_char, seen = T.unsafe(nil)); end

    # Merge a couple of values to one attribute value. No destructive operation.
    #
    # @param to [String, Hash, nil]
    # @param from [Object]
    # @return [String, Hash]
    def merge_value(key, to, from); end

    # Takes an array of objects and uses the class and id of the first
    # one to create an attributes hash.
    # The second object, if present, is used as a prefix,
    # just like you can do with `dom_id()` and `dom_class()` in Rails
    def parse_object_ref(ref); end

    # Changes a word from camel case to underscores.
    # Based on the method of the same name in Rails' Inflector,
    # but copied here so it'll run properly without Rails.
    def underscore(camel_cased_word); end
  end
end

# https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
Haml::AttributeBuilder::INVALID_ATTRIBUTE_NAME_REGEX = T.let(T.unsafe(nil), Regexp)

class Haml::AttributeCompiler
  # @param options [Haml::Options]
  # @return [AttributeCompiler] a new instance of AttributeCompiler
  def initialize(options); end

  # Returns Temple expression to render attributes.
  #
  # @param attributes [Hash]
  # @param object_ref [String, :nil]
  # @param dynamic_attributes [Haml::Parser::DynamicAttributes]
  # @return [Array] Temple expression
  def compile(attributes, object_ref, dynamic_attributes); end

  private

  # @param attr [Haml::AttributeCompiler::AttributeValue]
  def attr_literal(attr); end

  # Returns array of AttributeValue instances from static attributes and dynamic_attributes. For each key,
  # the values' order in returned value is preserved in the same order as Haml::Buffer#attributes's merge order.
  #
  # @param attributes [{ String => String }]
  # @param parsed_hashes [{ String => String }]
  # @return [Array<AttributeValue>]
  def build_attribute_values(attributes, parsed_hashes); end

  # Compiles attribute values for one key to Temple expression that generates ` key='value'`.
  #
  # @param key [String]
  # @param values [Array<AttributeValue>]
  # @return [Array] Temple expression
  def compile_attribute(key, values); end

  # Compiles attribute values with the similar key to Temple expression.
  #
  # @param values [Array<AttributeValue>] whose `key`s are partially or fully the same from left.
  # @return [Array] Temple expression
  def compile_attribute_values(values); end

  # @param key [String] Not "id" or "class"
  # @param values [Array<AttributeValue>]
  # @return [Array] Temple expression
  def compile_common_attribute(key, values); end

  # @param id_or_class [String] "id" or "class"
  # @param values [Array<AttributeValue>]
  # @return [Array] Temple expression
  def compile_id_or_class_attribute(id_or_class, values); end

  # Returns a script to render attributes on runtime.
  #
  # @param attributes [Hash]
  # @param object_ref [String, :nil]
  # @param dynamic_attributes [Haml::Parser::DynamicAttributes]
  # @return [String] Attributes rendering code
  def compile_runtime_build(attributes, object_ref, dynamic_attributes); end

  # @param str [String]
  # @return [String]
  def frozen_string(str); end

  # Build array of grouped values whose sort order may go back and forth, which is also sorted with key name.
  # This method needs to group values with the same start because it can be changed in `Haml::AttributeBuidler#build_data_keys`.
  #
  # @param values [Array<Haml::AttributeCompiler::AttributeValue>]
  # @return [Array<Array<Haml::AttributeCompiler::AttributeValue>>]
  def group_values_for_sort(values); end

  # @param key [String]
  # @param values [Array<AttributeValue>]
  # @return [String]
  def merged_value(key, values); end

  # @param values [Array<AttributeValue>]
  # @return [Array] Temple expression
  def runtime_build(values); end

  # Renders attribute values statically.
  #
  # @param values [Array<AttributeValue>]
  # @return [Array] Temple expression
  def static_build(values); end

  # For haml/haml#972
  #
  # @param value [Object]
  def to_literal(value); end

  def true_value(key); end
  def unique_name; end
end

# @param type [Symbol] :static or :dynamic
# @param key [String]
# @param value [String] Actual string value for :static type, value's Ruby literal for :dynamic type.
class Haml::AttributeCompiler::AttributeValue < ::Struct
  # Returns the value of attribute key
  #
  # @return [Object] the current value of key
  def key; end

  # Sets the attribute key
  #
  # @param value [Object] the value to set the attribute key to.
  # @return [Object] the newly set value
  def key=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Haml::AttriubuteParser parses Hash literal to { String (key name) => String (value literal) }.
module Haml::AttributeParser
  class << self
    # @return [Boolean] - return true if AttributeParser.parse can be used.
    def available?; end

    # @param exp [String] - Old attributes literal or Hash literal generated from new attributes.
    # @return [Hash<String, String>, nil] - Return parsed attribute Hash whose values are Ruby literals, or return nil if argument is not a single Hash literal.
    def parse(exp); end

    private

    # @param hash_literal [String]
    # @param block [Proc] - that takes [String, String] as arguments
    def each_attribute(hash_literal, &block); end

    # @param tokens [Array] - Ripper tokens
    # @param block [Proc] - that takes balanced Ripper tokens as arguments
    def each_balanced_tokens(tokens, &block); end

    # @param token [Array] - Ripper token
    def expect_string_end!(token); end

    # @param exp [String] - Ruby expression
    # @return [Boolean] - Return true if exp is a single Hash literal
    def hash_literal?(exp); end

    # @param tokens [Array] - Ripper tokens
    def shift_hash_rocket!(tokens); end

    # @param tokens [Array] - Ripper tokens. Scanned tokens will be destructively removed from this argument.
    # @return [String] - attribute name in String
    def shift_key!(tokens); end
  end
end

Haml::AttributeParser::IGNORED_TYPES = T.let(T.unsafe(nil), Array)
Haml::AttributeParser::TEXT = T.let(T.unsafe(nil), Integer)

# Indices in Ripper tokens
Haml::AttributeParser::TYPE = T.let(T.unsafe(nil), Integer)

class Haml::AttributeParser::UnexpectedKeyError < ::StandardError; end
class Haml::AttributeParser::UnexpectedTokenError < ::StandardError; end

# This class is used only internally. It holds the buffer of HTML that
# is eventually output as the resulting document.
# It's called from within the precompiled code,
# and helps reduce the amount of processing done within `instance_eval`ed code.
class Haml::Buffer
  include ::Haml::Helpers
  include ::Haml::Util

  # @param upper [Buffer] The parent buffer
  # @param options [{Symbol => Object}] An options hash.
  #   See {Haml::Engine#options\_for\_buffer}
  # @return [Buffer] a new instance of Buffer
  def initialize(upper = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  # @see #active?
  def active=(_arg0); end

  # Whether or not this buffer is currently being used to render a Haml template.
  # Returns `false` if a subtemplate is being rendered,
  # even if it's a subtemplate of this buffer's template.
  #
  # @return [Boolean]
  def active?; end

  # Modifies the indentation of the document.
  #
  # @param tab_change [Fixnum] The number of tabs by which to increase
  #   or decrease the document's indentation
  def adjust_tabs(tab_change); end

  # The string that holds the compiled HTML. This is aliased as
  # `_erbout` for compatibility with ERB-specific code.
  #
  # @return [String]
  def buffer; end

  # The string that holds the compiled HTML. This is aliased as
  # `_erbout` for compatibility with ERB-specific code.
  #
  # @return [String]
  def buffer=(_arg0); end

  # nil if there's no capture_haml block running,
  # and the position at which it's beginning the capture if there is one.
  #
  # @return [Fixnum, nil]
  def capture_position; end

  # nil if there's no capture_haml block running,
  # and the position at which it's beginning the capture if there is one.
  #
  # @return [Fixnum, nil]
  def capture_position=(_arg0); end

  # Works like #{find_and_preserve}, but allows the first newline after a
  # preserved opening tag to remain unencoded, and then outdents the content.
  # This change was motivated primarily by the change in Rails 3.2.3 to emit
  # a newline after textarea helpers.
  #
  # @param input [String] The text to process
  # @private
  # @since Haml 4.0.1
  def fix_textareas!(input); end

  # @return [Boolean] Whether or not the format is HTML4
  def html4?; end

  # @return [Boolean] Whether or not the format is HTML5.
  def html5?; end

  # @return [Boolean] Whether or not the format is any flavor of HTML
  def html?; end

  # The options hash passed in from {Haml::Engine}.
  #
  # @return [{String => Object}]
  # @see Haml::Options#for_buffer
  def options; end

  # The options hash passed in from {Haml::Engine}.
  #
  # @return [{String => Object}]
  # @see Haml::Options#for_buffer
  def options=(_arg0); end

  # Appends text to the buffer, properly tabulated.
  # Also modifies the document's indentation.
  #
  # @param text [String] The text to append
  # @param tab_change [Fixnum] The number of tabs by which to increase
  #   or decrease the document's indentation
  # @param dont_tab_up [Boolean] If true, don't indent the first line of `text`
  def push_text(text, tab_change, dont_tab_up); end

  # Remove the whitespace from the right side of the buffer string.
  # Doesn't do anything if we're at the beginning of a capture_haml block.
  def rstrip!; end

  # @return [Fixnum] The current indentation level of the document
  def tabulation; end

  # Sets the current tabulation of the document.
  #
  # @param val [Fixnum] The new tabulation
  def tabulation=(val); end

  # @return [Boolean] Whether or not this buffer is a top-level template,
  #   as opposed to a nested partial
  def toplevel?; end

  # The {Buffer} for the enclosing Haml document.
  # This is set for partials and similar sorts of nested templates.
  # It's `nil` at the top level (see \{#toplevel?}).
  #
  # @return [Buffer]
  def upper; end

  # The {Buffer} for the enclosing Haml document.
  # This is set for partials and similar sorts of nested templates.
  # It's `nil` at the top level (see \{#toplevel?}).
  #
  # @return [Buffer]
  def upper=(_arg0); end

  # @return [Boolean] Whether or not the format is XHTML
  def xhtml?; end

  private

  def new_encoded_string; end

  # Gets `count` tabs. Mostly for internal use.
  def tabs(count = T.unsafe(nil)); end
end

class Haml::Compiler
  include ::Haml::Util

  # @return [Compiler] a new instance of Compiler
  def initialize(options); end

  def call(node); end
  def compile(node); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  private

  def build_script_formatter(text, opts); end
  def compile_comment; end
  def compile_doctype; end
  def compile_filter; end
  def compile_haml_comment; end
  def compile_plain; end
  def compile_root; end
  def compile_script(&block); end
  def compile_silent_script; end
  def compile_tag; end
  def flush_merged_text; end

  # @return [Boolean]
  def nuke_inner_whitespace?(node); end

  def push_generated_script(text); end

  # Causes `text` to be evaluated in the context of
  # the scope object and the result to be added to `@buffer`.
  #
  # If `opts[:preserve_script]` is true, Haml::Helpers#find_and_preserve is run on
  # the result before it is added to `@buffer`
  def push_script(text, opts = T.unsafe(nil)); end

  # Evaluates `text` in the context of the scope object, but
  # does not output the result.
  def push_silent(text, can_suppress = T.unsafe(nil)); end

  def push_temple(temple); end

  # Adds `text` to `@buffer`.
  def push_text(text); end

  def resolve_newlines; end

  # Get rid of and whitespace at the end of the buffer
  # or the merged text
  def rstrip_buffer!(index = T.unsafe(nil)); end

  def text_for_doctype; end
end

# This is the frontend for using Haml programmatically.
# It can be directly used by the user by creating a
# new instance and calling \{#render} to render the template.
# For example:
#
#     template = File.read('templates/really_cool_template.haml')
#     haml_engine = Haml::Engine.new(template)
#     output = haml_engine.render
#     puts output
class Haml::Engine
  include ::Haml::Util
  extend ::Forwardable

  # Precompiles the Haml template.
  #
  # @param template [String] The Haml template
  # @param options [{Symbol => Object}] An options hash;
  #   see {file:REFERENCE.md#options the Haml options documentation}
  # @raise [Haml::Error] if there's a Haml syntax error in the template
  # @return [Engine] a new instance of Engine
  def initialize(template, options = T.unsafe(nil)); end

  # Deprecated API for backword compatibility
  def compiler; end

  # Defines a method on `object` with the given name
  # that renders the template and returns the result as a string.
  #
  # If `object` is a class or module,
  # the method will instead be defined as an instance method.
  # For example:
  #
  #     t = Time.now
  #     Haml::Engine.new("%p\n  Today's date is\n  .date= self.to_s").def_method(t, :render)
  #     t.render #=> "<p>\n  Today's date is\n  <div class='date'>Fri Nov 23 18:28:29 -0800 2007</div>\n</p>\n"
  #
  #     Haml::Engine.new(".upcased= upcase").def_method(String, :upcased_div)
  #     "foobar".upcased_div #=> "<div class='upcased'>FOOBAR</div>\n"
  #
  # The first argument of the defined method is a hash of local variable names to values.
  # However, due to an unfortunate Ruby quirk,
  # the local variables which can be assigned must be pre-declared.
  # This is done with the `local_names` argument.
  # For example:
  #
  #     # This works
  #     obj = Object.new
  #     Haml::Engine.new("%p= foo").def_method(obj, :render, :foo)
  #     obj.render(:foo => "Hello!") #=> "<p>Hello!</p>"
  #
  #     # This doesn't
  #     obj = Object.new
  #     Haml::Engine.new("%p= foo").def_method(obj, :render)
  #     obj.render(:foo => "Hello!") #=> NameError: undefined local variable or method `foo'
  #
  # Note that Haml modifies the evaluation context
  # (either the scope object or the `self` object of the scope binding).
  # It extends {Haml::Helpers}, and various instance variables are set
  # (all prefixed with `haml_`).
  #
  # @param object [Object, Module] The object on which to define the method
  # @param name [String, Symbol] The name of the method to define
  # @param local_names [Array<Symbol>] The names of the locals that can be passed to the proc
  def def_method(object, name, *local_names); end

  # The indentation used in the Haml document,
  # or `nil` if the indentation is ambiguous
  # (for example, for a single-level document).
  #
  # @return [String]
  def indentation; end

  # The indentation used in the Haml document,
  # or `nil` if the indentation is ambiguous
  # (for example, for a single-level document).
  #
  # @return [String]
  def indentation=(_arg0); end

  # The Haml::Options instance.
  # See {file:REFERENCE.md#options the Haml options documentation}.
  #
  # @return Haml::Options
  def options; end

  # The Haml::Options instance.
  # See {file:REFERENCE.md#options the Haml options documentation}.
  #
  # @return Haml::Options
  def options=(_arg0); end

  def options_for_buffer; end
  def precompiled(*args, **_arg1, &block); end
  def precompiled_method_return_value(*args, **_arg1, &block); end

  # Processes the template and returns the result as a string.
  #
  # `scope` is the context in which the template is evaluated.
  # If it's a `Binding`, Haml uses it as the second argument to `Kernel#eval`;
  # otherwise, Haml just uses its `#instance_eval` context.
  #
  # Note that Haml modifies the evaluation context
  # (either the scope object or the `self` object of the scope binding).
  # It extends {Haml::Helpers}, and various instance variables are set
  # (all prefixed with `haml_`).
  # For example:
  #
  #     s = "foobar"
  #     Haml::Engine.new("%p= upcase").render(s) #=> "<p>FOOBAR</p>"
  #
  #     # s now extends Haml::Helpers
  #     s.respond_to?(:html_attrs) #=> true
  #
  # `locals` is a hash of local variables to make available to the template.
  # For example:
  #
  #     Haml::Engine.new("%p= foo").render(Object.new, :foo => "Hello, world!") #=> "<p>Hello, world!</p>"
  #
  # If a block is passed to render,
  # that block is run when `yield` is called
  # within the template.
  #
  # Due to some Ruby quirks,
  # if `scope` is a `Binding` object and a block is given,
  # the evaluation context may not be quite what the user expects.
  # In particular, it's equivalent to passing `eval("self", scope)` as `scope`.
  # This won't have an effect in most cases,
  # but if you're relying on local variables defined in the context of `scope`,
  # they won't work.
  #
  # @param scope [Binding, Object] The context in which the template is evaluated
  # @param locals [{Symbol => Object}] Local variables that will be made available
  #   to the template
  # @param block [#to_proc] A block that can be yielded to within the template
  # @return [String] The rendered template
  def render(scope = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # Returns a proc that, when called,
  # renders the template and returns the result as a string.
  #
  # `scope` works the same as it does for render.
  #
  # The first argument of the returned proc is a hash of local variable names to values.
  # However, due to an unfortunate Ruby quirk,
  # the local variables which can be assigned must be pre-declared.
  # This is done with the `local_names` argument.
  # For example:
  #
  #     # This works
  #     Haml::Engine.new("%p= foo").render_proc(Object.new, :foo).call :foo => "Hello!"
  #       #=> "<p>Hello!</p>"
  #
  #     # This doesn't
  #     Haml::Engine.new("%p= foo").render_proc.call :foo => "Hello!"
  #       #=> NameError: undefined local variable or method `foo'
  #
  # The proc doesn't take a block; any yields in the template will fail.
  #
  # @param scope [Binding, Object] The context in which the template is evaluated
  # @param local_names [Array<Symbol>] The names of the locals that can be passed to the proc
  # @return [Proc] The proc that will run the template
  def render_proc(scope = T.unsafe(nil), *local_names); end

  # Processes the template and returns the result as a string.
  #
  # `scope` is the context in which the template is evaluated.
  # If it's a `Binding`, Haml uses it as the second argument to `Kernel#eval`;
  # otherwise, Haml just uses its `#instance_eval` context.
  #
  # Note that Haml modifies the evaluation context
  # (either the scope object or the `self` object of the scope binding).
  # It extends {Haml::Helpers}, and various instance variables are set
  # (all prefixed with `haml_`).
  # For example:
  #
  #     s = "foobar"
  #     Haml::Engine.new("%p= upcase").render(s) #=> "<p>FOOBAR</p>"
  #
  #     # s now extends Haml::Helpers
  #     s.respond_to?(:html_attrs) #=> true
  #
  # `locals` is a hash of local variables to make available to the template.
  # For example:
  #
  #     Haml::Engine.new("%p= foo").render(Object.new, :foo => "Hello, world!") #=> "<p>Hello, world!</p>"
  #
  # If a block is passed to render,
  # that block is run when `yield` is called
  # within the template.
  #
  # Due to some Ruby quirks,
  # if `scope` is a `Binding` object and a block is given,
  # the evaluation context may not be quite what the user expects.
  # In particular, it's equivalent to passing `eval("self", scope)` as `scope`.
  # This won't have an effect in most cases,
  # but if you're relying on local variables defined in the context of `scope`,
  # they won't work.
  #
  # @param scope [Binding, Object] The context in which the template is evaluated
  # @param locals [{Symbol => Object}] Local variables that will be made available
  #   to the template
  # @param block [#to_proc] A block that can be yielded to within the template
  # @return [String] The rendered template
  def to_html(scope = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  private

  def set_locals(locals, scope, scope_object); end
end

# An exception raised by Haml code.
class Haml::Error < ::StandardError
  # @param message [String] The error message
  # @param line [Fixnum] See \{#line}
  # @return [Error] a new instance of Error
  def initialize(message = T.unsafe(nil), line = T.unsafe(nil)); end

  # The line of the template on which the error occurred.
  #
  # @return [Fixnum]
  def line; end

  class << self
    def message(key, *args); end
  end
end

Haml::Error::MESSAGES = T.let(T.unsafe(nil), Hash)

# Like Temple::Filters::Escapable, but with support for escaping by
# Haml::Herlpers.html_escape and Haml::Herlpers.escape_once.
class Haml::Escapable < ::Temple::Filter
  # @return [Escapable] a new instance of Escapable
  def initialize(*_arg0); end

  # The same as Haml::AttributeBuilder.build_attributes
  def on_dynamic(value); end

  def on_escape(flag, exp); end

  # The same as Haml::AttributeBuilder.build_attributes
  def on_static(value); end

  private

  def escape(value); end
  def escape_code(value); end
  def escape_once(value); end
  def escape_once_code(value); end
end

# Special value of `flag` to ignore html_safe?
class Haml::Escapable::EscapeSafeBuffer < ::Struct
  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# The module containing the default Haml filters,
# as well as the base module, {Haml::Filters::Base}.
#
# @see Haml::Filters::Base
module Haml::Filters
  extend ::Haml::Filters

  # @return [{String => Haml::Filters::Base}] a hash mapping filter names to
  #   classes.
  def defined; end

  # Loads an external template engine from
  # [Tilt](https://github.com/rtomayko/tilt) as a filter. This method is used
  # internally by Haml to set up filters for Sass, SCSS, Less, Coffeescript,
  # and others. It's left public to make it easy for developers to add their
  # own Tilt-based filters if they choose.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] Options for generating the filter module.
  # @return [Module] The generated filter.
  # @since 4.0
  def register_tilt_filter(name, options = T.unsafe(nil)); end

  # Removes a filter from Haml. If the filter was removed, it returns
  # the Module that was removed upon success, or nil on failure. If you try
  # to redefine a filter, Haml will raise an error. Use this method first to
  # explicitly remove the filter before redefining it.
  #
  # @return Module The filter module that has been removed
  # @since 4.0
  def remove_filter(name); end
end

# The base module for Haml filters.
# User-defined filters should be modules including this module.
# The name of the filter is taken by downcasing the module name.
# For instance, if the module is named `FooBar`, the filter will be `:foobar`.
#
# A user-defined filter should override either \{#render} or {\#compile}.
# \{#render} is the most common.
# It takes a string, the filter source,
# and returns another string, the result of the filter.
# For example, the following will define a filter named `:sass`:
#
#     module Haml::Filters::Sass
#       include Haml::Filters::Base
#
#       def render(text)
#         ::Sass::Engine.new(text).render
#       end
#     end
#
# For details on overriding \{#compile}, see its documentation.
#
# Note that filters overriding \{#render} automatically support `#{}`
# for interpolating Ruby code.
# Those overriding \{#compile} will need to add such support manually
# if it's desired.
module Haml::Filters::Base
  # This should be overridden when a filter needs to have access to the Haml
  # evaluation context. Rather than applying a filter to a string at
  # compile-time, \{#compile} uses the {Haml::Compiler} instance to compile
  # the string to Ruby code that will be executed in the context of the
  # active Haml template.
  #
  # Warning: the {Haml::Compiler} interface is neither well-documented
  # nor guaranteed to be stable.
  # If you want to make use of it, you'll probably need to look at the
  # source code and should test your filter when upgrading to new Haml
  # versions.
  #
  # @param compiler [Haml::Compiler] The compiler instance
  # @param text [String] The text of the filter
  # @raise [Haml::Error] if none of \{#compile}, \{#render}, and
  #   \{#render_with_options} are overridden
  def compile(compiler, text); end

  # Same as \{#compile}, but requires the necessary files first.
  # *This is used by {Haml::Engine} and is not intended to be overridden or used elsewhere.*
  #
  # @see #compile
  def internal_compile(*args); end

  # Takes the source text that should be passed to the filter
  # and returns the result of running the filter on that string.
  #
  # This should be overridden in most individual filter modules
  # to render text with the given filter.
  # If \{#compile} is overridden, however, \{#render} doesn't need to be.
  #
  # @param text [String] The source text for the filter to process
  # @raise [Haml::Error] if it's not overridden
  # @return [String] The filtered result
  def render(_text); end

  # Same as \{#render}, but takes a {Haml::Engine} options hash as well.
  # It's only safe to rely on options made available in {Haml::Engine#options\_for\_buffer}.
  #
  # @param text [String] The source text for the filter to process
  # @raise [Haml::Error] if it or \{#render} isn't overridden
  # @return [String] The filtered result
  # @see #render
  def render_with_options(text, _options); end

  class << self
    # This method is automatically called when {Base} is included in a module.
    # It automatically defines a filter
    # with the downcased name of that module.
    # For example, if the module is named `FooBar`, the filter will be `:foobar`.
    #
    # @param base [Module, Class] The module that this is included in
    def included(base); end
  end
end

# Surrounds the filtered text with CDATA tags.
module Haml::Filters::Cdata
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Cdata

  # @see Base#render
  def render(text); end
end

# Fake CoffeeScript filter for Haml
module Haml::Filters::Coffee
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Javascript
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Coffee

  class << self
    def render_with_options(text, compiler_options); end
  end
end

# Surrounds the filtered text with `<style>` and CDATA tags. Useful for
# including inline CSS.
module Haml::Filters::Css
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Css

  # @see Base#render_with_options
  def render_with_options(text, options); end
end

# Parses the filtered text with ERB.
# Not available if the {file:REFERENCE.md#suppress_eval-option
# `:suppress_eval`} option is set to true. Embedded Ruby code is evaluated
# in the same context as the Haml template.
module Haml::Filters::Erb
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Plain
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Erb
  extend ::Haml::Filters::PrecompiledTiltFilter

  class << self
    def precompiled(text); end
    def render_with_options(text, compiler_options); end
  end
end

# Works the same as {Plain}, but HTML-escapes the text before placing it in
# the document.
module Haml::Filters::Escaped
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Escaped

  # @see Base#render
  def render(text); end
end

# Surrounds the filtered text with `<script>` and CDATA tags. Useful for
# including inline Javascript.
module Haml::Filters::Javascript
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Javascript

  # @see Base#render_with_options
  def render_with_options(text, options); end
end

module Haml::Filters::Less
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Css
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Less

  class << self
    def render_with_options(text, compiler_options); end
  end
end

# Fake Markdown filter for Haml
module Haml::Filters::Markdown
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Plain
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Markdown

  class << self
    def render_with_options(text, compiler_options); end
  end
end

# Does not parse the filtered text.
# This is useful for large blocks of text without HTML tags, when you don't
# want lines starting with `.` or `-` to be parsed.
module Haml::Filters::Plain
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Plain

  # @see Base#render
  def render(text); end
end

# @private
module Haml::Filters::PrecompiledTiltFilter
  def compile(compiler, text); end
  def precompiled(text); end
end

# Inserts the filtered text into the template with whitespace preserved.
# `preserve`d blocks of text aren't indented, and newlines are replaced with
# the HTML escape code for newlines, to preserve nice-looking output.
#
# @see Haml::Helpers#preserve
module Haml::Filters::Preserve
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Preserve

  # @see Base#render
  def render(text); end
end

module Haml::Filters::RailsErb
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Plain
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::RailsErb
  extend ::Haml::Filters::PrecompiledTiltFilter

  class << self
    def render_with_options(text, compiler_options); end
  end
end

# Parses the filtered text with the normal Ruby interpreter. Creates an IO
# object named `haml_io`, anything written to it is output into the Haml
# document. In previous version this filter redirected any output to `$stdout`
# to the Haml document, this was not threadsafe and has been removed, you
# should use `haml_io` instead.
#
# Not available if the {file:REFERENCE.md#suppress_eval-option `:suppress_eval`}
# option is set to true. The Ruby code is evaluated in the same context as
# the Haml template.
module Haml::Filters::Ruby
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Ruby

  # @see Base#compile
  def compile(compiler, text); end
end

# Fake Sass filter for Haml
module Haml::Filters::Sass
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Css
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Sass

  class << self
    def render_with_options(text, compiler_options); end
  end
end

module Haml::Filters::Scss
  include ::Haml::Filters::Base
  extend ::Haml::Filters::Base
  extend ::Haml::Filters::Css
  extend ::Haml::Filters::TiltFilter
  extend ::Haml::Filters::Scss

  class << self
    def render_with_options(text, compiler_options); end
  end
end

# @private
module Haml::Filters::TiltFilter
  extend ::Haml::Filters::TiltFilter

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def template_class; end

  # Sets the attribute template_class
  #
  # @param value the value to set the attribute template_class to.
  def template_class=(_arg0); end

  # Returns the value of attribute tilt_extension.
  def tilt_extension; end

  # Sets the attribute tilt_extension
  #
  # @param value the value to set the attribute tilt_extension to.
  def tilt_extension=(_arg0); end

  class << self
    # @private
    def extended(base); end
  end
end

# Ruby code generator, which is a limited version of Temple::Generator.
# Limit methods since Haml doesn't need most of them.
class Haml::Generator
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::Options
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions

  def call(exp); end
  def on_code(exp); end
  def on_dynamic(code); end
  def on_multi(*exp); end
  def on_newline; end
  def on_static(text); end

  private

  def concat(str); end
end

# This module contains various helpful methods to make it easier to do various tasks.
# {Haml::Helpers} is automatically included in the context
# that a Haml template is parsed in, so all these methods are at your
# disposal from within the template.
module Haml::Helpers
  extend ::Haml::Helpers

  # Returns whether or not `block` is defined directly in a Haml template.
  #
  # @param block [Proc] A Ruby block
  # @return [Boolean] Whether or not `block` is defined directly in a Haml template
  def block_is_haml?(block); end

  # Captures the result of a block of Haml code,
  # gets rid of the excess indentation,
  # and returns it as a string.
  # For example, after the following,
  #
  #     .foo
  #       - foo = capture_haml(13) do |a|
  #         %p= a
  #
  # the local variable `foo` would be assigned to `"<p>13</p>\n"`.
  #
  # @param args [Array] Arguments to pass into the block
  # @yield [args] A block of Haml code that will be converted to a string
  # @yieldparam args [Array] `args`
  def capture_haml(*args, &block); end

  # Escapes HTML entities in `text`, but without escaping an ampersand
  # that is already part of an escaped entity.
  #
  # @param text [String] The string to sanitize
  # @return [String] The sanitized string
  def escape_once(text); end

  # Escapes HTML entities in `text`, but without escaping an ampersand
  # that is already part of an escaped entity.
  # Always escape text once regardless of html_safe?
  #
  # @param text [String] The string to sanitize
  # @return [String] The sanitized string
  def escape_once_without_haml_xss(text); end

  # Uses \{#preserve} to convert any newlines inside whitespace-sensitive tags
  # into the HTML entities for endlines.
  #
  # @overload find_and_preserve
  # @overload find_and_preserve
  # @param tags [Array<String>] Tags that should have newlines escaped
  def find_and_preserve(input = T.unsafe(nil), tags = T.unsafe(nil), &block); end

  # Takes any string, finds all the newlines, and converts them to
  # HTML entities so they'll render correctly in
  # whitespace-sensitive tags without screwing up the indentation.
  #
  # @overload preserve
  # @overload preserve
  def flatten(input = T.unsafe(nil), &block); end

  # Outputs text directly to the Haml buffer, with the proper indentation.
  #
  # @param text [#to_s] The text to output
  def haml_concat(text = T.unsafe(nil)); end

  # @return [String] The indentation string for the current line
  def haml_indent; end

  # Creates an HTML tag with the given name and optionally text and attributes.
  # Can take a block that will run between the opening and closing tags.
  # If the block is a Haml block or outputs text using \{#haml\_concat},
  # the text will be properly indented.
  #
  # `name` can be a string using the standard Haml class/id shorthand
  # (e.g. "span#foo.bar", "#foo").
  # Just like standard Haml tags, these class and id values
  # will be merged with manually-specified attributes.
  #
  # `flags` is a list of symbol flags
  # like those that can be put at the end of a Haml tag
  # (`:/`, `:<`, and `:>`).
  # Currently, only `:/` and `:<` are supported.
  #
  # `haml_tag` outputs directly to the buffer;
  # its return value should not be used.
  # If you need to get the results as a string,
  # use \{#capture\_haml\}.
  #
  # For example,
  #
  #     haml_tag :table do
  #       haml_tag :tr do
  #         haml_tag 'td.cell' do
  #           haml_tag :strong, "strong!"
  #           haml_concat "data"
  #         end
  #         haml_tag :td do
  #           haml_concat "more_data"
  #         end
  #       end
  #     end
  #
  # outputs
  #
  #     <table>
  #       <tr>
  #         <td class='cell'>
  #           <strong>
  #             strong!
  #           </strong>
  #           data
  #         </td>
  #         <td>
  #           more_data
  #         </td>
  #       </tr>
  #     </table>
  #
  # @overload haml_tag
  # @overload haml_tag
  # @param name [#to_s] The name of the tag
  def haml_tag(name, *rest, &block); end

  # Conditionally wrap a block in an element. If `condition` is `true` then
  # this method renders the tag described by the arguments in `tag` (using
  # \{#haml_tag}) with the given block inside, otherwise it just renders the block.
  #
  # For example,
  #
  #     - haml_tag_if important, '.important' do
  #       %p
  #         A (possibly) important paragraph.
  #
  # will produce
  #
  #     <div class='important'>
  #       <p>
  #         A (possibly) important paragraph.
  #       </p>
  #     </div>
  #
  # if `important` is truthy, and just
  #
  #     <p>
  #       A (possibly) important paragraph.
  #     </p>
  #
  # otherwise.
  #
  # Like \{#haml_tag}, `haml_tag_if` outputs directly to the buffer and its
  # return value should not be used. Use \{#capture_haml} if you need to use
  # its results as a string.
  #
  # @param condition The condition to test to determine whether to render
  #   the enclosing tag
  # @param tag Definition of the enclosing tag. See \{#haml_tag} for details
  #   (specifically the form that takes a block)
  def haml_tag_if(condition, *tag); end

  # Returns a hash containing default assignments for the `xmlns`, `lang`, and `xml:lang`
  # attributes of the `html` HTML element.
  # For example,
  #
  #     %html{html_attrs}
  #
  # becomes
  #
  #     <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en-US' lang='en-US'>
  #
  # @param lang [String] The value of `xml:lang` and `lang`
  # @return [{#to_s => String}] The attribute hash
  def html_attrs(lang = T.unsafe(nil)); end

  # Returns a copy of `text` with ampersands, angle brackets and quotes
  # escaped into HTML entities.
  #
  # Note that if ActionView is loaded and XSS protection is enabled
  # (as is the default for Rails 3.0+, and optional for version 2.3.5+),
  # this won't escape text declared as "safe".
  #
  # @param text [String] The string to sanitize
  # @return [String] The sanitized string
  def html_escape(text); end

  # Returns a copy of `text` with ampersands, angle brackets and quotes
  # escaped into HTML entities.
  #
  # Note that if ActionView is loaded and XSS protection is enabled
  # (as is the default for Rails 3.0+, and optional for version 2.3.5+),
  # this won't escape text declared as "safe".
  # Always escape text regardless of html_safe?
  #
  # @param text [String] The string to sanitize
  # @return [String] The sanitized string
  def html_escape_without_haml_xss(text); end

  # Note: this does **not** need to be called when using Haml helpers
  # normally in Rails.
  #
  # Initializes the current object as though it were in the same context
  # as a normal ActionView instance using Haml.
  # This is useful if you want to use the helpers in a context
  # other than the normal setup with ActionView.
  # For example:
  #
  #     context = Object.new
  #     class << context
  #       include Haml::Helpers
  #     end
  #     context.init_haml_helpers
  #     context.haml_tag :p, "Stuff"
  def init_haml_helpers; end

  # Returns whether or not the current template is a Haml template.
  #
  # This function, unlike other {Haml::Helpers} functions,
  # also works in other `ActionView` templates,
  # where it will always return false.
  #
  # @return [Boolean] Whether or not the current template is a Haml template
  def is_haml?; end

  # Takes an `Enumerable` object and a block
  # and iterates over the enum,
  # yielding each element to a Haml block
  # and putting the result into `<li>` elements.
  # This creates a list of the results of the block.
  # For example:
  #
  #     = list_of([['hello'], ['yall']]) do |i|
  #       = i[0]
  #
  # Produces:
  #
  #     <li>hello</li>
  #     <li>yall</li>
  #
  # And:
  #
  #     = list_of({:title => 'All the stuff', :description => 'A book about all the stuff.'}) do |key, val|
  #       %h3= key.humanize
  #       %p= val
  #
  # Produces:
  #
  #     <li>
  #       <h3>Title</h3>
  #       <p>All the stuff</p>
  #     </li>
  #     <li>
  #       <h3>Description</h3>
  #       <p>A book about all the stuff.</p>
  #     </li>
  #
  # While:
  #
  #     = list_of(["Home", "About", "Contact", "FAQ"], {class: "nav", role: "nav"}) do |item|
  #       %a{ href="#" }= item
  #
  # Produces:
  #
  #     <li class='nav' role='nav'>
  #       <a href='#'>Home</a>
  #     </li>
  #     <li class='nav' role='nav'>
  #       <a href='#'>About</a>
  #     </li>
  #     <li class='nav' role='nav'>
  #       <a href='#'>Contact</a>
  #     </li>
  #     <li class='nav' role='nav'>
  #       <a href='#'>FAQ</a>
  #     </li>
  #
  #  `[[class", "nav"], [role", "nav"]]` could have been used instead of `{class: "nav", role: "nav"}` (or any enumerable collection where each pair of items responds to #to_s)
  #
  # @param enum [Enumerable] The list of objects to iterate over
  # @param opts [Enumerable<#to_s,#to_s>] Each key/value pair will become an attribute pair for each list item element.
  # @yield [item] A block which contains Haml code that goes within list items
  # @yieldparam item An element of `enum`
  def list_of(enum, opts = T.unsafe(nil), &block); end

  # Runs a block of code in a non-Haml context
  # (i.e. \{#is\_haml?} will return false).
  #
  # This is mainly useful for rendering sub-templates such as partials in a non-Haml language,
  # particularly where helpers may behave differently when run from Haml.
  #
  # Note that this is automatically applied to Rails partials.
  #
  # @yield A block which won't register as Haml
  def non_haml; end

  # Prepends a string to the beginning of a Haml block,
  # with no whitespace between.
  # For example:
  #
  #     = precede '*' do
  #       %span.small Not really
  #
  # Produces:
  #
  #     *<span class='small'>Not really</span>
  #
  # @param str [String] The string to add before the Haml
  # @yield A block of Haml to prepend to
  def precede(str, &block); end

  # Takes any string, finds all the newlines, and converts them to
  # HTML entities so they'll render correctly in
  # whitespace-sensitive tags without screwing up the indentation.
  #
  # @overload preserve
  # @overload preserve
  def preserve(input = T.unsafe(nil), &block); end

  # Appends a string to the end of a Haml block,
  # with no whitespace between.
  # For example:
  #
  #     click
  #     = succeed '.' do
  #       %a{:href=>"thing"} here
  #
  # Produces:
  #
  #     click
  #     <a href='thing'>here</a>.
  #
  # @param str [String] The string to add after the Haml
  # @yield A block of Haml to append to
  def succeed(str, &block); end

  # Surrounds a block of Haml code with strings,
  # with no whitespace in between.
  # For example:
  #
  #     = surround '(', ')' do
  #       %a{:href => "food"} chicken
  #
  # Produces:
  #
  #     (<a href='food'>chicken</a>)
  #
  # and
  #
  #     = surround '*' do
  #       %strong angry
  #
  # Produces:
  #
  #     *<strong>angry</strong>*
  #
  # @param front [String] The string to add before the Haml
  # @param back [String] The string to add after the Haml
  # @yield A block of Haml to surround
  def surround(front, back = T.unsafe(nil), &block); end

  # Decrements the number of tabs the buffer automatically adds
  # to the lines of the template.
  #
  # @param i [Fixnum] The number of tabs by which to decrease the indentation
  # @see #tab_up
  def tab_down(i = T.unsafe(nil)); end

  # Increments the number of tabs the buffer automatically adds
  # to the lines of the template.
  # For example:
  #
  #     %h1 foo
  #     - tab_up
  #     %p bar
  #     - tab_down
  #     %strong baz
  #
  # Produces:
  #
  #     <h1>foo</h1>
  #       <p>bar</p>
  #     <strong>baz</strong>
  #
  # @param i [Fixnum] The number of tabs by which to increase the indentation
  # @see #tab_down
  def tab_up(i = T.unsafe(nil)); end

  # Sets the number of tabs the buffer automatically adds
  # to the lines of the template,
  # but only for the duration of the block.
  # For example:
  #
  #     %h1 foo
  #     - with_tabs(2) do
  #       %p bar
  #     %strong baz
  #
  # Produces:
  #
  #     <h1>foo</h1>
  #         <p>bar</p>
  #     <strong>baz</strong>
  #
  # @param i [Fixnum] The number of tabs to use
  # @yield A block in which the indentation will be `i` spaces
  def with_tabs(i); end

  private

  # Gives a proc the same local `_hamlout` and `_erbout` variables
  # that the current template has.
  #
  # @param proc [#call] The proc to bind
  # @return [Proc] A new proc with the new variables bound
  def haml_bind_proc(&proc); end

  # The current {Haml::Buffer} object.
  #
  # @return [Haml::Buffer]
  def haml_buffer; end

  # Internal method to write directly to the buffer with control of
  # whether the first line should be indented, and if there should be a
  # final newline.
  #
  # Lines added will have the proper indentation. This can be controlled
  # for the first line.
  #
  # Used by #haml_concat and #haml_tag.
  #
  # @param text [#to_s] The text to output
  # @param newline [Boolean] Whether to add a newline after the text
  # @param indent [Boolean] Whether to add indentation to the first line
  def haml_internal_concat(text = T.unsafe(nil), newline = T.unsafe(nil), indent = T.unsafe(nil)); end

  # Internal method to write directly to the buffer with control of
  # whether the first line should be indented, and if there should be a
  # final newline.
  #
  # Lines added will have the proper indentation. This can be controlled
  # for the first line.
  #
  # Used by #haml_concat and #haml_tag.
  # Allows writing raw content. `haml_internal_concat_raw` isn't
  # effected by XSS mods. Used by #haml_tag to write the actual tags.
  #
  # @param text [#to_s] The text to output
  # @param newline [Boolean] Whether to add a newline after the text
  # @param indent [Boolean] Whether to add indentation to the first line
  def haml_internal_concat_raw(text = T.unsafe(nil), newline = T.unsafe(nil), indent = T.unsafe(nil)); end

  # Parses the tag name used for \{#haml\_tag}
  # and merges it with the Ruby attributes hash.
  def merge_name_and_attributes(name, attributes_hash = T.unsafe(nil)); end

  # Runs a block of code with the given buffer as the currently active buffer.
  #
  # @param buffer [Haml::Buffer] The Haml buffer to use temporarily
  # @yield A block in which the given buffer should be used
  def with_haml_buffer(buffer); end

  class << self
    # @return [Boolean] Whether or not ActionView is loaded
    def action_view?; end
  end
end

# An object that raises an error when \{#to\_s} is called.
# It's used to raise an error when the return value of a helper is used
# when it shouldn't be.
class Haml::Helpers::ErrorReturn
  # @return [ErrorReturn] a new instance of ErrorReturn
  def initialize(method); end

  # @return [String] A human-readable string representation
  def inspect; end

  # Raises an error.
  #
  # @raise [Haml::Error] The error
  def to_s; end
end

# Characters that need to be escaped to HTML entities from user input
Haml::Helpers::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)

Haml::Helpers::HTML_ESCAPE_ONCE_REGEX = T.let(T.unsafe(nil), Regexp)
Haml::Helpers::HTML_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)
class Haml::InvalidAttributeNameError < ::Haml::SyntaxError; end

# This class encapsulates all of the configuration options that Haml
# understands. Please see the {file:REFERENCE.md#options Haml Reference} to
# learn how to set the options.
class Haml::Options
  # @return [Options] a new instance of Options
  def initialize(values = T.unsafe(nil)); end

  # Retrieve an option value.
  #
  # @param key The value to retrieve.
  def [](key); end

  # Set an option value.
  #
  # @param key The key to set.
  # @param value The value to set for the key.
  def []=(key, value); end

  # The character that should wrap element attributes. This defaults to `'`
  # (an apostrophe). Characters of this type within the attributes will be
  # escaped (e.g. by replacing them with `&apos;`) if the character is an
  # apostrophe or a quotation mark.
  def attr_wrapper; end

  def attr_wrapper=(value); end

  # A list of tag names that should be automatically self-closed if they have
  # no content. This can also contain regular expressions that match tag names
  # (or any object which responds to `#===`). Defaults to `['meta', 'img',
  # 'link', 'br', 'hr', 'input', 'area', 'param', 'col', 'base']`.
  def autoclose; end

  # A list of tag names that should be automatically self-closed if they have
  # no content. This can also contain regular expressions that match tag names
  # (or any object which responds to `#===`). Defaults to `['meta', 'img',
  # 'link', 'br', 'hr', 'input', 'area', 'param', 'col', 'base']`.
  def autoclose=(_arg0); end

  # Whether to include CDATA sections around javascript and css blocks when
  # using the `:javascript` or `:css` filters.
  #
  # This option also affects the `:sass`, `:scss`, `:less` and `:coffeescript`
  # filters.
  #
  # Defaults to `false` for html, `true` for xhtml. Cannot be changed when using
  # xhtml.
  def cdata; end

  # Whether to include CDATA sections around javascript and css blocks when
  # using the `:javascript` or `:css` filters.
  #
  # This option also affects the `:sass`, `:scss`, `:less` and `:coffeescript`
  # filters.
  #
  # Defaults to `false` for html, `true` for xhtml. Cannot be changed when using
  # xhtml.
  def cdata=(_arg0); end

  # The compiler class to use. Defaults to Haml::Compiler.
  def compiler_class; end

  # The compiler class to use. Defaults to Haml::Compiler.
  def compiler_class=(_arg0); end

  # The encoding to use for the HTML output.
  # This can be a string or an `Encoding` Object. Note that Haml **does not**
  # automatically re-encode Ruby values; any strings coming from outside the
  # application should be converted before being passed into the Haml
  # template. Defaults to `Encoding.default_internal`; if that's not set,
  # defaults to the encoding of the Haml template; if that's `US-ASCII`,
  # defaults to `"UTF-8"`.
  def encoding; end

  def encoding=(value); end

  # Sets whether or not to escape HTML-sensitive characters in attributes. If
  # this is true, all HTML-sensitive characters in attributes are escaped. If
  # it's set to false, no HTML-sensitive characters in attributes are escaped.
  # If it's set to `:once`, existing HTML escape sequences are preserved, but
  # other HTML-sensitive characters are escaped.
  #
  # Defaults to `true`.
  def escape_attrs; end

  # Sets whether or not to escape HTML-sensitive characters in attributes. If
  # this is true, all HTML-sensitive characters in attributes are escaped. If
  # it's set to false, no HTML-sensitive characters in attributes are escaped.
  # If it's set to `:once`, existing HTML escape sequences are preserved, but
  # other HTML-sensitive characters are escaped.
  #
  # Defaults to `true`.
  def escape_attrs=(_arg0); end

  def escape_attrs?; end

  # Sets whether or not to escape HTML-sensitive characters in interpolated strings.
  # See also {file:REFERENCE.md#escaping_html Escaping HTML} and
  # {file:REFERENCE.md#unescaping_html Unescaping HTML}.
  #
  # Defaults to the current value of `escape_html`.
  def escape_filter_interpolations; end

  # Sets whether or not to escape HTML-sensitive characters in interpolated strings.
  # See also {file:REFERENCE.md#escaping_html Escaping HTML} and
  # {file:REFERENCE.md#unescaping_html Unescaping HTML}.
  #
  # Defaults to the current value of `escape_html`.
  def escape_filter_interpolations=(_arg0); end

  # Sets whether or not to escape HTML-sensitive characters in script. If this
  # is true, `=` behaves like {file:REFERENCE.md#escaping_html `&=`};
  # otherwise, it behaves like {file:REFERENCE.md#unescaping_html `!=`}. Note
  # that if this is set, `!=` should be used for yielding to subtemplates and
  # rendering partials. See also {file:REFERENCE.md#escaping_html Escaping HTML} and
  # {file:REFERENCE.md#unescaping_html Unescaping HTML}.
  #
  # Defaults to false.
  def escape_html; end

  # Sets whether or not to escape HTML-sensitive characters in script. If this
  # is true, `=` behaves like {file:REFERENCE.md#escaping_html `&=`};
  # otherwise, it behaves like {file:REFERENCE.md#unescaping_html `!=`}. Note
  # that if this is set, `!=` should be used for yielding to subtemplates and
  # rendering partials. See also {file:REFERENCE.md#escaping_html Escaping HTML} and
  # {file:REFERENCE.md#unescaping_html Unescaping HTML}.
  #
  # Defaults to false.
  def escape_html=(_arg0); end

  # The name of the Haml file being parsed.
  # This is only used as information when exceptions are raised. This is
  # automatically assigned when working through ActionView, so it's really
  # only useful for the user to assign when dealing with Haml programatically.
  def filename; end

  # The name of the Haml file being parsed.
  # This is only used as information when exceptions are raised. This is
  # automatically assigned when working through ActionView, so it's really
  # only useful for the user to assign when dealing with Haml programatically.
  def filename=(_arg0); end

  # Key is filter name in String and value is Class to use. Defaults to {}.
  def filters; end

  # Key is filter name in String and value is Class to use. Defaults to {}.
  def filters=(_arg0); end

  # Returns a non-default subset of options: those that {Haml::Buffer} cares about.
  # All of the values here are such that when `#inspect` is called on the hash,
  # it can be `Kernel#eval`ed to get the same result back.
  #
  # See {file:REFERENCE.md#options the Haml options documentation}.
  #
  # @return [{Symbol => Object}] The options hash
  def for_buffer; end

  # Determines the output format. The default is `:html5`. The other options
  # are `:html4` and `:xhtml`. If the output is set to XHTML, then Haml
  # automatically generates self-closing tags and wraps the output of the
  # Javascript and CSS-like filters inside CDATA. When the output is set to
  # `:html5` or `:html4`, XML prologs are ignored. In all cases, an appropriate
  # doctype is generated from `!!!`.
  #
  # If the mime_type of the template being rendered is `text/xml` then a
  # format of `:xhtml` will be used even if the global output format is set to
  # `:html4` or `:html5`.
  def format; end

  def format=(value); end

  # @return [Boolean] Whether or not the format is HTML4.
  def html4?; end

  # @return [Boolean] Whether or not the format is HTML5.
  def html5?; end

  # @return [Boolean] Whether or not the format is any flavor of HTML.
  def html?; end

  # If set to `true`, Haml will convert underscores to hyphens in all
  # {file:REFERENCE.md#html5_custom_data_attributes Custom Data Attributes} As
  # of Haml 4.0, this defaults to `true`.
  def hyphenate_data_attrs; end

  # If set to `true`, Haml will convert underscores to hyphens in all
  # {file:REFERENCE.md#html5_custom_data_attributes Custom Data Attributes} As
  # of Haml 4.0, this defaults to `true`.
  def hyphenate_data_attrs=(_arg0); end

  def hyphenate_data_attrs?; end

  # The line offset of the Haml template being parsed. This is useful for
  # inline templates, similar to the last argument to `Kernel#eval`.
  def line; end

  # The line offset of the Haml template being parsed. This is useful for
  # inline templates, similar to the last argument to `Kernel#eval`.
  def line=(_arg0); end

  # The mime type that the rendered document will be served with. If this is
  # set to `text/xml` then the format will be overridden to `:xhtml` even if
  # it has set to `:html4` or `:html5`.
  def mime_type; end

  # The mime type that the rendered document will be served with. If this is
  # set to `text/xml` then the format will be overridden to `:xhtml` even if
  # it has set to `:html4` or `:html5`.
  def mime_type=(_arg0); end

  # The parser class to use. Defaults to Haml::Parser.
  def parser_class; end

  # The parser class to use. Defaults to Haml::Parser.
  def parser_class=(_arg0); end

  # A list of tag names that should automatically have their newlines
  # preserved using the {Haml::Helpers#preserve} helper. This means that any
  # content given on the same line as the tag will be preserved. For example,
  # `%textarea= "Foo\nBar"` compiles to `<textarea>Foo&#x000A;Bar</textarea>`.
  # Defaults to `['textarea', 'pre']`. See also
  # {file:REFERENCE.md#whitespace_preservation Whitespace Preservation}.
  def preserve; end

  # A list of tag names that should automatically have their newlines
  # preserved using the {Haml::Helpers#preserve} helper. This means that any
  # content given on the same line as the tag will be preserved. For example,
  # `%textarea= "Foo\nBar"` compiles to `<textarea>Foo&#x000A;Bar</textarea>`.
  # Defaults to `['textarea', 'pre']`. See also
  # {file:REFERENCE.md#whitespace_preservation Whitespace Preservation}.
  def preserve=(_arg0); end

  # If set to `true`, all tags are treated as if both
  # {file:REFERENCE.md#whitespace_removal__and_ whitespace removal} options
  # were present. Use with caution as this may cause whitespace-related
  # formatting errors.
  #
  # Defaults to `false`.
  def remove_whitespace; end

  # If set to `true`, all tags are treated as if both
  # {file:REFERENCE.md#whitespace_removal__and_ whitespace removal} options
  # were present. Use with caution as this may cause whitespace-related
  # formatting errors.
  #
  # Defaults to `false`.
  def remove_whitespace=(_arg0); end

  def remove_whitespace?; end

  # Whether or not attribute hashes and Ruby scripts designated by `=` or `~`
  # should be evaluated. If this is `true`, said scripts are rendered as empty
  # strings.
  #
  # Defaults to `false`.
  def suppress_eval; end

  # Whether or not attribute hashes and Ruby scripts designated by `=` or `~`
  # should be evaluated. If this is `true`, said scripts are rendered as empty
  # strings.
  #
  # Defaults to `false`.
  def suppress_eval=(_arg0); end

  def suppress_eval?; end

  # Enable template tracing. If true, it will add a 'data-trace' attribute to
  # each tag generated by Haml. The value of the attribute will be the
  # source template name and the line number from which the tag was generated,
  # separated by a colon. On Rails applications, the path given will be a
  # relative path as from the views directory. On non-Rails applications,
  # the path will be the full path.
  def trace; end

  # Enable template tracing. If true, it will add a 'data-trace' attribute to
  # each tag generated by Haml. The value of the attribute will be the
  # source template name and the line number from which the tag was generated,
  # separated by a colon. On Rails applications, the path given will be a
  # relative path as from the views directory. On non-Rails applications,
  # the path will be the full path.
  def trace=(_arg0); end

  # @return [Boolean] Whether or not the format is XHTML.
  def xhtml?; end

  private

  def defaults; end

  class << self
    # Returns a subset of defaults: those that {Haml::Buffer} cares about.
    #
    # @return [{Symbol => Object}] The options hash
    def buffer_defaults; end

    # An array of keys that will be used to provide a hash of options to
    # {Haml::Buffer}.
    #
    # @return Hash
    def buffer_option_keys; end

    # The default option values.
    #
    # @return Hash
    def defaults; end

    # An array of valid values for the `:format` option.
    #
    # @return Array
    def valid_formats; end

    def wrap(options); end
  end
end

class Haml::Parser
  include ::Haml::Util

  # @return [Parser] a new instance of Parser
  def initialize(options); end

  def call(template); end

  # @raise [SyntaxError]
  def compute_tabs(line); end

  # Returns the value of attribute root.
  def root; end

  private

  def balance(*args); end

  # Unlike #balance, this balances Ripper tokens to balance something like `{ a: "}" }` correctly.
  #
  # @raise [SyntaxError]
  def balance_tokens(buf, start, finish, count: T.unsafe(nil)); end

  def block_keyword(text); end

  # @return [Boolean]
  def block_opened?; end

  def check_push_script_stack(keyword); end
  def close; end
  def close_filter(_); end
  def close_flat_section; end
  def close_haml_comment(_); end
  def close_script(node); end
  def close_silent_script(node); end

  # @return [Boolean]
  def closes_flat?(line); end

  # Renders an XHTML comment.
  def comment(text); end

  # @return [Boolean]
  def continuation_script?(text); end

  # Renders a line that creates an XHTML tag and has an implicit div because of
  # `.` or `#`.
  def div(line); end

  # Renders an XHTML doctype or XML shebang.
  #
  # @raise [SyntaxError]
  def doctype(text); end

  # @raise [Error]
  def filter(name); end

  # Same semantics as block_opened?, except that block_opened? uses Line#tabs,
  # which doesn't interact well with filter lines
  #
  # @return [Boolean]
  def filter_opened?; end

  # @return [Boolean]
  def flat?; end

  # @raise [SyntaxError]
  def flat_script(line, escape_html = T.unsafe(nil)); end

  def haml_comment(text); end
  def handle_multiline(line); end
  def handle_ruby_multiline(line); end

  # Checks whether or not `line` is in a multiline sequence.
  #
  # @return [Boolean]
  def is_multiline?(text); end

  # `text' is a Ruby multiline block if it:
  # - ends with a comma
  # - but not "?," which is a character literal
  #   (however, "x?," is a method call and not a literal)
  # - and not "?\," which is a character literal
  #
  # @return [Boolean]
  def is_ruby_multiline?(text); end

  # @return [Boolean]
  def mid_block_keyword?(text); end

  def next_line; end
  def parse_new_attribute(scanner); end

  # @return [Array<Hash,String,nil>] - [static_attributes (Hash), dynamic_attributes (nil or String starting with `{` and ending with `}`)]
  # @return [String] rest
  # @return [Integer] last_line
  def parse_new_attributes(text); end

  # @return [String] attributes_hash - Hash literal starting with `{` and ending with `}`
  # @return [String] rest
  # @return [Integer] last_line
  def parse_old_attributes(text); end

  # This method doesn't use Haml::AttributeParser because currently it depends on Ripper and Rubinius doesn't provide it.
  # Ideally this logic should be placed in Haml::AttributeParser instead of here and this method should use it.
  #
  # @param text [String] - Hash literal or text inside old attributes
  # @return [Hash, nil] - Return nil if text is not static Hash literal
  def parse_static_hash(text); end

  # Parses a line into tag_name, attributes, attributes_hash, object_ref, action, value
  #
  # @raise [SyntaxError]
  def parse_tag(text); end

  def plain(line, escape_html = T.unsafe(nil)); end

  # Processes and deals with lowering indentation.
  def process_indent(line); end

  # Processes a single line of Haml.
  #
  # This method doesn't return anything; it simply processes the line and
  # adds the appropriate code to `@precompiled`.
  def process_line(line); end

  def push(node); end

  # @raise [SyntaxError]
  def script(line, escape_html = T.unsafe(nil), preserve = T.unsafe(nil)); end

  # @raise [SyntaxError]
  def silent_script(line); end

  # @raise [SyntaxError]
  def tag(line); end

  class << self
    # This is a class method so it can be accessed from {Haml::Helpers}.
    #
    # Iterates through the classes and ids supplied through `.`
    # and `#` syntax, and returns a hash with them as attributes,
    # that can then be merged with another attributes hash.
    def parse_class_and_id(list); end
  end
end

Haml::Parser::BLOCK_KEYWORD_REGEX = T.let(T.unsafe(nil), Regexp)

# Regex to check for blocks with spaces around arguments. Not to be confused
# with multiline script.
# For example:
#     foo.each do | bar |
#       = bar
Haml::Parser::BLOCK_WITH_SPACES = T.let(T.unsafe(nil), Regexp)

Haml::Parser::CLASS_KEY = T.let(T.unsafe(nil), String)

# Designates an XHTML/XML comment.
Haml::Parser::COMMENT = T.let(T.unsafe(nil), String)

# Designates a `<div>` element with the given class.
Haml::Parser::DIV_CLASS = T.let(T.unsafe(nil), String)

# Designates a `<div>` element with the given id.
Haml::Parser::DIV_ID = T.let(T.unsafe(nil), String)

# Designates an XHTML doctype or script that is never HTML-escaped.
Haml::Parser::DOCTYPE = T.let(T.unsafe(nil), String)

# The Regex that matches a Doctype command.
Haml::Parser::DOCTYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# @param new [String] - Hash literal including dynamic values.
# @param old [String] - Hash literal including dynamic values or Ruby literal of multiple Hashes which MUST be interpreted as method's last arguments.
class Haml::Parser::DynamicAttributes < ::Struct
  # Returns the value of attribute new
  #
  # @return [Object] the current value of new
  def new; end

  # Sets the attribute new
  #
  # @param value [Object] the value to set the attribute new to.
  # @return [Object] the newly set value
  def new=(_); end

  # Returns the value of attribute old
  #
  # @return [Object] the current value of old
  def old; end

  # Sets the attribute old
  #
  # @param value [Object] the value to set the attribute old to.
  # @return [Object] the newly set value
  def old=(value); end

  # This will be a literal for Haml::Buffer#attributes's last argument, `attributes_hashes`.
  def to_literal; end

  private

  # For `%foo{ { foo: 1 }, bar: 2 }`, :old is "{ { foo: 1 }, bar: 2 }" and this method returns " { foo: 1 }, bar: 2 " for last argument.
  def stripped_old; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Designates an XHTML/XML element.
Haml::Parser::ELEMENT = T.let(T.unsafe(nil), String)

# Designates a non-parsed line.
Haml::Parser::ESCAPE = T.let(T.unsafe(nil), String)

# Designates a block of filtered text.
Haml::Parser::FILTER = T.let(T.unsafe(nil), String)

# Designates script, the result of which is flattened and output.
Haml::Parser::FLAT_SCRIPT = T.let(T.unsafe(nil), String)

Haml::Parser::ID_KEY = T.let(T.unsafe(nil), String)

# The Regex that matches a literal string or symbol value
Haml::Parser::LITERAL_VALUE_REGEX = T.let(T.unsafe(nil), Regexp)

# @private
class Haml::Parser::Line < ::Struct
  # Returns the value of attribute eod
  #
  # @return [Object] the current value of eod
  def eod; end

  # Sets the attribute eod
  #
  # @param value [Object] the value to set the attribute eod to.
  # @return [Object] the newly set value
  def eod=(_); end

  # Returns the value of attribute eod
  #
  # @return [Object] the current value of eod
  def eod?; end

  # Returns the value of attribute full
  #
  # @return [Object] the current value of full
  def full; end

  # Sets the attribute full
  #
  # @param value [Object] the value to set the attribute full to.
  # @return [Object] the newly set value
  def full=(_); end

  # Returns the value of attribute index
  #
  # @return [Object] the current value of index
  def index; end

  # Sets the attribute index
  #
  # @param value [Object] the value to set the attribute index to.
  # @return [Object] the newly set value
  def index=(_); end

  # Returns the value of attribute parser
  #
  # @return [Object] the current value of parser
  def parser; end

  # Sets the attribute parser
  #
  # @param value [Object] the value to set the attribute parser to.
  # @return [Object] the newly set value
  def parser=(_); end

  def strip!(from); end

  # @private
  def tabs; end

  # Returns the value of attribute text
  #
  # @return [Object] the current value of text
  def text; end

  # Sets the attribute text
  #
  # @param value [Object] the value to set the attribute text to.
  # @return [Object] the newly set value
  def text=(_); end

  # Returns the value of attribute whitespace
  #
  # @return [Object] the current value of whitespace
  def whitespace; end

  # Sets the attribute whitespace
  #
  # @param value [Object] the value to set the attribute whitespace to.
  # @return [Object] the newly set value
  def whitespace=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Used for scanning old attributes, substituting the first '{'
Haml::Parser::METHOD_CALL_PREFIX = T.let(T.unsafe(nil), String)

Haml::Parser::MID_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# The value of the character that designates that a line is part
# of a multiline string.
Haml::Parser::MULTILINE_CHAR_VALUE = T.let(T.unsafe(nil), String)

# Designates a non-parsed line. Not actually a character.
Haml::Parser::PLAIN_TEXT = T.let(T.unsafe(nil), Integer)

# @private
class Haml::Parser::ParseNode < ::Struct
  # @return [ParseNode] a new instance of ParseNode
  def initialize(*args); end

  # Returns the value of attribute children
  #
  # @return [Object] the current value of children
  def children; end

  # Sets the attribute children
  #
  # @param value [Object] the value to set the attribute children to.
  # @return [Object] the newly set value
  def children=(_); end

  def inspect; end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute parent
  #
  # @return [Object] the current value of parent
  def parent; end

  # Sets the attribute parent
  #
  # @param value [Object] the value to set the attribute parent to.
  # @return [Object] the newly set value
  def parent=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Designates script that is always HTML-escaped.
Haml::Parser::SANITIZE = T.let(T.unsafe(nil), String)

# Designates script, the result of which is output.
Haml::Parser::SCRIPT = T.let(T.unsafe(nil), String)

# When following SILENT_SCRIPT, designates a comment that is not output.
Haml::Parser::SILENT_COMMENT = T.let(T.unsafe(nil), String)

# Designates script which is run but not output.
Haml::Parser::SILENT_SCRIPT = T.let(T.unsafe(nil), String)

# Keeps track of the ASCII values of the characters that begin a
# specially-interpreted line.
Haml::Parser::SPECIAL_CHARACTERS = T.let(T.unsafe(nil), Array)

Haml::Parser::START_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Try to parse assignments to block starters as best as possible
Haml::Parser::START_BLOCK_KEYWORD_REGEX = T.let(T.unsafe(nil), Regexp)

class Haml::Railtie < ::Rails::Railtie; end

# SyntaxError is the type of exception raised when Haml encounters an
# ill-formatted document.
# It's not particularly interesting,
# except in that it's a subclass of {Haml::Error}.
class Haml::SyntaxError < ::Haml::Error; end

module Haml::Template
  extend ::Haml::Template

  # The options hash for Haml when used within Rails.
  # See {file:REFERENCE.md#options the Haml options documentation}.
  #
  # @return [Haml::Template::Options<Symbol => Object>]
  def options; end

  # The options hash for Haml when used within Rails.
  # See {file:REFERENCE.md#options the Haml options documentation}.
  #
  # @return [Haml::Template::Options<Symbol => Object>]
  def options=(_arg0); end
end

class Haml::Template::Options < ::Hash
  def []=(key, value); end
end

class Haml::TempleEngine < ::Temple::Engine
  def compile(template); end

  # The source code that is evaluated to produce the Haml document.
  #
  # This is automatically converted to the correct encoding
  # (see {file:REFERENCE.md#encodings the `:encoding` option}).
  #
  # @return [String]
  def precompiled; end

  # The source code that is evaluated to produce the Haml document.
  #
  # This is automatically converted to the correct encoding
  # (see {file:REFERENCE.md#encodings the `:encoding` option}).
  #
  # @return [String]
  def precompiled_with_ambles(local_names, after_preamble: T.unsafe(nil), before_postamble: T.unsafe(nil)); end

  def precompiled_with_return_value; end

  private

  def initialize_encoding(template, given_value); end
  def inspect_obj(obj); end
  def locals_code(names); end

  # Returns the string used as the return value of the precompiled method.
  # This method exists so it can be monkeypatched to return modified values.
  def precompiled_method_return_value; end
end

# A module to count lines of expected code. This would be faster than actual code generation
# and counting newlines in it.
module Haml::TempleLineCounter
  class << self
    def count_lines(exp); end
  end
end

class Haml::TempleLineCounter::UnexpectedExpression < ::StandardError; end

# A module containing various useful functions.
module Haml::Util
  extend ::Haml::Util

  # Moves a scanner through a balanced pair of characters.
  # For example:
  #
  #     Foo (Bar (Baz bang) bop) (Bang (bop bip))
  #     ^                       ^
  #     from                    to
  #
  # @param scanner [StringScanner] The string scanner to move
  # @param start [String] The character opening the balanced pair.
  # @param finish [String] The character closing the balanced pair.
  # @param count [Fixnum] The number of opening characters matched
  #   before calling this method
  # @return [(String, String)] The string matched within the balanced pair
  #   and the rest of the string.
  #   `["Foo (Bar (Baz bang) bop)", " (Bang (bop bip))"]` in the example above.
  def balance(scanner, start, finish, count = T.unsafe(nil)); end

  # Checks that the encoding of a string is valid
  # and cleans up potential encoding gotchas like the UTF-8 BOM.
  # If it's not, yields an error string describing the invalid character
  # and the line on which it occurs.
  #
  # @param str [String] The string of which to check the encoding
  # @return [String] `str`, potentially with encoding gotchas like BOMs removed
  # @yield [msg] A block in which an encoding error can be raised.
  #   Only yields if there is an encoding error
  # @yieldparam msg [String] The error message to be raised
  def check_encoding(str); end

  # Like {\#check\_encoding}, but also checks for a Ruby-style `-# coding:` comment
  # at the beginning of the template and uses that encoding if it exists.
  #
  # The Haml encoding rules are simple.
  # If a `-# coding:` comment exists,
  # we assume that that's the original encoding of the document.
  # Otherwise, we use whatever encoding Ruby has.
  #
  # Haml uses the same rules for parsing coding comments as Ruby.
  # This means that it can understand Emacs-style comments
  # and also that it cannot understand non-ASCII-compatible encodings
  # such as `UTF-16` and `UTF-32`.
  #
  # @param str [String] The Haml template of which to check the encoding
  # @raise [ArgumentError] if the document declares an unknown encoding
  # @return [String] The original string encoded properly
  # @yield [msg] A block in which an encoding error can be raised.
  #   Only yields if there is an encoding error
  # @yieldparam msg [String] The error message to be raised
  def check_haml_encoding(str, &block); end

  # @return [Boolean]
  def contains_interpolation?(str); end

  # Scans through a string looking for the interoplation-opening `#{`
  # and, when it's found, yields the scanner to the calling code
  # so it can handle it properly.
  #
  # The scanner will have any backslashes immediately in front of the `#{`
  # as the second capture group (`scan[2]`),
  # and the text prior to that as the first (`scan[1]`).
  #
  # @return [String] The text remaining in the scanner after all `#{`s have been processed
  # @yieldparam scan [StringScanner] The scanner scanning through the string
  def handle_interpolation(str); end

  # Returns the given text, marked as being HTML-safe.
  # With older versions of the Rails XSS-safety mechanism,
  # this destructively modifies the HTML-safety of `text`.
  #
  # It only works if you are using ActiveSupport or the parameter `text`
  # implements the #html_safe method.
  #
  # @param text [String, nil]
  # @return [String, nil] `text`, marked as HTML-safe
  def html_safe(text); end

  # Formats a string for use in error messages about indentation.
  #
  # @param indentation [String] The string used for indentation
  # @return [String] The name of the indentation (e.g. `"12 spaces"`, `"1 tab"`)
  def human_indentation(indentation); end

  # Like `Object#inspect`, but preserves non-ASCII characters rather than escaping them.
  # This is necessary so that the precompiled Haml template can be `#encode`d into `@options[:encoding]`
  # before being evaluated.
  #
  # @param obj [Object]
  # @return [String]
  def inspect_obj(obj); end

  # Whether or not ActionView's XSS protection is available and enabled,
  # as is the default for Rails 3.0+, and optional for version 2.3.5+.
  # Overridden in haml/template.rb if this is the case.
  #
  # @return [Boolean]
  def rails_xss_safe?; end

  # Silence all output to STDERR within a block.
  #
  # @yield A block in which no output will be printed to STDERR
  def silence_warnings; end

  def unescape_interpolation(str, escape_html = T.unsafe(nil)); end

  private

  # Parses a magic comment at the beginning of a Haml file.
  # The parsing rules are basically the same as Ruby's.
  #
  # @return [(Boolean, String or nil)] Whether the document begins with a UTF-8 BOM,
  #   and the declared encoding of the document (or nil if none is declared)
  def parse_haml_magic_comment(str); end

  def try_parse_haml_emacs_magic_comment(scanner); end
end

Haml::VERSION = T.let(T.unsafe(nil), String)

# @private
class Object < ::BasicObject
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  include ::Kernel
  include ::DEBUGGER__::TrapInterceptor
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::FriendlyId::ObjectUtils
  include ::PP::ObjectMixin

  # Haml overrides various `ActionView` helpers,
  # which call an \{#is\_haml?} method
  # to determine whether or not the current context object
  # is a proper Haml context.
  # Because `ActionView` helpers may be included in non-`ActionView::Base` classes,
  # it's a good idea to define \{#is\_haml?} for all objects.
  #
  # @return [Boolean]
  def is_haml?; end
end
