# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `capybara-screenshot` gem.
# Please instead update this file by running `bin/tapioca gem capybara-screenshot`.

module Capybara
  extend ::Capybara::DSL

  class << self
    # Parse raw html into a document using Nokogiri, and adjust textarea contents as defined by the spec.
    #
    # @param html [String] The raw html
    # @return [Nokogiri::HTML::Document] HTML document
    def HTML(html); end

    # Add a new selector to Capybara. Selectors can be used by various methods in Capybara
    # to find certain elements on the page in a more convenient way. For example adding a
    # selector to find certain table rows might look like this:
    #
    #     Capybara.add_selector(:row) do
    #       xpath { |num| ".//tbody/tr[#{num}]" }
    #     end
    #
    # This makes it possible to use this selector in a variety of ways:
    #
    #     find(:row, 3)
    #     page.find('table#myTable').find(:row, 3).text
    #     page.find('table#myTable').has_selector?(:row, 3)
    #     within(:row, 3) { expect(page).to have_content('$100.000') }
    #
    # Here is another example:
    #
    #     Capybara.add_selector(:id) do
    #       xpath { |id| XPath.descendant[XPath.attr(:id) == id.to_s] }
    #     end
    #
    # Note that this particular selector already ships with Capybara.
    #
    # @param name [Symbol] The name of the selector to add
    # @yield A block executed in the context of the new {Capybara::Selector}
    def add_selector(name, **options, &block); end

    def allow_gumbo(*args, **_arg1, &block); end
    def allow_gumbo=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def always_include_port(*args, **_arg1, &block); end

    def always_include_port=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def app(*args, **_arg1, &block); end

    def app=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def app_host(*args, **_arg1, &block); end

    def app_host=(*args, **_arg1, &block); end
    def asset_host(*args, **_arg1, &block); end
    def asset_host=(*args, **_arg1, &block); end
    def automatic_label_click(*args, **_arg1, &block); end
    def automatic_label_click=(*args, **_arg1, &block); end
    def automatic_reload(*args, **_arg1, &block); end
    def automatic_reload=(*args, **_arg1, &block); end

    # Configure Capybara to suit your needs.
    #
    #     Capybara.configure do |config|
    #       config.run_server = false
    #       config.app_host   = 'http://www.google.com'
    #     end
    #
    # #### Configurable options
    #
    # - **use_html5_parsing** (Boolean = `false`) - When Nokogiri >= 1.12.0 or `nokogumbo` is installed, whether HTML5 parsing will be used for HTML strings.
    # - **always_include_port** (Boolean = `false`) - Whether the Rack server's port should automatically be inserted into every visited URL
    #   unless another port is explicitly specified.
    # - **app_host** (String, `nil`) - The default host to use when giving a relative URL to visit, must be a valid URL e.g. `http://www.example.com`.
    # - **asset_host** (String = `nil`) - Where dynamic assets are hosted - will be prepended to relative asset locations if present.
    # - **automatic_label_click** (Boolean = `false`) - Whether {Capybara::Node::Element#choose Element#choose}, {Capybara::Node::Element#check Element#check},
    #   {Capybara::Node::Element#uncheck Element#uncheck} will attempt to click the associated `<label>` element if the checkbox/radio button are non-visible.
    # - **automatic_reload** (Boolean = `true`) - Whether to automatically reload elements as Capybara is waiting.
    # - **default_max_wait_time** (Numeric = `2`) - The maximum number of seconds to wait for asynchronous processes to finish.
    # - **default_normalize_ws** (Boolean = `false`) - Whether text predicates and matchers use normalize whitespace behavior.
    # - **default_selector** (`:css`, `:xpath` = `:css`) - Methods which take a selector use the given type by default. See also {Capybara::Selector}.
    # - **default_set_options** (Hash = `{}`) - The default options passed to {Capybara::Node::Element#set Element#set}.
    # - **enable_aria_label** (Boolean = `false`) - Whether fields, links, and buttons will match against `aria-label` attribute.
    # - **enable_aria_role** (Boolean = `false`) - Selectors will check for relevant aria role (currently only `button`).
    # - **exact** (Boolean = `false`) - Whether locators are matched exactly or with substrings. Only affects selector conditions
    #   written using the `XPath#is` method.
    # - **exact_text** (Boolean = `false`) - Whether the text matchers and `:text` filter match exactly or on substrings.
    # - **ignore_hidden_elements** (Boolean = `true`) - Whether to ignore hidden elements on the page.
    # - **match** (`:one`, `:first`, `:prefer_exact`, `:smart` = `:smart`) - The matching strategy to find nodes.
    # - **predicates_wait** (Boolean = `true`) - Whether Capybara's predicate matchers use waiting behavior by default.
    # - **raise_server_errors** (Boolean = `true`) - Should errors raised in the server be raised in the tests?
    # - **reuse_server** (Boolean = `true`) - Whether to reuse the server thread between multiple sessions using the same app object.
    # - **run_server** (Boolean = `true`) - Whether to start a Rack server for the given Rack app.
    # - **save_path** (String = `Dir.pwd`) - Where to put pages saved through {Capybara::Session#save_page save_page}, {Capybara::Session#save_screenshot save_screenshot},
    #   {Capybara::Session#save_and_open_page save_and_open_page}, or {Capybara::Session#save_and_open_screenshot save_and_open_screenshot}.
    # - **server** (Symbol = `:default` (which uses puma)) - The name of the registered server to use when running the app under test.
    # - **server_port** (Integer) - The port Capybara will run the application server on, if not specified a random port will be used.
    # - **server_errors** (Array\<Class> = `[Exception]`) - Error classes that should be raised in the tests if they are raised in the server
    #   and {configure raise_server_errors} is `true`.
    # - **test_id** (Symbol, String, `nil` = `nil`) - Optional attribute to match locator against with built-in selectors along with id.
    # - **threadsafe** (Boolean = `false`) - Whether sessions can be configured individually.
    # - **w3c_click_offset** (Boolean = 'false') - Whether click offsets should be from element center (true) or top left (false)
    #
    # #### DSL Options
    #
    # When using `capybara/dsl`, the following options are also available:
    #
    # - **default_driver** (Symbol = `:rack_test`) - The name of the driver to use by default.
    # - **javascript_driver** (Symbol = `:selenium`) - The name of a driver to use for JavaScript enabled tests.
    #
    # @yield [config]
    def configure; end

    # @return [Symbol] The name of the driver currently in use
    def current_driver; end

    def current_driver=(name); end

    # The current {Capybara::Session} based on what is set as {app} and {current_driver}.
    #
    # @return [Capybara::Session] The currently used session
    def current_session; end

    # See {Capybara.configure}
    def default_driver(*args, **_arg1, &block); end

    def default_driver=(*args, **_arg1, &block); end
    def default_host(*args, **_arg1, &block); end
    def default_host=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def default_max_wait_time(*args, **_arg1, &block); end

    def default_max_wait_time=(*args, **_arg1, &block); end
    def default_normalize_ws(*args, **_arg1, &block); end
    def default_normalize_ws=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def default_selector(*args, **_arg1, &block); end

    def default_selector=(*args, **_arg1, &block); end
    def default_set_options(*args, **_arg1, &block); end
    def default_set_options=(*args, **_arg1, &block); end
    def disable_animation(*args, **_arg1, &block); end
    def disable_animation=(*args, **_arg1, &block); end
    def drivers; end
    def enable_aria_label(*args, **_arg1, &block); end
    def enable_aria_label=(*args, **_arg1, &block); end
    def enable_aria_role(*args, **_arg1, &block); end
    def enable_aria_role=(*args, **_arg1, &block); end
    def exact(*args, **_arg1, &block); end
    def exact=(*args, **_arg1, &block); end
    def exact_text(*args, **_arg1, &block); end
    def exact_text=(*args, **_arg1, &block); end
    def ignore_hidden_elements(*args, **_arg1, &block); end
    def ignore_hidden_elements=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def javascript_driver(*args, **_arg1, &block); end

    def javascript_driver=(*args, **_arg1, &block); end
    def match(*args, **_arg1, &block); end
    def match=(*args, **_arg1, &block); end

    # @return [Symbol] The name of the driver currently in use
    def mode; end

    # Modify a selector previously created by {Capybara.add_selector}.
    # For example, adding a new filter to the :button selector to filter based on
    # button style (a class) might look like this
    #
    #     Capybara.modify_selector(:button) do
    #       filter (:btn_style, valid_values: [:primary, :secondary]) { |node, style| node[:class].split.include? "btn-#{style}" }
    #     end
    #
    # @param name [Symbol] The name of the selector to modify
    # @yield A block executed in the context of the existing {Capybara::Selector}
    def modify_selector(name, &block); end

    def predicates_wait(*args, **_arg1, &block); end
    def predicates_wait=(*args, **_arg1, &block); end
    def raise_server_errors(*args, **_arg1, &block); end
    def raise_server_errors=(*args, **_arg1, &block); end

    # Register a new driver for Capybara.
    #
    #     Capybara.register_driver :rack_test do |app|
    #       Capybara::RackTest::Driver.new(app)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app] This block takes a rack app and returns a Capybara driver
    # @yieldparam app [<Rack>] The rack application that this driver runs against. May be nil.
    # @yieldreturn [Capybara::Driver::Base] A Capybara driver instance
    def register_driver(name, &block); end

    # Register a new server for Capybara.
    #
    #     Capybara.register_server :webrick do |app, port, host|
    #       require 'rack/handler/webrick'
    #       Rack::Handler::WEBrick.run(app, ...)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app, port, host] This block takes a rack app and a port and returns a rack server listening on that port
    # @yieldparam app [<Rack>] The rack application that this server will contain.
    # @yieldparam port The port number the server should listen on
    # @yieldparam host The host/ip to bind to
    def register_server(name, &block); end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    def reset!; end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    def reset_sessions!; end

    # See {Capybara.configure}
    def reuse_server(*args, **_arg1, &block); end

    def reuse_server=(*args, **_arg1, &block); end

    # Runs Capybara's default server for the given application and port
    # under most circumstances you should not have to call this method
    # manually.
    #
    # @param app [Rack Application] The rack application to run
    # @param port [Integer] The port to run the application on
    def run_default_server(app, port); end

    def run_server(*args, **_arg1, &block); end
    def run_server=(*args, **_arg1, &block); end
    def save_path(*args, **_arg1, &block); end
    def save_path=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def server(*args, **_arg1, &block); end

    def server=(*args, **_arg1, &block); end
    def server_errors(*args, **_arg1, &block); end
    def server_errors=(*args, **_arg1, &block); end
    def server_host(*args, **_arg1, &block); end
    def server_host=(*args, **_arg1, &block); end
    def server_port(*args, **_arg1, &block); end
    def server_port=(*args, **_arg1, &block); end
    def servers; end

    # The current session name.
    #
    # @return [Symbol] The name of the currently used session.
    def session_name; end

    def session_name=(name); end
    def session_options; end

    # Wraps the given string, which should contain an HTML document or fragment
    # in a {Capybara::Node::Simple} which exposes all {Capybara::Node::Matchers},
    # {Capybara::Node::Finders} and {Capybara::Node::DocumentMatchers}. This allows you to query
    # any string containing HTML in the exact same way you would query the current document in a Capybara
    # session.
    #
    # @example A single element
    #   node = Capybara.string('<a href="foo">bar</a>')
    #   anchor = node.first('a')
    #   anchor[:href] #=> 'foo'
    #   anchor.text #=> 'bar'
    # @example Multiple elements
    #   node = Capybara.string <<-HTML
    #   <ul>
    #   <li id="home">Home</li>
    #   <li id="projects">Projects</li>
    #   </ul>
    #   HTML
    #
    #   node.find('#projects').text # => 'Projects'
    #   node.has_selector?('li#home', text: 'Home')
    #   node.has_selector?('#projects')
    #   node.find('ul').find('li:first-child').text # => 'Home'
    # @param html [String] An html fragment or document
    # @return [Capybara::Node::Simple] A node which has Capybara's finders and matchers
    def string(html); end

    def test_id(*args, **_arg1, &block); end
    def test_id=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    def threadsafe(*args, **_arg1, &block); end

    def threadsafe=(*args, **_arg1, &block); end

    # Use the default driver as the current driver
    def use_default_driver; end

    # See {Capybara.configure}
    def use_html5_parsing(*args, **_arg1, &block); end

    def use_html5_parsing=(*args, **_arg1, &block); end

    # Yield a block using a specific driver
    def using_driver(driver); end

    # Yield a block using a specific session name or {Capybara::Session} instance.
    def using_session(name, &block); end

    def using_session_with_screenshot(name, &block); end

    # Yield a block using a specific wait time
    def using_wait_time(seconds); end

    def visible_text_only(*args, **_arg1, &block); end
    def visible_text_only=(*args, **_arg1, &block); end
    def w3c_click_offset(*args, **_arg1, &block); end
    def w3c_click_offset=(*args, **_arg1, &block); end

    private

    def config; end
    def session_pool; end
    def specified_session; end
    def specified_session=(session); end
  end
end

# :nocov:
module Capybara::DSL
  def accept_alert(*_arg0, **_arg1, &_arg2); end
  def accept_confirm(*_arg0, **_arg1, &_arg2); end
  def accept_prompt(*_arg0, **_arg1, &_arg2); end
  def all(*_arg0, **_arg1, &_arg2); end
  def assert_all_of_selectors(*_arg0, **_arg1, &_arg2); end
  def assert_any_of_selectors(*_arg0, **_arg1, &_arg2); end
  def assert_current_path(*_arg0, **_arg1, &_arg2); end
  def assert_no_current_path(*_arg0, **_arg1, &_arg2); end
  def assert_no_selector(*_arg0, **_arg1, &_arg2); end
  def assert_no_text(*_arg0, **_arg1, &_arg2); end
  def assert_no_title(*_arg0, **_arg1, &_arg2); end
  def assert_none_of_selectors(*_arg0, **_arg1, &_arg2); end
  def assert_selector(*_arg0, **_arg1, &_arg2); end
  def assert_text(*_arg0, **_arg1, &_arg2); end
  def assert_title(*_arg0, **_arg1, &_arg2); end
  def attach_file(*_arg0, **_arg1, &_arg2); end
  def body(*_arg0, **_arg1, &_arg2); end
  def check(*_arg0, **_arg1, &_arg2); end
  def choose(*_arg0, **_arg1, &_arg2); end
  def click_button(*_arg0, **_arg1, &_arg2); end
  def click_link(*_arg0, **_arg1, &_arg2); end
  def click_link_or_button(*_arg0, **_arg1, &_arg2); end
  def click_on(*_arg0, **_arg1, &_arg2); end
  def current_host(*_arg0, **_arg1, &_arg2); end
  def current_path(*_arg0, **_arg1, &_arg2); end
  def current_scope(*_arg0, **_arg1, &_arg2); end
  def current_url(*_arg0, **_arg1, &_arg2); end
  def current_window(*_arg0, **_arg1, &_arg2); end
  def dismiss_confirm(*_arg0, **_arg1, &_arg2); end
  def dismiss_prompt(*_arg0, **_arg1, &_arg2); end
  def evaluate_script(*_arg0, **_arg1, &_arg2); end
  def execute_script(*_arg0, **_arg1, &_arg2); end
  def fill_in(*_arg0, **_arg1, &_arg2); end
  def find(*_arg0, **_arg1, &_arg2); end
  def find_all(*_arg0, **_arg1, &_arg2); end
  def find_button(*_arg0, **_arg1, &_arg2); end
  def find_by_id(*_arg0, **_arg1, &_arg2); end
  def find_field(*_arg0, **_arg1, &_arg2); end
  def find_link(*_arg0, **_arg1, &_arg2); end
  def first(*_arg0, **_arg1, &_arg2); end
  def go_back(*_arg0, **_arg1, &_arg2); end
  def go_forward(*_arg0, **_arg1, &_arg2); end
  def has_button?(*_arg0, **_arg1, &_arg2); end
  def has_checked_field?(*_arg0, **_arg1, &_arg2); end
  def has_content?(*_arg0, **_arg1, &_arg2); end
  def has_css?(*_arg0, **_arg1, &_arg2); end
  def has_current_path?(*_arg0, **_arg1, &_arg2); end
  def has_field?(*_arg0, **_arg1, &_arg2); end
  def has_link?(*_arg0, **_arg1, &_arg2); end
  def has_no_button?(*_arg0, **_arg1, &_arg2); end
  def has_no_checked_field?(*_arg0, **_arg1, &_arg2); end
  def has_no_content?(*_arg0, **_arg1, &_arg2); end
  def has_no_css?(*_arg0, **_arg1, &_arg2); end
  def has_no_current_path?(*_arg0, **_arg1, &_arg2); end
  def has_no_field?(*_arg0, **_arg1, &_arg2); end
  def has_no_link?(*_arg0, **_arg1, &_arg2); end
  def has_no_select?(*_arg0, **_arg1, &_arg2); end
  def has_no_selector?(*_arg0, **_arg1, &_arg2); end
  def has_no_table?(*_arg0, **_arg1, &_arg2); end
  def has_no_text?(*_arg0, **_arg1, &_arg2); end
  def has_no_title?(*_arg0, **_arg1, &_arg2); end
  def has_no_unchecked_field?(*_arg0, **_arg1, &_arg2); end
  def has_no_xpath?(*_arg0, **_arg1, &_arg2); end
  def has_select?(*_arg0, **_arg1, &_arg2); end
  def has_selector?(*_arg0, **_arg1, &_arg2); end
  def has_table?(*_arg0, **_arg1, &_arg2); end
  def has_text?(*_arg0, **_arg1, &_arg2); end
  def has_title?(*_arg0, **_arg1, &_arg2); end
  def has_unchecked_field?(*_arg0, **_arg1, &_arg2); end
  def has_xpath?(*_arg0, **_arg1, &_arg2); end
  def html(*_arg0, **_arg1, &_arg2); end
  def open_new_window(*_arg0, **_arg1, &_arg2); end

  # Shortcut to accessing the current session.
  #
  #     class MyClass
  #       include Capybara::DSL
  #
  #       def has_header?
  #         page.has_css?('h1')
  #       end
  #     end
  #
  # @return [Capybara::Session] The current session object
  def page; end

  def query(*_arg0, **_arg1, &_arg2); end
  def refresh(*_arg0, **_arg1, &_arg2); end
  def refute_selector(*_arg0, **_arg1, &_arg2); end
  def reset_session!(*_arg0, **_arg1, &_arg2); end
  def response_headers(*_arg0, **_arg1, &_arg2); end
  def save_and_open_page(*_arg0, **_arg1, &_arg2); end
  def save_and_open_screenshot(*_arg0, **_arg1, &_arg2); end
  def save_page(*_arg0, **_arg1, &_arg2); end
  def save_screenshot(*_arg0, **_arg1, &_arg2); end
  def screenshot_and_open_image; end

  # Adds class methods to Capybara module and gets mixed into
  # the current scope during Cucumber and RSpec tests
  def screenshot_and_save_page; end

  def scroll_by(*_arg0, **_arg1, &_arg2); end
  def scroll_to(*_arg0, **_arg1, &_arg2); end
  def select(*_arg0, **_arg1, &_arg2); end
  def send_keys(*_arg0, **_arg1, &_arg2); end
  def source(*_arg0, **_arg1, &_arg2); end
  def status_code(*_arg0, **_arg1, &_arg2); end
  def switch_to_frame(*_arg0, **_arg1, &_arg2); end
  def switch_to_window(*_arg0, **_arg1, &_arg2); end
  def text(*_arg0, **_arg1, &_arg2); end
  def title(*_arg0, **_arg1, &_arg2); end
  def uncheck(*_arg0, **_arg1, &_arg2); end
  def unselect(*_arg0, **_arg1, &_arg2); end

  # Shortcut to working in a different session.
  def using_session(name_or_session, &block); end

  # Shortcut to using a different wait time.
  def using_wait_time(seconds, &block); end

  def visit(*_arg0, **_arg1, &_arg2); end
  def window_opened_by(*_arg0, **_arg1, &_arg2); end
  def windows(*_arg0, **_arg1, &_arg2); end
  def within(*_arg0, **_arg1, &_arg2); end
  def within_element(*_arg0, **_arg1, &_arg2); end
  def within_fieldset(*_arg0, **_arg1, &_arg2); end
  def within_frame(*_arg0, **_arg1, &_arg2); end
  def within_table(*_arg0, **_arg1, &_arg2); end
  def within_window(*_arg0, **_arg1, &_arg2); end

  class << self
    # @private
    def extended(base); end

    # @private
    # @private
    def included(base); end
  end
end

module Capybara::Screenshot
  class << self
    def after_save_html(&block); end
    def after_save_screenshot(&block); end

    # Returns the value of attribute append_random.
    def append_random; end

    # Sets the attribute append_random
    #
    # @param value the value to set the attribute append_random to.
    def append_random=(_arg0); end

    def append_screenshot_path=(value); end

    # Returns the value of attribute append_timestamp.
    def append_timestamp; end

    # Sets the attribute append_timestamp
    #
    # @param value the value to set the attribute append_timestamp to.
    def append_timestamp=(_arg0); end

    # Returns the value of attribute autosave_on_failure.
    def autosave_on_failure; end

    # Sets the attribute autosave_on_failure
    #
    # @param value the value to set the attribute autosave_on_failure to.
    def autosave_on_failure=(_arg0); end

    def capybara_root; end

    # If the path isn't set, default to the current directory
    def capybara_tmp_path; end

    # Configure the path unless '.'
    def capybara_tmp_path=(path); end

    def filename_prefix_for(test_type, test); end

    # Returns the value of attribute filename_prefix_formatters.
    def filename_prefix_formatters; end

    # Sets the attribute filename_prefix_formatters
    #
    # @param value the value to set the attribute filename_prefix_formatters to.
    def filename_prefix_formatters=(_arg0); end

    def final_session_name; end

    # Sets the attribute final_session_name
    #
    # @param value the value to set the attribute final_session_name to.
    def final_session_name=(_arg0); end

    def new_saver(*args); end

    # Prune screenshots based on prune_strategy
    # Will run only once unless force:true
    def prune(options = T.unsafe(nil)); end

    # Returns the value of attribute prune_strategy.
    def prune_strategy; end

    # Sets the attribute prune_strategy
    #
    # @param value the value to set the attribute prune_strategy to.
    def prune_strategy=(_arg0); end

    def register_driver(driver, &block); end
    def register_filename_prefix_formatter(test_type, &block); end

    # Returns the value of attribute registered_drivers.
    def registered_drivers; end

    # Sets the attribute registered_drivers
    #
    # @param value the value to set the attribute registered_drivers to.
    def registered_drivers=(_arg0); end

    # Reset prune history allowing further prunining on next failure
    def reset_prune_history; end

    # Returns the value of attribute s3_configuration.
    def s3_configuration; end

    # Sets the attribute s3_configuration
    #
    # @param value the value to set the attribute s3_configuration to.
    def s3_configuration=(_arg0); end

    # Returns the value of attribute s3_object_configuration.
    def s3_object_configuration; end

    # Sets the attribute s3_object_configuration
    #
    # @param value the value to set the attribute s3_object_configuration to.
    def s3_object_configuration=(_arg0); end

    def screen_shot_and_open_image; end
    def screen_shot_and_save_page; end
    def screenshot_and_open_image; end
    def screenshot_and_save_page; end

    # Returns the value of attribute webkit_options.
    def webkit_options; end

    # Sets the attribute webkit_options
    #
    # @param value the value to set the attribute webkit_options to.
    def webkit_options=(_arg0); end
  end
end

module Capybara::Screenshot::Callbacks
  include ::Capybara::Screenshot::Callbacks::InstanceMethods

  mixes_in_class_methods ::Capybara::Screenshot::Callbacks::ClassMethods

  class << self
    # @private
    def included(receiver); end
  end
end

class Capybara::Screenshot::Callbacks::CallbackSet < ::Array
  def call(*args); end
end

module Capybara::Screenshot::Callbacks::ClassMethods
  def callbacks; end
  def define_callback(name); end
  def run_callbacks(name, *args); end
end

module Capybara::Screenshot::Callbacks::InstanceMethods
  def run_callbacks(name, *args); end
end

class Capybara::Screenshot::Pruner
  # @return [Pruner] a new instance of Pruner
  def initialize(strategy); end

  def prune_old_screenshots; end

  # Returns the value of attribute strategy.
  def strategy; end

  private

  def prune_with_last_run_strategy; end
  def prune_with_numeric_strategy(count); end
  def strategy_proc; end
  def wildcard_path; end
end

class Capybara::Screenshot::Saver
  include ::Capybara::Screenshot::Callbacks
  include ::Capybara::Screenshot::Callbacks::InstanceMethods
  extend ::Capybara::Screenshot::Callbacks::ClassMethods

  # @return [Saver] a new instance of Saver
  def initialize(capybara, page, html_save = T.unsafe(nil), filename_prefix = T.unsafe(nil)); end

  # Returns the value of attribute capybara.
  def capybara; end

  # If Capybara::Screenshot.capybara_tmp_path is set then
  # the html_path or screenshot_path can be appended to this path in
  # some versions of Capybara instead of using it as an absolute path
  def clear_save_path; end

  # Print image to screen, if imgcat is available
  def display_image; end

  # Returns the value of attribute file_base_name.
  def file_base_name; end

  def html_path; end

  # @return [Boolean]
  def html_saved?; end

  def output_screenshot_path; end

  # Returns the value of attribute page.
  def page; end

  def save; end
  def save_html; end
  def save_screenshot; end
  def screenshot_path; end

  # @return [Boolean]
  def screenshot_saved?; end

  private

  # @yield [path]
  def current_path; end

  def imgcat; end
  def output(message); end

  # Cross-platform way of finding an executable in the $PATH.
  #
  #   which('ruby') #=> /usr/bin/ruby
  def which(cmd); end

  def within_offending_window; end

  class << self
    def after_save_html(&block); end
    def after_save_screenshot(&block); end
  end
end

module Capybara::SessionScreenshotOverrides
  def within_window(window_or_handle); end
end

Capybara::VERSION = T.let(T.unsafe(nil), String)
class CapybaraScreenshot; end

module CapybaraScreenshot::Helpers
  extend ::CapybaraScreenshot::Helpers

  def black(text); end
  def blue(text); end
  def bright_black(text); end
  def bright_blue(text); end
  def bright_cyan(text); end
  def bright_green(text); end
  def bright_magenta(text); end
  def bright_purple(text); end
  def bright_red(text); end
  def bright_white(text); end
  def bright_yellow(text); end
  def cyan(text); end
  def green(text); end
  def magenta(text); end
  def purple(text); end
  def red(text); end
  def white(text); end
  def yellow(text); end
end

CapybaraScreenshot::Helpers::COLORS = T.let(T.unsafe(nil), Hash)
